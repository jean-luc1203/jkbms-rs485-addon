[
    {
        "id": "0f3c5bd285141d40",
        "type": "tab",
        "label": "Warning - Avertissement",
        "disabled": false,
        "info": ""
    },
    {
        "id": "b1ca67b21089b915",
        "type": "tab",
        "label": "Initialisations",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "ce01fabde0618f55",
        "type": "tab",
        "label": "Lecture RS485",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "348d851bc48bb663",
        "type": "tab",
        "label": "Setup RS485",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "7eba58462314a0d7",
        "type": "tab",
        "label": "Lecture Broadascting RS485",
        "disabled": false,
        "info": "Dans ce cas, il y a un des BMS qui est \r\ndéfini en maitre du bus rs485. C'est lui \r\nqui va aller demander les informations aux\r\nautres BMS.\r\nDans cette configuration, on ne peut pas\r\nchanger les paramètres car il ne peut pas\r\ny avoir 2 Master sur le bus en modbus.",
        "env": []
    },
    {
        "id": "2e99fd421b434bcb",
        "type": "tab",
        "label": "CAN bus",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "6fc9763d4087338c",
        "type": "subflow",
        "name": "Subflow 1",
        "info": "",
        "category": "",
        "in": [],
        "out": [],
        "env": [],
        "meta": {},
        "color": "#DDAA99"
    },
    {
        "id": "0693b9727dec471d",
        "type": "group",
        "z": "ce01fabde0618f55",
        "name": "Phase initialisation & lecture automatique (1 seule demande modbus)",
        "style": {
            "stroke": "#000000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "d84c3f32b5bee13a",
            "1430199873abea94",
            "9df6cb4f228ce42d",
            "61eadd92484325e7",
            "c054e6c82bc4bb0a",
            "6ca55c256080e1c0",
            "73bb9117fd0b3a8e",
            "4deeee03e0b1768d",
            "16f7228e721581da",
            "2d3862f26efaad60",
            "bfc4f86c756f8e57",
            "348ec2d0147bf36c",
            "a3bd0a6eeb93d67f",
            "074c128ffe1701e8",
            "935c37a416cb0336",
            "a632bb3545ad81d5",
            "389031f7d149d0e4",
            "bbfdd16be70fd7b0",
            "b7c41933feffd518",
            "7fc90ebca81725ca",
            "3f472b31a16a5124",
            "5d8b1329cf980408",
            "73cf0d220e1de798",
            "e45ebcb6cea88b4b",
            "35900806dc5fb044"
        ],
        "x": 14,
        "y": 499,
        "w": 1262,
        "h": 362
    },
    {
        "id": "9c42cd07964fe992",
        "type": "group",
        "z": "ce01fabde0618f55",
        "name": "Port Série Out",
        "style": {
            "stroke": "#ff0000",
            "label": true,
            "color": "#000000",
            "fill": "#ffbfbf"
        },
        "nodes": [
            "19e4f82b41b8041a",
            "5e23433b1e088edf",
            "9fb62a629d09612b",
            "47ab0322cedc3c22",
            "54c93e67707946a8"
        ],
        "x": 434,
        "y": 279,
        "w": 352,
        "h": 122
    },
    {
        "id": "1bb1485c6f644ee6",
        "type": "group",
        "z": "ce01fabde0618f55",
        "name": "Décodage des trames 1 - 2 - 3",
        "style": {
            "stroke": "#ffC000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "2621a947da028681",
            "300c67230e4e510a",
            "6152557feb0eac9a",
            "c516cfa766ac29a1",
            "7bd0459073759ca1",
            "b17bb5bd16c1be78",
            "bff0d4fab3ef46a5",
            "2e57321f85689f45",
            "c06c156ddb36634e",
            "fd734524924bf8a8",
            "95b5286db50cb893"
        ],
        "x": 18,
        "y": 899,
        "w": 1034,
        "h": 768
    },
    {
        "id": "18188dc49c4fd89a",
        "type": "group",
        "z": "348d851bc48bb663",
        "name": "Lecture des setup arrivant depuis HAOS",
        "style": {
            "stroke": "#ff0000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "02dd5257a29af5a6",
            "aa260e367192285d",
            "81acf21e86521b86",
            "d9252d611463a606",
            "32701e033c9ee445",
            "8f82452292423562",
            "d866e088f62e39db",
            "f446b30dc2078f42",
            "223504123cb3206a",
            "3b20d857112c188b",
            "0feab4f81e28026c",
            "37a35ec9033764b1",
            "b6ad66b9c7594229",
            "0e879f0b1033923c"
        ],
        "x": 14,
        "y": 59,
        "w": 842,
        "h": 242
    },
    {
        "id": "0bbb61cb5f6504ae",
        "type": "group",
        "z": "348d851bc48bb663",
        "name": "Write Setup Valeurs",
        "style": {
            "stroke": "#6f2fa0",
            "label": true,
            "color": "#6f2fa0"
        },
        "nodes": [
            "133adc320649ffd0",
            "1b9d270fb278785c",
            "0f8129c7962fb889",
            "5132d56fbde6fce4",
            "9cdaf1add7c8c49f",
            "5818d18351e2505a",
            "e1f20160d6873a16",
            "831223922b6e7a42",
            "fd1c6b82e6f4c66b",
            "bb7a17a27dd64e00",
            "bceacd21b82896e0",
            "c84672a0371bb1cc",
            "57c093189c8bb8cb",
            "bd140493b7942afa",
            "3317efd75feda45f",
            "edda4776590c41a7",
            "c2528c16e766563a",
            "666ac34f65df37fe",
            "c939f58b7a5ce3a1",
            "b9c43c59d83a114b",
            "834f13ebf4e4b0aa",
            "a08c1b9678760404",
            "9877b4d7a594f576",
            "57a2d5e590849c4c",
            "b2b2a91d76d8b8ef",
            "070294cbb6631c51",
            "18100f82ea9b96e2",
            "82a079d96e716dfb",
            "a2d933bf5714917f",
            "f69bb43232dd2c3b",
            "e1b5d6daa74cc917",
            "10d7690719c5a734",
            "452323515d5b4f2d",
            "ca1db571bf48ece1",
            "25bbb554698f3085",
            "d4b59e37e854b67d",
            "4782063a6f4cbb89",
            "b545eac4a5a827f8",
            "b997b486b520ba66",
            "969bfbdc6ff80482",
            "842d499ea9fe3f9c",
            "830726d692b9c886",
            "b4210ea0e3eceeca",
            "19813c881712a20f",
            "1d8951e6d5cadaac",
            "bcb6622b78752c20"
        ],
        "x": 54,
        "y": 419,
        "w": 942,
        "h": 1482
    },
    {
        "id": "4cfdd0fab949bb3c",
        "type": "group",
        "z": "b1ca67b21089b915",
        "name": "Configuration du port USB RS485",
        "style": {
            "stroke": "#000000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "36ac99672d282e93",
            "00678a50f9f3ef9c",
            "0c9baa364697bbfe",
            "df5482d67ec293f9",
            "49c92598895378e1"
        ],
        "x": 14,
        "y": 359,
        "w": 1052,
        "h": 82
    },
    {
        "id": "d9178a09ade71024",
        "type": "group",
        "z": "b1ca67b21089b915",
        "name": "Initialisation des variables",
        "style": {
            "stroke": "#000000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "3fba971ea0547c66",
            "3ecb0dcd9663050d",
            "c8e26f4ca5e76e36"
        ],
        "x": 8,
        "y": 19,
        "w": 1064,
        "h": 308
    },
    {
        "id": "c1fd93cd8f38ea7c",
        "type": "group",
        "z": "b1ca67b21089b915",
        "name": "MQTT définitions",
        "style": {
            "stroke": "#000000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "0c319b0244658cad",
            "80a0031e2a8dbfbc",
            "355fec0a2e1aaf7a",
            "b82078ca27edc9db",
            "58adbc8abf20aab0",
            "4e25b5fa6500606e",
            "66ce0bd5261eb149",
            "63efeee1a97e3bb9",
            "323bc1fdf8eb4b0e",
            "468d5c1a95681d8d"
        ],
        "x": 34,
        "y": 499,
        "w": 772,
        "h": 182
    },
    {
        "id": "fcf5dd3bc6e97b81",
        "type": "group",
        "z": "ce01fabde0618f55",
        "name": "Gateway Ethernet or Wifi",
        "style": {
            "stroke": "#0070c0",
            "fill": "#bfdbef",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "f1e5252af3527154",
            "55581e8fd2063a3b",
            "5f1cc6f02653dd86",
            "03d54d1f353534ca",
            "72408cddd3840bf2",
            "b2892effe9f79e84",
            "fbd3591a98eafd6d",
            "3de40e166b34cd30"
        ],
        "x": 814,
        "y": 239,
        "w": 392,
        "h": 222
    },
    {
        "id": "71ff535abf2657b3",
        "type": "group",
        "z": "7eba58462314a0d7",
        "name": "Port Série Out",
        "style": {
            "stroke": "#ff0000",
            "label": true,
            "color": "#000000",
            "fill": "#ffbfbf",
            "fill-opacity": "0.21"
        },
        "nodes": [
            "24f7bb18c1109510",
            "a760f49cb3f03843",
            "b28c235f729ec2af",
            "d2613e804a5c9e0d",
            "41542c3844b4344a",
            "cc1ee5cb46e0c0b3",
            "cdc3910800c7d95b",
            "76ddac3ef98c9d5f"
        ],
        "x": 14,
        "y": 359,
        "w": 972,
        "h": 162
    },
    {
        "id": "09da833fe1650dca",
        "type": "group",
        "z": "7eba58462314a0d7",
        "name": "Décodage des trames \"setup\" & \"data\"",
        "style": {
            "stroke": "#ffC000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "b75a55c2aaa3b2b6",
            "a1697c874f4c5e2d",
            "c7bb4746ce710cb1"
        ],
        "x": 8,
        "y": 573,
        "w": 824,
        "h": 534
    },
    {
        "id": "6c19eb9e84cdf38b",
        "type": "group",
        "z": "b1ca67b21089b915",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "0ec51b6fd8d48038",
            "84db6ed2a0945bdd",
            "a0a0d9469406c5a8",
            "b38da9cc0fe45944",
            "18be8868fd9888b7",
            "567fe9a7f3910323",
            "32d98207bb37887d",
            "9d3d9cd9d0aaf884",
            "ea424593a0b6533a",
            "4a6179de378fa7c5",
            "6fa5d0c215b7e641",
            "8bcf0e0b17b0565f"
        ],
        "x": 34,
        "y": 979,
        "w": 492,
        "h": 282
    },
    {
        "id": "09c8d74836111377",
        "type": "group",
        "z": "b1ca67b21089b915",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "2f1946e570f89af5",
            "4b621344460ef394"
        ],
        "x": 574,
        "y": 1089.199951171875,
        "w": 312,
        "h": 131.800048828125
    },
    {
        "id": "8db7330998795c6b",
        "type": "group",
        "z": "7eba58462314a0d7",
        "name": "Check si on est en position broadcast sur le JKBMS Master et si on utilise le Gateway Ethernet or Wifi. Si oui, il faut établir une fois la connexion IP",
        "style": {
            "stroke": "#0070c0",
            "fill": "#bfdbef",
            "label": true,
            "color": "#000000",
            "fill-opacity": "0.21"
        },
        "nodes": [
            "54f13db307ef04c6",
            "44c1946af35b4bf2",
            "ac5e2007494e8ec7",
            "39deea4e80f940dc",
            "36740c8949df9213",
            "9065a93867dab80e",
            "73d8b350243362a9",
            "312ad2b56727f9b0",
            "69b1ce57af6c5821"
        ],
        "x": 14,
        "y": 199,
        "w": 1112,
        "h": 122
    },
    {
        "id": "d03facb97e5d14d1",
        "type": "group",
        "z": "2e99fd421b434bcb",
        "name": "CAN read",
        "style": {
            "stroke": "#ff0000",
            "label": true,
            "color": "#ff0000"
        },
        "nodes": [
            "c3de74fe6e67e34d",
            "3228a87076560c09",
            "b1930c0f7c133e97",
            "0efe20eac7430343",
            "edddd5764795e5e8",
            "a382ef9233e091ce",
            "3468acfdfe712e73",
            "f42caadb5356ae1d"
        ],
        "x": 34,
        "y": 339,
        "w": 952,
        "h": 162
    },
    {
        "id": "1d5b0e71e0a2eba5",
        "type": "group",
        "z": "2e99fd421b434bcb",
        "name": "Up & Down & Bit rate",
        "style": {
            "label": true
        },
        "nodes": [
            "0ef8fc221e14acf6",
            "bfc557c471275022",
            "ab0eed874c8d277a",
            "505be46f8eda2768",
            "f73071ac18154111",
            "f5dfca4e639fa942",
            "876fccdff470c9e9",
            "7dc27bfd806f5368",
            "c3b71c2f1a714c85",
            "64ae959294b9f406",
            "4b1f866ae32190f9",
            "ac59461acfb2cc71"
        ],
        "x": 734,
        "y": 1439,
        "w": 752,
        "h": 322
    },
    {
        "id": "2584ccec0ec42693",
        "type": "group",
        "z": "2e99fd421b434bcb",
        "name": "CAN décodage",
        "style": {
            "stroke": "#ffff00",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "db723bbce9cd2eb7",
            "427020bec4bb2db0",
            "cf375bcb018ce6c2",
            "c2369537eb2295bb",
            "2a10c4fd52fdcdbf",
            "f28c4eb22257478c",
            "b84f87970c11f14e",
            "e7576279e8153b1b",
            "80a3b32d9f0f0730",
            "8603c29f2c2105d4",
            "7821b4f3d5cbe3df",
            "0a5f6e32247b194d",
            "75044b278b31a047",
            "89d6590a094825e7",
            "788e057cc57fcb4c",
            "ed8a4b44d9f1a840",
            "c955aacbd7372820",
            "33664bc1723b2cde",
            "8c4ae23f7fadd63d",
            "cf27fc9e687cec75",
            "ecea4cb337311c7f",
            "5db3845569e2eacb",
            "21eb77fc0deb7df8",
            "91aacf4dfc2f6b45",
            "8144d8148f4c0840",
            "1daa9e6390671ea8",
            "72b36b4609b42dba",
            "0005b67220843057",
            "9de87061f754ddf9",
            "b188deca5d12b002"
        ],
        "x": 34,
        "y": 539,
        "w": 1058,
        "h": 768
    },
    {
        "id": "ccc1258cc5051fb2",
        "type": "group",
        "z": "2e99fd421b434bcb",
        "name": "Show",
        "style": {
            "label": true
        },
        "nodes": [
            "0d119ba5972c169a",
            "91b2a628817de544",
            "e568cd8b91c96fff",
            "19e2a3758a49f532"
        ],
        "x": 734,
        "y": 1819,
        "w": 582,
        "h": 122
    },
    {
        "id": "9ca59e5665a543ec",
        "type": "group",
        "z": "2e99fd421b434bcb",
        "name": "Pour debug only",
        "style": {
            "stroke": "#a4a4a4",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "459611fc12f08799",
            "70175f15e3a96645",
            "851759d8657506d7",
            "a11b6d0e18d66357",
            "cc70f856bb715e58",
            "5832fe6540f56826",
            "cc58661e52c4af01",
            "0114fcc43bfd35e2",
            "a518317b59bd58da",
            "5c3517a74be5a7e7",
            "840d9bc33fc7e3e4",
            "49530b441302aacc",
            "0d4939b7cbb31bb3",
            "156de1e34b3811c8",
            "646f282c0dd63a6e"
        ],
        "x": 34,
        "y": 1339,
        "w": 638,
        "h": 722
    },
    {
        "id": "c002b2b718abc28f",
        "type": "group",
        "z": "2e99fd421b434bcb",
        "name": "Initialisation de l'interface",
        "style": {
            "stroke": "#6f2fa0",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "5cfaee00ed1d945e",
            "93acca2bdf879a01",
            "81797f8435ea4090",
            "33e185e362f95f82",
            "d09a3cc293255be2",
            "4c7382e365ab7a48",
            "b3cc6af46b5e8003",
            "b5fefa24fa332bb0",
            "a1212ebb1907b570",
            "89480d3fdae61266",
            "606759ae352bbf73",
            "918a82299c32dcf9"
        ],
        "x": 34,
        "y": 19,
        "w": 852,
        "h": 269.5
    },
    {
        "id": "fcb249897b0ead9e",
        "type": "group",
        "z": "2e99fd421b434bcb",
        "name": "Globale Variable change",
        "style": {
            "stroke": "#bfdbef",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "69e938ba030b7546",
            "795828b453f64b9b",
            "748d73da83bca2cf",
            "b30c7fb6356f631e"
        ],
        "x": 914,
        "y": 59,
        "w": 472,
        "h": 122
    },
    {
        "id": "fc42763da6defab8",
        "type": "group",
        "z": "ce01fabde0618f55",
        "name": "Permet de ne faire qu'une seule passe pour les  discovery topic de HAOS",
        "style": {
            "label": true
        },
        "nodes": [
            "8666d6cf3f8a75cc",
            "bd13172ab7887f84",
            "5b29999d7fdc4120",
            "e77b486cbdcfe2b9"
        ],
        "x": 44,
        "y": 19,
        "w": 602,
        "h": 162
    },
    {
        "id": "ce6083697fa14dc0",
        "type": "group",
        "z": "ce01fabde0618f55",
        "name": "Debug des données",
        "style": {
            "stroke": "#007000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "993c2383b70be9f1",
            "0b8826e5e66ac591",
            "898dd8cf77551382",
            "9cd19b0cda3b295b",
            "4c96f83e2c664c74",
            "276f29f9528f1322",
            "a4215bec9779ed8c",
            "3c1b49123cabedb0",
            "8eea8a8ef9220c22"
        ],
        "x": 14,
        "y": 1699,
        "w": 712,
        "h": 242
    },
    {
        "id": "e09fcfa37fa58cc8",
        "type": "group",
        "z": "ce01fabde0618f55",
        "name": "Envoi des commandes Setup vers le port série ou IP",
        "style": {
            "stroke": "#92d04f",
            "label": true,
            "color": "#6f2fa0",
            "fill": "#c8e7a7",
            "fill-opacity": "0.37"
        },
        "nodes": [
            "fa351cb08a5d02e9",
            "bb64089a3c76b396",
            "54a82bd9914c48e5",
            "0e2831f9e2a8e7cf",
            "6542c8ba28167fbf"
        ],
        "x": 44,
        "y": 239,
        "w": 334,
        "h": 162
    },
    {
        "id": "646f282c0dd63a6e",
        "type": "group",
        "z": "2e99fd421b434bcb",
        "g": "9ca59e5665a543ec",
        "name": "16 Cell's volatge",
        "style": {
            "stroke": "#92d04f",
            "label": true
        },
        "nodes": [
            "181f7ced3cb4faf7",
            "8264c8cacce70110",
            "95ae122462034c80",
            "890d83e4ddd29134"
        ],
        "x": 294,
        "y": 1619,
        "w": 352,
        "h": 202
    },
    {
        "id": "9de87061f754ddf9",
        "type": "group",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "16 Cell's volatge",
        "style": {
            "stroke": "#92d04f",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "59a32da84f1d558f",
            "6012cd81c0bcf535",
            "7052b31a5e638f20",
            "13609daae25e3257",
            "52d83545146677d4",
            "5902f421447b046d",
            "e78e87fb719b450d",
            "c50f23a0e0297de8",
            "1b8d8f8af7b7474f",
            "7d97f7131d3497a0",
            "32e8d6abd9ac44d0",
            "740e7dc1d40c5efa",
            "4be4303ae0f078dc"
        ],
        "x": 234,
        "y": 819,
        "w": 832,
        "h": 202
    },
    {
        "id": "b188deca5d12b002",
        "type": "group",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "To MQTT Broker",
        "style": {
            "label": true,
            "stroke": "#0070c0",
            "fill": "#e3f3d3",
            "color": "#000000"
        },
        "nodes": [
            "7cdddbdff16d1585",
            "f491a2b292a65e24"
        ],
        "x": 704,
        "y": 1199,
        "w": 222,
        "h": 82
    },
    {
        "id": "c8e26f4ca5e76e36",
        "type": "group",
        "z": "b1ca67b21089b915",
        "g": "d9178a09ade71024",
        "name": "Récupération des variables définies dans la configuration du module depuis l'onglet configuration de HAOS",
        "style": {
            "stroke": "#000000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "12543920bca0a8e5",
            "5c144e0e135713c7",
            "9db46980e482d881",
            "2682276da62a0840",
            "b122ec506872171a",
            "416789eaf381cb09"
        ],
        "x": 34,
        "y": 179,
        "w": 1012,
        "h": 122
    },
    {
        "id": "bff0d4fab3ef46a5",
        "type": "group",
        "z": "ce01fabde0618f55",
        "g": "1bb1485c6f644ee6",
        "name": "Trame 1 - Specifications statiques",
        "style": {
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "b2d928a2b649fe63",
            "bbe7f5ddcea331a9",
            "264d6f5686cf22f1",
            "7a45939101576456",
            "2492d95ecc9f328c",
            "32a6b862b301b073",
            "cb1a7697e8293f75",
            "f15bd83b2cddefde",
            "1c51761e84ee5bb2"
        ],
        "x": 44,
        "y": 1119,
        "w": 902,
        "h": 142
    },
    {
        "id": "2e57321f85689f45",
        "type": "group",
        "z": "ce01fabde0618f55",
        "g": "1bb1485c6f644ee6",
        "name": "Trame 3 - Data des BMS en live",
        "style": {
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "a6b1b65a3e856d8f",
            "4c893435cad6711e",
            "c0f222bb926bd319",
            "d8f9f00da2e3a338",
            "97a3abc79a4c67cd",
            "60a06da8cc236522",
            "c6f86ca54e23c581",
            "609d1962222fd9ae",
            "341f048d7cd2addd",
            "15033939a61ddd92",
            "65f7cb3119d4baa9",
            "cd88b13577b5a05a",
            "705a77e3b053f7ca"
        ],
        "x": 134,
        "y": 1419,
        "w": 892,
        "h": 222
    },
    {
        "id": "c06c156ddb36634e",
        "type": "group",
        "z": "ce01fabde0618f55",
        "g": "1bb1485c6f644ee6",
        "name": "Trame 2 - Settings des BMS",
        "style": {
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "867fca3b9f77ce27",
            "3987f9e640e885a6",
            "dde116783a665a3f",
            "34f5429239508138",
            "d07dea014d2dd68a",
            "f62828b434e3951b",
            "ea72bb742b3422f7",
            "0780657340cd75cc"
        ],
        "x": 84,
        "y": 1279,
        "w": 902,
        "h": 122
    },
    {
        "id": "b75a55c2aaa3b2b6",
        "type": "group",
        "z": "7eba58462314a0d7",
        "g": "09da833fe1650dca",
        "name": "Trame \"data\"",
        "style": {
            "label": true,
            "color": "#000000",
            "fill": "#addb7b",
            "fill-opacity": "0.24"
        },
        "nodes": [
            "bc098ac8e7c2a80e",
            "e207f8c07a156191",
            "ace79b04ef5d3953",
            "b8c6447a9aadb290",
            "6ac6b1debaf96f4e",
            "e3768062bfabfaf0",
            "2773a8c67764f19a"
        ],
        "x": 34,
        "y": 959,
        "w": 692,
        "h": 122
    },
    {
        "id": "a1697c874f4c5e2d",
        "type": "group",
        "z": "7eba58462314a0d7",
        "g": "09da833fe1650dca",
        "name": "Trame \"setup\"",
        "style": {
            "label": true,
            "color": "#000000",
            "fill": "#ffbfbf",
            "fill-opacity": "0.22"
        },
        "nodes": [
            "d0b96287555baddd",
            "5379d0376efbcee9",
            "a4be995f90fc779c",
            "6ca68da351cc699c",
            "4716f48d98903bbc",
            "13e4f2a13df6fe21",
            "34aa954d066715d4"
        ],
        "x": 34,
        "y": 819,
        "w": 692,
        "h": 122
    },
    {
        "id": "c7bb4746ce710cb1",
        "type": "group",
        "z": "7eba58462314a0d7",
        "g": "09da833fe1650dca",
        "name": "",
        "style": {
            "stroke": "#0070c0",
            "stroke-opacity": "0.44",
            "label": true,
            "fill": "#bfdbef",
            "fill-opacity": "0.15"
        },
        "nodes": [
            "74c53c8fdd7c6f6e",
            "1bb4998cb85dda4e",
            "a65a870d600bb230",
            "88b164ac7026be0e",
            "40053a1d91143e21",
            "06b6d386a10741c2",
            "9bf8da3dfdb70216"
        ],
        "x": 34,
        "y": 599,
        "w": 772,
        "h": 142
    },
    {
        "id": "6e1abcbcc6ebb714",
        "type": "serial-port",
        "name": "JKBMS-RS485-Fake",
        "serialport": "/dev/JKBMS-Fake",
        "serialbaud": "115200",
        "databits": 8,
        "parity": "none",
        "stopbits": 1,
        "waitfor": "",
        "dtr": "none",
        "rts": "none",
        "cts": "none",
        "dsr": "none",
        "newline": "50",
        "bin": "bin",
        "out": "interbyte",
        "addchar": "",
        "responsetimeout": "500"
    },
    {
        "id": "56f7b2737cce493b",
        "type": "mqtt-broker",
        "name": "",
        "broker": "core-mosquitto.local.hass.io",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "346118cfe13b92d2",
        "type": "global-config",
        "env": [],
        "modules": {
            "node-red-node-serialport": "2.0.3",
            "node-red-contrib-buffer-parser": "3.2.2",
            "node-red-contrib-tcp-client2": "1.1.3"
        }
    },
    {
        "id": "bd32d7ad2e41fd6b",
        "type": "inject",
        "z": "6fc9763d4087338c",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "url",
                "v": "https://domosimple.eu/valide/check_license.php?license_key=LIC-675AA47154DF52.6175956",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "",
        "payload": "",
        "payloadType": "str",
        "x": 100,
        "y": 100,
        "wires": [
            [
                "baef5c9129331285"
            ]
        ]
    },
    {
        "id": "1ce6a7eabb31a0e3",
        "type": "function",
        "z": "6fc9763d4087338c",
        "name": "function 99",
        "func": "// Vérifier si le payload est une chaîne JSON\ntry {\n    // Tenter de parser la chaîne JSON dans le payload\n    var jsonData = JSON.parse(msg.payload);\n\n    // Maintenant vous pouvez accéder aux propriétés de jsonData\n    msg.payload = {\n        status: jsonData.status,\n        expiration: jsonData.expiration\n    };\n\n} catch (e) {\n    // Si le parsing échoue, afficher une erreur et conserver l'ancienne valeur\n    node.error(\"Erreur de parsing JSON : \" + e.message);\n\n    // En cas d'erreur de parsing, récupérer la date d'expiration depuis les paramètres globaux\n    msg.payload = {\n        expiration: global.get('parametre.li.expiration'),\n        erreur: \"Problème serveur, mais licence toujours valide\",\n        status: true // Le statut reste à true, indiquant que la licence existe toujours\n    };\n}\n\n// Fonction pour vérifier la date d'expiration avec le serveur\nif (msg.payload.status === \"true\" || msg.payload.status === true) {\n    // Licence existe, vérifier la date d'expiration\n    const expirationDate = new Date(msg.payload.expiration); // Convertir la date d'expiration au format Date\n    const currentDate = new Date();\n\n    // Comparer les deux dates\n    if (expirationDate < currentDate) {\n        msg.payload.status = false;  // Licence expirée\n        global.set('parametre.li.active', false); // Mettre à jour le statut dans les paramètres globaux\n        global.set('parametre.li.expiration', expirationDate.toISOString()); // Enregistrer la date d'expiration\n        msg.erreur = \"License expirer\"\n        node.send(msg);\n    } else {\n        msg.payload.status = true; // Licence valide\n        global.set('parametre.li.active', true); // Mettre à jour le statut dans les paramètres globaux\n        global.set('parametre.li.expiration', expirationDate.toISOString()); // Enregistrer la date d'expiration\n    }\n} else {\n    // Licence n'existe pas ou problème de serveur\n    msg.payload.status = false; // Licence n'existe pas\n    global.set('parametre.li.active', false); // Mettre à jour le statut dans les paramètres globaux\n    global.set('parametre.li.expiration', null); // Pas de date d'expiration car la licence n'existe pas\n    msg.erreur = \"Licence n'existe pas\"\n    node.send(msg);\n}\n\n\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 750,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "a7bf12e890b893de",
        "type": "http request",
        "z": "6fc9763d4087338c",
        "name": "",
        "method": "GET",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 550,
        "y": 100,
        "wires": [
            [
                "1ce6a7eabb31a0e3"
            ]
        ]
    },
    {
        "id": "baef5c9129331285",
        "type": "function",
        "z": "6fc9763d4087338c",
        "name": "function 100",
        "func": "msg.license = global.get(\"parametre.li.num\");\nmsg.url = \"https://domosimple.eu/valide/valide.php?license_key=\" + msg.license\nmsg.headers = {\n    'Cache-Control': 'no-store, no-cache, must-revalidate, proxy-revalidate',\n    'Pragma': 'no-cache',\n    'Expires': '0'\n};\nreturn msg",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 310,
        "y": 100,
        "wires": [
            [
                "a7bf12e890b893de"
            ]
        ]
    },
    {
        "id": "438bd283fc7ed79f",
        "type": "comment",
        "z": "0f3c5bd285141d40",
        "name": "This software is the property of JLM . It is subject to intellectual property and copyright laws.",
        "info": "",
        "x": 330,
        "y": 134,
        "wires": []
    },
    {
        "id": "25c51ee819816528",
        "type": "comment",
        "z": "0f3c5bd285141d40",
        "name": "copyright ©JLM 2025",
        "info": "",
        "x": 120,
        "y": 74,
        "wires": []
    },
    {
        "id": "ff1ece7fe3612315",
        "type": "comment",
        "z": "0f3c5bd285141d40",
        "name": "Only JLM has the right to modify all or part of this software.",
        "info": "",
        "x": 230,
        "y": 260,
        "wires": []
    },
    {
        "id": "2c25611ae5eaf661",
        "type": "comment",
        "z": "0f3c5bd285141d40",
        "name": "It has been designed to manage JK-KONG BMS type: PBxA1xS1xP",
        "info": "",
        "x": 260,
        "y": 200,
        "wires": []
    },
    {
        "id": "e57773e891517763",
        "type": "comment",
        "z": "0f3c5bd285141d40",
        "name": "Do not transmit, copy or modify this software without the written consent of its authors.",
        "info": "",
        "x": 320,
        "y": 320,
        "wires": []
    },
    {
        "id": "1886fc8967eaf339",
        "type": "comment",
        "z": "0f3c5bd285141d40",
        "name": "According to article L335-3 of the French Intellectual Property Code, “infringement of one of the rights of the author of a software program as defined in article L122-6” constitutes an offence of counterfeiting.",
        "info": "",
        "x": 690,
        "y": 380,
        "wires": []
    },
    {
        "id": "212b75fb3d14df62",
        "type": "comment",
        "z": "0f3c5bd285141d40",
        "name": "Any infringement of a software author's rights can therefore be qualified as counterfeiting.",
        "info": "",
        "x": 330,
        "y": 440,
        "wires": []
    },
    {
        "id": "00678a50f9f3ef9c",
        "type": "function",
        "z": "b1ca67b21089b915",
        "g": "4cfdd0fab949bb3c",
        "name": "Setup USB Port",
        "func": "// récupère le port série à utiliser\n    msg.payload = {\n    \"serialport\": global.get(\"path\"),\n    \"serialbaud\": 115800,\n    \"databits\": 8,\n    \"parity\": \"none\",\n    \"stopbits\": 1,\n    \"enabled\": true\n    }\n\n    node.send(msg)",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 400,
        "wires": [
            [
                "df5482d67ec293f9"
            ]
        ]
    },
    {
        "id": "0c9baa364697bbfe",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "4cfdd0fab949bb3c",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1.5",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 130,
        "y": 400,
        "wires": [
            [
                "49c92598895378e1"
            ]
        ]
    },
    {
        "id": "df5482d67ec293f9",
        "type": "serial control",
        "z": "b1ca67b21089b915",
        "g": "4cfdd0fab949bb3c",
        "name": "JKBMS-RS485-Fake",
        "serial": "6e1abcbcc6ebb714",
        "x": 730,
        "y": 400,
        "wires": [
            [
                "36ac99672d282e93"
            ]
        ]
    },
    {
        "id": "36ac99672d282e93",
        "type": "debug",
        "z": "b1ca67b21089b915",
        "g": "4cfdd0fab949bb3c",
        "name": "Serial Control",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 400,
        "wires": []
    },
    {
        "id": "3fba971ea0547c66",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "d9178a09ade71024",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 130,
        "y": 60,
        "wires": [
            [
                "3ecb0dcd9663050d"
            ]
        ]
    },
    {
        "id": "3ecb0dcd9663050d",
        "type": "change",
        "z": "b1ca67b21089b915",
        "g": "d9178a09ade71024",
        "name": "initialisation slaveAddress-Trame-1-2-3",
        "rules": [
            {
                "t": "set",
                "p": "slaveAddress-Trame1",
                "pt": "global",
                "to": "1",
                "tot": "num"
            },
            {
                "t": "set",
                "p": "slaveAddress-Trame2",
                "pt": "global",
                "to": "1",
                "tot": "num"
            },
            {
                "t": "set",
                "p": "slaveAddress-Trame3",
                "pt": "global",
                "to": "1",
                "tot": "num"
            },
            {
                "t": "set",
                "p": "slaveAddress-setup",
                "pt": "global",
                "to": "1",
                "tot": "num"
            },
            {
                "t": "set",
                "p": "gateway_ip",
                "pt": "global",
                "to": "192.168.1.238",
                "tot": "str"
            },
            {
                "t": "set",
                "p": "gateway_port",
                "pt": "global",
                "to": "8887",
                "tot": "num"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 400,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "80a0031e2a8dbfbc",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "c1fd93cd8f38ea7c",
        "name": "disconnect",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "action",
                "v": "disconnect",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "0.5",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 540,
        "wires": [
            [
                "4e25b5fa6500606e"
            ]
        ]
    },
    {
        "id": "355fec0a2e1aaf7a",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "c1fd93cd8f38ea7c",
        "name": "connect",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 600,
        "wires": [
            [
                "b82078ca27edc9db"
            ]
        ]
    },
    {
        "id": "b82078ca27edc9db",
        "type": "function",
        "z": "b1ca67b21089b915",
        "g": "c1fd93cd8f38ea7c",
        "name": "Défiition du Broker",
        "func": "msg.action = \"connect\";\nmsg.broker = '{\"broker\":\"' + global.get(\"mqttadresse\")+'\",'\n    + '\"port\":\"' + global.get(\"mqttport\")+'\",'\n    + '\"username\":\"' + global.get(\"mqttuser\")+'\",'\n    + '\"password\":\"' + global.get(\"mqttpass\")+'\"'\n    +'}';\nreturn msg\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 600,
        "wires": [
            [
                "58adbc8abf20aab0"
            ]
        ]
    },
    {
        "id": "58adbc8abf20aab0",
        "type": "json",
        "z": "b1ca67b21089b915",
        "g": "c1fd93cd8f38ea7c",
        "name": "",
        "property": "broker",
        "action": "",
        "pretty": false,
        "x": 510,
        "y": 600,
        "wires": [
            [
                "4e25b5fa6500606e",
                "0c319b0244658cad",
                "468d5c1a95681d8d"
            ]
        ]
    },
    {
        "id": "4e25b5fa6500606e",
        "type": "mqtt out",
        "z": "b1ca67b21089b915",
        "g": "c1fd93cd8f38ea7c",
        "name": "MQTT Broker",
        "topic": "",
        "qos": "1",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 700,
        "y": 540,
        "wires": []
    },
    {
        "id": "0c319b0244658cad",
        "type": "debug",
        "z": "b1ca67b21089b915",
        "g": "c1fd93cd8f38ea7c",
        "name": "debug 23",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 680,
        "y": 600,
        "wires": []
    },
    {
        "id": "12543920bca0a8e5",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "c8e26f4ca5e76e36",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 220,
        "wires": [
            [
                "5c144e0e135713c7"
            ]
        ]
    },
    {
        "id": "5c144e0e135713c7",
        "type": "file in",
        "z": "b1ca67b21089b915",
        "g": "c8e26f4ca5e76e36",
        "name": "",
        "filename": "/data/options.json",
        "filenameType": "str",
        "format": "utf8",
        "chunk": false,
        "sendError": false,
        "encoding": "none",
        "allProps": false,
        "x": 350,
        "y": 220,
        "wires": [
            [
                "9db46980e482d881"
            ]
        ]
    },
    {
        "id": "9db46980e482d881",
        "type": "json",
        "z": "b1ca67b21089b915",
        "g": "c8e26f4ca5e76e36",
        "name": "",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 510,
        "y": 220,
        "wires": [
            [
                "b122ec506872171a",
                "416789eaf381cb09"
            ]
        ]
    },
    {
        "id": "2682276da62a0840",
        "type": "debug",
        "z": "b1ca67b21089b915",
        "g": "c8e26f4ca5e76e36",
        "name": "debug 97",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 220,
        "wires": []
    },
    {
        "id": "0ec51b6fd8d48038",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 1020,
        "wires": [
            [
                "84db6ed2a0945bdd"
            ]
        ]
    },
    {
        "id": "84db6ed2a0945bdd",
        "type": "change",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "GW true ",
        "rules": [
            {
                "t": "set",
                "p": "use_gateway",
                "pt": "global",
                "to": "true",
                "tot": "bool"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 320,
        "y": 1020,
        "wires": [
            []
        ]
    },
    {
        "id": "a0a0d9469406c5a8",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 1060,
        "wires": [
            [
                "b38da9cc0fe45944"
            ]
        ]
    },
    {
        "id": "b38da9cc0fe45944",
        "type": "change",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "GW false ",
        "rules": [
            {
                "t": "set",
                "p": "use_gateway",
                "pt": "global",
                "to": "false",
                "tot": "bool"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 320,
        "y": 1060,
        "wires": [
            []
        ]
    },
    {
        "id": "18be8868fd9888b7",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 1100,
        "wires": [
            [
                "567fe9a7f3910323"
            ]
        ]
    },
    {
        "id": "567fe9a7f3910323",
        "type": "change",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "BMS Broadcasting ? True",
        "rules": [
            {
                "t": "set",
                "p": "bms_broadcasting",
                "pt": "global",
                "to": "true",
                "tot": "bool"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 370,
        "y": 1100,
        "wires": [
            []
        ]
    },
    {
        "id": "32d98207bb37887d",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 1140,
        "wires": [
            [
                "9d3d9cd9d0aaf884"
            ]
        ]
    },
    {
        "id": "9d3d9cd9d0aaf884",
        "type": "change",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "BMS Broadcasting ? False",
        "rules": [
            {
                "t": "set",
                "p": "bms_broadcasting",
                "pt": "global",
                "to": "false",
                "tot": "bool"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 380,
        "y": 1140,
        "wires": [
            []
        ]
    },
    {
        "id": "2f1946e570f89af5",
        "type": "file",
        "z": "b1ca67b21089b915",
        "g": "09c8d74836111377",
        "name": "",
        "filename": "/config/temp/broadcast-bms.txt",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 730,
        "y": 1180,
        "wires": [
            []
        ]
    },
    {
        "id": "4b621344460ef394",
        "type": "function",
        "z": "b1ca67b21089b915",
        "g": "09c8d74836111377",
        "name": "debug en hexa",
        "func": "// Vérifie que le payload est un Buffer\nif (Buffer.isBuffer(msg.payload)) {\n    // Convertit chaque octet en hexadécimal sur 2 chiffres\n    msg.payload = msg.payload\n        .toString('hex')                // Convertit tout le buffer en une chaîne hexadécimale continue\n        .match(/.{1,2}/g)               // Coupe la chaîne tous les 2 caractères\n        .join(' ') + '\\n';              // Ajoute un espace entre chaque octet et un retour à la ligne\n} else if (Array.isArray(msg.payload)) {\n    // Si c'est un tableau, on le traite aussi\n    msg.payload = msg.payload\n        .map(x => x.toString(16).padStart(2, '0'))\n        .join(' ') + '\\n';\n} else {\n    // Sinon, on ne fait rien ou on peut lever une erreur\n    msg.payload = 'Payload non reconnu\\n';\n}\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 682.2000122070312,
        "y": 1130.199951171875,
        "wires": [
            [
                "2f1946e570f89af5"
            ]
        ]
    },
    {
        "id": "66ce0bd5261eb149",
        "type": "mqtt out",
        "z": "b1ca67b21089b915",
        "g": "c1fd93cd8f38ea7c",
        "name": "Onduleur",
        "topic": "",
        "qos": "0",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 700,
        "y": 640,
        "wires": []
    },
    {
        "id": "63efeee1a97e3bb9",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "c1fd93cd8f38ea7c",
        "name": "Publie \"Online\"",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 640,
        "wires": [
            [
                "468d5c1a95681d8d"
            ]
        ]
    },
    {
        "id": "323bc1fdf8eb4b0e",
        "type": "delay",
        "z": "b1ca67b21089b915",
        "g": "c1fd93cd8f38ea7c",
        "name": "",
        "pauseType": "delay",
        "timeout": "10",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 520,
        "y": 640,
        "wires": [
            [
                "66ce0bd5261eb149"
            ]
        ]
    },
    {
        "id": "468d5c1a95681d8d",
        "type": "function",
        "z": "b1ca67b21089b915",
        "g": "c1fd93cd8f38ea7c",
        "name": "Informe \"Online\"",
        "func": "msg.payload = \"Online\";\nmsg.topic = \"JK-BMS-RS485-CAN-module\";\nmsg.action = \"\";\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 640,
        "wires": [
            [
                "323bc1fdf8eb4b0e"
            ]
        ]
    },
    {
        "id": "ea424593a0b6533a",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 1180,
        "wires": [
            [
                "4a6179de378fa7c5"
            ]
        ]
    },
    {
        "id": "4a6179de378fa7c5",
        "type": "change",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "communication_debug true ",
        "rules": [
            {
                "t": "set",
                "p": "communication_debug",
                "pt": "global",
                "to": "true",
                "tot": "bool"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 380,
        "y": 1180,
        "wires": [
            []
        ]
    },
    {
        "id": "6fa5d0c215b7e641",
        "type": "inject",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 1220,
        "wires": [
            [
                "8bcf0e0b17b0565f"
            ]
        ]
    },
    {
        "id": "8bcf0e0b17b0565f",
        "type": "change",
        "z": "b1ca67b21089b915",
        "g": "6c19eb9e84cdf38b",
        "name": "communication_debug false ",
        "rules": [
            {
                "t": "set",
                "p": "communication_debug",
                "pt": "global",
                "to": "false",
                "tot": "bool"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 380,
        "y": 1220,
        "wires": [
            []
        ]
    },
    {
        "id": "b122ec506872171a",
        "type": "debug",
        "z": "b1ca67b21089b915",
        "g": "c8e26f4ca5e76e36",
        "name": "debug 4",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 520,
        "y": 260,
        "wires": []
    },
    {
        "id": "416789eaf381cb09",
        "type": "function",
        "z": "b1ca67b21089b915",
        "g": "c8e26f4ca5e76e36",
        "name": "traitement des variables",
        "func": "// Récupération des données du payload\nconst data = msg.payload;\n\n// Fonction pour traiter les champs contenant \":\"\nfunction processAddressPortFields(data) {\n    const processedData = {...data}; // Copie de l'objet original\n    \n    // Liste des champs à traiter (ceux qui peuvent contenir adresse:port)\n    const fieldsToProcess = [\n        { field: 'gateway_ip_port', addressField: 'gateway_ip', portField: 'gateway_port' },\n        { field: 'mqttadresse_port', addressField: 'mqttadresse', portField: 'mqttport' },\n        { field: 'cloud_broker_adress_port', addressField: 'cloud_broker_adress', portField: 'cloud_broker_port' }\n    ];\n    \n    fieldsToProcess.forEach(config => {\n        if (processedData[config.field] && typeof processedData[config.field] === 'string') {\n            const value = processedData[config.field];\n            \n            // Vérifier si le champ contient \":\"\n            if (value.includes(':')) {\n                const lastColonIndex = value.lastIndexOf(':'); // Utilise le dernier \":\" pour gérer les IPv6\n                const address = value.substring(0, lastColonIndex);\n                const port = value.substring(lastColonIndex + 1);\n                \n                // Ajouter les champs séparés\n                processedData[config.addressField] = address;\n                processedData[config.portField] = parseInt(port, 10);\n                \n                node.log(`Champ '${config.field}' traité: ${address}:${port}`);\n            }\n            \n            // Supprimer le champ original avec \"_port\" \n            delete processedData[config.field];\n        }\n    });\n    \n    return processedData;\n}\n\n// Extraction et stockage des variables globales\ntry {\n    // Traitement préalable des champs avec \":\"\n    const processedData = processAddressPortFields(data);\n    \n    // Configuration JK-BMS principale\n    if (processedData.jkbms_path) {\n        global.set(\"path\", processedData.jkbms_path);\n        node.log(\"Variable globale 'path' = \" + processedData.jkbms_path);\n    }\n    \n    if (processedData.jkbms_count) {\n        global.set(\"nb_jkbms\", processedData.jkbms_count);\n        node.log(\"Variable globale 'nb_jkbms' = \" + processedData.jkbms_count);\n    }\n    \n    // Configuration Gateway\n    if (processedData.use_gateway !== undefined) {\n        global.set(\"use_gateway\", processedData.use_gateway);\n        node.log(\"Variable globale 'use_gateway' = \" + processedData.use_gateway);\n    }\n    \n    if (processedData.gateway_ip !== undefined) {\n        global.set(\"gateway_ip\", processedData.gateway_ip);\n        node.log(\"Variable globale 'gateway_ip' = \" + processedData.gateway_ip);\n    }\n    \n    if (processedData.gateway_port !== undefined) {\n        global.set(\"gateway_port\", processedData.gateway_port);\n        node.log(\"Variable globale 'gateway_port' = \" + processedData.gateway_port);\n    }\n    \n    if (processedData.communication_debug !== undefined) {\n        global.set(\"communication_debug\", processedData.communication_debug);\n        node.log(\"Variable globale 'communication_debug' = \" + processedData.communication_debug);\n    }\n     \n    if (processedData.bms_broadcasting !== undefined) {\n        global.set(\"bms_broadcasting\", processedData.bms_broadcasting);\n        node.log(\"Variable globale 'bms_broadcasting' = \" + processedData.bms_broadcasting);\n    }\n   \n    if (processedData.CAN_bus_usage !== undefined) {\n        global.set(\"CAN_bus_usage\", processedData.CAN_bus_usage);\n        node.log(\"Variable globale 'CAN_bus_usage' = \" + processedData.CAN_bus_usage);\n    }\n\n    // Paramètres MQTT\n    if (processedData.mqttadresse) {\n        global.set(\"mqttadresse\", processedData.mqttadresse);\n        node.log(\"Variable globale 'mqttadresse' = \" + processedData.mqttadresse);\n    }\n    \n    if (processedData.mqttport) {\n        global.set(\"mqttport\", processedData.mqttport);\n        node.log(\"Variable globale 'mqttport' = \" + processedData.mqttport);\n    }\n    \n    if (processedData.mqttuser) {\n        global.set(\"mqttuser\", processedData.mqttuser);\n        node.log(\"Variable globale 'mqttuser' = \" + processedData.mqttuser);\n    }\n    \n    if (processedData.mqttpass) {\n        global.set(\"mqttpass\", processedData.mqttpass);\n        node.log(\"Variable globale 'mqttpass' = •••••••••\");\n    }\n\n    // Message de confirmation\n    msg.payload = {\n        status: \"success\",\n        message: \"Variables globales créées avec succès\",\n        variables: {\n            path: global.get(\"path\"),\n            nb_jkbms: global.get(\"nb_jkbms\"),\n            use_gateway: global.get(\"use_gateway\"),\n            gateway_ip: global.get(\"gateway_ip\"),\n            gateway_port: global.get(\"gateway_port\"),\n            communication_debug: global.get(\"communication_debug\"),\n            bms_broadcasting: global.get(\"bms_broadcasting\"),\n            mqttadresse: global.get(\"mqttadresse\"),\n            mqttport: global.get(\"mqttport\"),\n            mqttuser: global.get(\"mqttuser\"),\n            mqttpass: global.get(\"mqttpass\"),\n            CAN_bus_usage: global.get(\"CAN_bus_usage\")\n        },\n        processedData: processedData // Pour debugging\n    };\n\n} catch (error) {\n    node.error(\"Erreur lors de la création des variables globales: \" + error.message);\n    msg.payload = {\n        status: \"error\",\n        message: error.message\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 710,
        "y": 220,
        "wires": [
            [
                "2682276da62a0840"
            ]
        ]
    },
    {
        "id": "49c92598895378e1",
        "type": "switch",
        "z": "b1ca67b21089b915",
        "g": "4cfdd0fab949bb3c",
        "name": "Use Gateway ?",
        "property": "use_gateway",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 320,
        "y": 400,
        "wires": [
            [],
            [
                "00678a50f9f3ef9c"
            ]
        ],
        "outputLabels": [
            "Ip Gateway",
            "Serial Port"
        ]
    },
    {
        "id": "d84c3f32b5bee13a",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "Live Trame 3   -  #5664 - 0x1620",
        "func": "// Création de la trame Modbus pour registre 5664\nlet currentAddress = global.get(\"slaveAddress-Trame3\") || 1; // Valeur par défaut : 1\n// Récupération de l'adresse esclave depuis le contexte global\nconst slaveId = global.get(\"slaveAddress-Trame3\") || 0x01; // Valeur par défaut si non définie\nconst functionCode = 0x10;\nconst registerHigh = 0x16;\nconst registerLow = 0x20;\nconst quantityHigh = 0x00;\nconst quantityLow = 0x01;\nconst byteCount = 0x02;\nconst valueHigh = 0x00;\nconst valueLow = 0x00;\n\n// Calculer CRC16 Modbus\nfunction crc16(buffer) {\n    let crc = 0xFFFF;\n    for (let i = 0; i < buffer.length; i++) {\n        crc ^= buffer[i];\n        for (let j = 0; j < 8; j++) {\n            if (crc & 0x0001) {\n                crc = (crc >> 1) ^ 0xA001;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    return crc;\n}\n\n// Construction du buffer sans CRC\nconst dataBuffer = Buffer.from([\n    slaveId,\n    functionCode,\n    registerHigh,\n    registerLow,\n    quantityHigh,\n    quantityLow,\n    byteCount,\n    valueHigh,\n    valueLow\n]);\n\n// Calcul du CRC\nconst crc = crc16(dataBuffer);\n\n// Buffer final avec CRC\nconst finalBuffer = Buffer.allocUnsafe(dataBuffer.length + 2);\ndataBuffer.copy(finalBuffer);\nfinalBuffer.writeUInt16LE(crc, dataBuffer.length);\n\nmsg.topic = \"Trame-3-dynamiques\"\nmsg.payload = finalBuffer;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 820,
        "wires": [
            [
                "a632bb3545ad81d5"
            ]
        ]
    },
    {
        "id": "1430199873abea94",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "Fixes Trame 1  -  #5660 - 0x161C",
        "func": "// Création de la trame Modbus pour registre 5664\nlet currentAddress = global.get(\"slaveAddress-Trame1\") || 1; // Valeur par défaut : 1\n// Récupération de l'adresse esclave depuis le contexte global\nconst slaveId = global.get(\"slaveAddress-Trame1\") || 0x01; // Valeur par défaut si non définie\nconst functionCode = 0x10;\nconst registerHigh = 0x16;\nconst registerLow = 0x1C;\nconst quantityHigh = 0x00;\nconst quantityLow = 0x01;\nconst byteCount = 0x02;\nconst valueHigh = 0x00;\nconst valueLow = 0x00;\n\n// Calculer CRC16 Modbus\nfunction crc16(buffer) {\n    let crc = 0xFFFF;\n    for (let i = 0; i < buffer.length; i++) {\n        crc ^= buffer[i];\n        for (let j = 0; j < 8; j++) {\n            if (crc & 0x0001) {\n                crc = (crc >> 1) ^ 0xA001;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    return crc;\n}\n\n// Construction du buffer sans CRC\nconst dataBuffer = Buffer.from([\n    slaveId,\n    functionCode,\n    registerHigh,\n    registerLow,\n    quantityHigh,\n    quantityLow,\n    byteCount,\n    valueHigh,\n    valueLow\n]);\n\n// Calcul du CRC\nconst crc = crc16(dataBuffer);\n\n// Buffer final avec CRC\nconst finalBuffer = Buffer.allocUnsafe(dataBuffer.length + 2);\ndataBuffer.copy(finalBuffer);\nfinalBuffer.writeUInt16LE(crc, dataBuffer.length);\n\nmsg.topic = \"Trame-1-statiques\"\nmsg.payload = finalBuffer;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 580,
        "wires": [
            [
                "a632bb3545ad81d5"
            ]
        ]
    },
    {
        "id": "19e4f82b41b8041a",
        "type": "link in",
        "z": "ce01fabde0618f55",
        "g": "9c42cd07964fe992",
        "name": "Serial-In",
        "links": [
            "389031f7d149d0e4",
            "6542c8ba28167fbf"
        ],
        "x": 475,
        "y": 360,
        "wires": [
            [
                "5e23433b1e088edf"
            ]
        ]
    },
    {
        "id": "9df6cb4f228ce42d",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "Setup Trame 2  -  #5662 - 0x1622",
        "func": "// Création de la trame Modbus pour registre 5662\nlet currentAddress = global.get(\"slaveAddress-Trame2\") || 1; // Valeur par défaut : 1\n// Récupération de l'adresse esclave depuis le contexte global\nconst slaveId = global.get(\"slaveAddress-Trame2\") || 0x01; // Valeur par défaut si non définie\nconst functionCode = 0x10;\nconst registerHigh = 0x16;\nconst registerLow = 0x1E;\nconst quantityHigh = 0x00;\nconst quantityLow = 0x01;\nconst byteCount = 0x02;\nconst valueHigh = 0x00;\nconst valueLow = 0x00;\n\n// Calculer CRC16 Modbus\nfunction crc16(buffer) {\n    let crc = 0xFFFF;\n    for (let i = 0; i < buffer.length; i++) {\n        crc ^= buffer[i];\n        for (let j = 0; j < 8; j++) {\n            if (crc & 0x0001) {\n                crc = (crc >> 1) ^ 0xA001;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    return crc;\n}\n\n// Construction du buffer sans CRC\nconst dataBuffer = Buffer.from([\n    slaveId,\n    functionCode,\n    registerHigh,\n    registerLow,\n    quantityHigh,\n    quantityLow,\n    byteCount,\n    valueHigh,\n    valueLow\n]);\n\n// Calcul du CRC\nconst crc = crc16(dataBuffer);\n\n// Buffer final avec CRC\nconst finalBuffer = Buffer.allocUnsafe(dataBuffer.length + 2);\ndataBuffer.copy(finalBuffer);\nfinalBuffer.writeUInt16LE(crc, dataBuffer.length);\n\nmsg.topic = \"Trame-2-setup\"\nmsg.payload = finalBuffer;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 700,
        "wires": [
            [
                "a632bb3545ad81d5"
            ]
        ]
    },
    {
        "id": "a6b1b65a3e856d8f",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "Trame 3",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 280,
        "y": 1460,
        "wires": []
    },
    {
        "id": "867fca3b9f77ce27",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "c06c156ddb36634e",
        "name": "setup",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 450,
        "y": 1320,
        "wires": []
    },
    {
        "id": "2621a947da028681",
        "type": "link in",
        "z": "ce01fabde0618f55",
        "g": "1bb1485c6f644ee6",
        "name": "link in 3",
        "links": [
            "9fb62a629d09612b",
            "03d54d1f353534ca"
        ],
        "x": 65,
        "y": 1000,
        "wires": [
            [
                "300c67230e4e510a",
                "95b5286db50cb893"
            ]
        ]
    },
    {
        "id": "3987f9e640e885a6",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "c06c156ddb36634e",
        "name": "Trame 2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 230,
        "y": 1320,
        "wires": []
    },
    {
        "id": "b2d928a2b649fe63",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "bff0d4fab3ef46a5",
        "name": "Trame 1",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 200,
        "y": 1180,
        "wires": []
    },
    {
        "id": "bbe7f5ddcea331a9",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "bff0d4fab3ef46a5",
        "name": "statics",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 410,
        "y": 1180,
        "wires": []
    },
    {
        "id": "264d6f5686cf22f1",
        "type": "buffer-parser",
        "z": "ce01fabde0618f55",
        "g": "bff0d4fab3ef46a5",
        "name": "Trame 1",
        "data": "payload",
        "dataType": "msg",
        "specification": "spec",
        "specificationType": "ui",
        "items": [
            {
                "type": "ascii",
                "name": "BMS_A",
                "offset": 6,
                "length": 13,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "ascii",
                "name": "FW_A",
                "offset": 22,
                "length": 3,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "ascii",
                "name": "SW_N",
                "offset": 30,
                "length": 5,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint32le",
                "name": "Uptime_S",
                "offset": 38,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint32le",
                "name": "Power_count_N",
                "offset": 42,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "ascii",
                "name": "SerialNb_N",
                "offset": 46,
                "length": 13,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "ascii",
                "name": "Password1_A",
                "offset": 62,
                "length": 8,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "ascii",
                "name": "Manufacturing_date_N",
                "offset": 78,
                "length": 8,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "ascii",
                "name": "Brand_A",
                "offset": 102,
                "length": 8,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "ascii",
                "name": "Password2_A",
                "offset": 118,
                "length": 8,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "UART1_protocol_number_N",
                "offset": 184,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "CAN_protocol_number_N",
                "offset": 185,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "LCD_buzzer_trigger_N",
                "offset": 234,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint32le",
                "name": "LCD_buzzer_trigger_value_N",
                "offset": 238,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint32le",
                "name": "LCD_buzzer_release_value_N",
                "offset": 242,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "Request_Charge_voltage_Time_S",
                "offset": 266,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "Request_Float_voltage_Time_N",
                "offset": 267,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            }
        ],
        "swap1": "",
        "swap2": "",
        "swap3": "",
        "swap1Type": "swap",
        "swap2Type": "swap",
        "swap3Type": "swap",
        "msgProperty": "payload",
        "msgPropertyType": "str",
        "resultType": "keyvalue",
        "resultTypeType": "return",
        "multipleResult": false,
        "fanOutMultipleResult": false,
        "setTopic": true,
        "outputs": 1,
        "x": 420,
        "y": 1220,
        "wires": [
            [
                "bbe7f5ddcea331a9",
                "f15bd83b2cddefde",
                "1c51761e84ee5bb2"
            ]
        ]
    },
    {
        "id": "5e23433b1e088edf",
        "type": "serial request",
        "z": "ce01fabde0618f55",
        "g": "9c42cd07964fe992",
        "name": "JKBMS-RS485",
        "serial": "6e1abcbcc6ebb714",
        "x": 610,
        "y": 360,
        "wires": [
            [
                "47ab0322cedc3c22",
                "9fb62a629d09612b",
                "54c93e67707946a8"
            ]
        ]
    },
    {
        "id": "300c67230e4e510a",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "1bb1485c6f644ee6",
        "name": "Trame 1-2-3-Autres",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "Trame-1-statiques",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "Trame-2-setup",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "Trame-3-dynamiques",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 4,
        "x": 200,
        "y": 1000,
        "wires": [
            [
                "b17bb5bd16c1be78"
            ],
            [
                "7bd0459073759ca1"
            ],
            [
                "c516cfa766ac29a1"
            ],
            [
                "6152557feb0eac9a",
                "fd734524924bf8a8"
            ]
        ]
    },
    {
        "id": "9fb62a629d09612b",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "9c42cd07964fe992",
        "name": "Serial Out",
        "mode": "link",
        "links": [
            "2621a947da028681"
        ],
        "x": 745,
        "y": 360,
        "wires": []
    },
    {
        "id": "47ab0322cedc3c22",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "9c42cd07964fe992",
        "name": "Modbus Out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 600,
        "y": 320,
        "wires": []
    },
    {
        "id": "6152557feb0eac9a",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "1bb1485c6f644ee6",
        "name": "Autres trame",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 170,
        "y": 1060,
        "wires": []
    },
    {
        "id": "4c893435cad6711e",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "Vérifie Trame 3",
        "func": "const expectedHeader = [0x55, 0xAA, 0xEB, 0x90, 0x02];\nconst expectedLength = 308;\n\n// Vérifie si le buffer commence par la séquence attendue et fait la bonne longueur\nfunction checkBuffer(buffer) {\n    // Vérifie d'abord la longueur totale\n    if (buffer.length !== expectedLength) return false;\n\n    // Vérifie ensuite l'en-tête\n    if (buffer.length < expectedHeader.length) return false;\n\n    for (let i = 0; i < expectedHeader.length; i++) {\n        if (buffer[i] !== expectedHeader[i]) return false;\n    }\n    return true;\n}\n\nif (checkBuffer(msg.payload)) {\n    return msg;\n} else {\n    return null; // Ne transmet pas le message si la vérification échoue\n}",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 300,
        "y": 1500,
        "wires": [
            [
                "c6f86ca54e23c581",
                "65f7cb3119d4baa9",
                "609d1962222fd9ae"
            ],
            []
        ]
    },
    {
        "id": "c516cfa766ac29a1",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "1bb1485c6f644ee6",
        "name": "trame3-out",
        "mode": "link",
        "links": [
            "c0f222bb926bd319"
        ],
        "x": 365,
        "y": 1020,
        "wires": []
    },
    {
        "id": "c0f222bb926bd319",
        "type": "link in",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "trame3-in",
        "links": [
            "c516cfa766ac29a1"
        ],
        "x": 175,
        "y": 1500,
        "wires": [
            [
                "4c893435cad6711e",
                "a6b1b65a3e856d8f"
            ]
        ]
    },
    {
        "id": "7bd0459073759ca1",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "1bb1485c6f644ee6",
        "name": "trame2-out",
        "mode": "link",
        "links": [
            "dde116783a665a3f"
        ],
        "x": 365,
        "y": 980,
        "wires": []
    },
    {
        "id": "dde116783a665a3f",
        "type": "link in",
        "z": "ce01fabde0618f55",
        "g": "c06c156ddb36634e",
        "name": "trame2-in",
        "links": [
            "7bd0459073759ca1"
        ],
        "x": 125,
        "y": 1340,
        "wires": [
            [
                "3987f9e640e885a6",
                "34f5429239508138"
            ]
        ]
    },
    {
        "id": "34f5429239508138",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "c06c156ddb36634e",
        "name": "Vérifie Trame 2",
        "func": "//const expectedHeader = [0x55, 0xAA, 0xEB, 0x90, 0x01];\nconst expectedHeader = [0x55, 0xAA, 0xEB, 0x90, 0x01];\n\n// Vérifie si le buffer commence par la séquence attendue\nfunction checkHeader(buffer) {\n    if (buffer.length < expectedHeader.length) return false;\n    \n    for (let i = 0; i < expectedHeader.length; i++) {\n        if (buffer[i] !== expectedHeader[i]) return false;\n    }\n    return true;\n}\n\nif (checkHeader(msg.payload)) {\n    return msg;\n} else {\n    return null; // Ne transmet pas le message si l'en-tête ne correspond pas\n}",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 250,
        "y": 1360,
        "wires": [
            [
                "d07dea014d2dd68a"
            ],
            []
        ]
    },
    {
        "id": "b17bb5bd16c1be78",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "1bb1485c6f644ee6",
        "name": "trame1-out",
        "mode": "link",
        "links": [
            "7a45939101576456"
        ],
        "x": 365,
        "y": 940,
        "wires": []
    },
    {
        "id": "7a45939101576456",
        "type": "link in",
        "z": "ce01fabde0618f55",
        "g": "bff0d4fab3ef46a5",
        "name": "trame1-in",
        "links": [
            "b17bb5bd16c1be78"
        ],
        "x": 85,
        "y": 1220,
        "wires": [
            [
                "2492d95ecc9f328c",
                "b2d928a2b649fe63"
            ]
        ]
    },
    {
        "id": "2492d95ecc9f328c",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "bff0d4fab3ef46a5",
        "name": "Vérifie Trame 1",
        "func": "const expectedHeader = [0x55, 0xAA, 0xEB, 0x90];\n\n// Vérifie si le buffer commence par la séquence attendue\nfunction checkHeader(buffer) {\n    if (buffer.length < expectedHeader.length) return false;\n    \n    for (let i = 0; i < expectedHeader.length; i++) {\n        if (buffer[i] !== expectedHeader[i]) return false;\n    }\n    return true;\n}\n\nif (checkHeader(msg.payload)) {\n    return msg;\n} else {\n    return null; // Ne transmet pas le message si l'en-tête ne correspond pas\n}",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 220,
        "y": 1220,
        "wires": [
            [
                "264d6f5686cf22f1"
            ],
            []
        ]
    },
    {
        "id": "60a06da8cc236522",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "data's",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 490,
        "y": 1460,
        "wires": []
    },
    {
        "id": "97a3abc79a4c67cd",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "MQTT data",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 910,
        "y": 1460,
        "wires": []
    },
    {
        "id": "d8f9f00da2e3a338",
        "type": "mqtt out",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "Onduleur",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 900,
        "y": 1500,
        "wires": []
    },
    {
        "id": "32a6b862b301b073",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "bff0d4fab3ef46a5",
        "name": "MQTT static",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 830,
        "y": 1180,
        "wires": []
    },
    {
        "id": "cb1a7697e8293f75",
        "type": "mqtt out",
        "z": "ce01fabde0618f55",
        "g": "bff0d4fab3ef46a5",
        "name": "Onduleur",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 860,
        "y": 1220,
        "wires": []
    },
    {
        "id": "d07dea014d2dd68a",
        "type": "buffer-parser",
        "z": "ce01fabde0618f55",
        "g": "c06c156ddb36634e",
        "name": "Trame 2",
        "data": "payload",
        "dataType": "msg",
        "specification": "spec",
        "specificationType": "ui",
        "items": [
            {
                "type": "int32le",
                "name": "smart_sleep_voltage_V",
                "offset": 6,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_voltage_undervoltage_protection_V",
                "offset": 10,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_voltage_undervoltage_recovery_V",
                "offset": 14,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_voltage_overvoltage_protection_V",
                "offset": 18,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_voltage_overvoltage_recovery_V",
                "offset": 22,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "balance_trigger_voltage_V",
                "offset": 26,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_soc100_voltage_V",
                "offset": 30,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_soc0_voltage_V",
                "offset": 34,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_request_charge_voltage_V",
                "offset": 38,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_request_float_voltage_V",
                "offset": 42,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "power_off_voltage_V",
                "offset": 46,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "max_charge_current_A",
                "offset": 50,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_overcurrent_protection_delay_S",
                "offset": 54,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_overcurrent_protection_recovery_time_S",
                "offset": 58,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "max_discharge_current_S",
                "offset": 62,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "discharge_overcurrent_protection_delay_S",
                "offset": 66,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "discharge_overcurrent_protection_recovery_time_S",
                "offset": 70,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "short_circuit_protection_recovery_time_S",
                "offset": 74,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "max_balance_current_A",
                "offset": 78,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_overtemperature_protection_T",
                "offset": 82,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_overtemperature_protection_recovery_T",
                "offset": 86,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "discharge_overtemperature_protection_T",
                "offset": 90,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "discharge_overtemperature_protection_recovery_T",
                "offset": 94,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_undertemperature_protection_T",
                "offset": 98,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_undertemperature_protection_recovery_T",
                "offset": 102,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "power_tube_overtemperature_protection_T",
                "offset": 106,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "power_tube_overtemperature_protection_recovery_T",
                "offset": 110,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_count_N",
                "offset": 114,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "charging_switch_B",
                "offset": 118,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "discharging_switch_B",
                "offset": 122,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "balance_switch_B",
                "offset": 126,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "total_battery_capacity_Ah",
                "offset": 130,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "short_circuit_protection_delay_S",
                "offset": 134,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "balance_starting_voltage_V",
                "offset": 138,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Connexion_wire_resistance_1_R",
                "offset": 158,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": " Device_address_N",
                "offset": 270,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "display_always_on_switch_B",
                "offset": 282,
                "length": 1,
                "offsetbit": 4,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "smart_sleep_switch_B",
                "offset": 282,
                "length": 1,
                "offsetbit": 7,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "disable_pcl_module_switch_B",
                "offset": 282,
                "length": 1,
                "offsetbit": 8,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "timed_stored_data_switch_B",
                "offset": 283,
                "length": 1,
                "offsetbit": 1,
                "scale": "1",
                "mask": ""
            }
        ],
        "swap1": "",
        "swap2": "",
        "swap3": "",
        "swap1Type": "swap",
        "swap2Type": "swap",
        "swap3Type": "swap",
        "msgProperty": "payload",
        "msgPropertyType": "str",
        "resultType": "keyvalue",
        "resultTypeType": "return",
        "multipleResult": false,
        "fanOutMultipleResult": false,
        "setTopic": true,
        "outputs": 1,
        "x": 460,
        "y": 1360,
        "wires": [
            [
                "867fca3b9f77ce27",
                "f62828b434e3951b"
            ]
        ]
    },
    {
        "id": "f15bd83b2cddefde",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "bff0d4fab3ef46a5",
        "name": "Trame \"statics\" to MQTT",
        "func": "// Récupération de l'ID d'esclave\nconst slaveId = global.get(\"slaveAddress-Trame1\") || 0x01;\nconst slaveIdNumber = typeof slaveId === 'string' ? parseInt(slaveId, 16) : slaveId;\n\n// ------------------------------------------------------------------\n// 1. Vérrou : discovery une seule fois\nconst discoveryKey = `discoverySent_STATIC_BMS_${slaveIdNumber}`;\nconst discoveryAlreadySent = flow.get(discoveryKey) || false;\n\n// ------------------------------------------------------------------\n// 2. Constantes\nconst baseTopic = \"BMS_\" + slaveIdNumber;\nconst discoveryPrefix = \"homeassistant\";\nconst deviceName = \"BMS_\" + slaveIdNumber;\nconst deviceID = \"BMS_\" + slaveIdNumber + \"_device\";\n\n// Champs qui doivent être des \"number\" (configuration)\nconst numberFields = [\"LCD_buzzer_trigger_N\", \"LCD_buzzer_trigger_value_N\", \"LCD_buzzer_release_value_N\"];\n\n// ------------------------------------------------------------------\n// 3. Fonctions de génération\nfunction formatValue(v) {\n    return (typeof v === 'string') ? v : String(v);\n}\n\nfunction buildDiscoveryMessages(payloadObj) {\n    const msgs = [];\n    for (const key in payloadObj) {\n        const cleanKey = key.replace(/_[A-Z]+$/, \"\").toLowerCase();\n        const sensorTopic = `${baseTopic}/state/${cleanKey}`;\n        \n        // Vérifier si c'est un champ \"number\" (configuration)\n        if (numberFields.includes(key)) {\n            const commandTopic = `${baseTopic}/control/${cleanKey}/set`;\n            \n            // Définir la plage selon le champ\n            let min = 0;\n            let max = 100;\n            let unit = \"%\";\n            \n            if (key === \"LCD_buzzer_trigger_N\") {\n                max = 12;\n                unit = \"\";\n            }\n            \n            let cfg = {\n                name: `BMS ${key.replace(/_[A-Z]+$/, \"\").replace(/_/g, \" \")}`,\n                unique_id: `${deviceID}_${cleanKey}`,\n                state_topic: sensorTopic,\n                command_topic: commandTopic,\n                min: min,\n                max: max,\n                step: 1,\n                mode: \"box\",\n                entity_category: \"config\",\n                enabled_by_default: true,\n                device: {\n                    identifiers: [deviceID],\n                    name: deviceName,\n                    manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n                    model: payloadObj.BMS_A || \"rs485 vers MQTT\",\n                    sw_version: payloadObj.SW_N || \"3.1.5\"\n                }\n            };\n            \n            // Ajouter l'unité seulement si elle existe\n            if (unit) {\n                cfg.unit_of_measurement = unit;\n            }\n            \n            // Icône spécifique pour les alarmes sonores\n            if (key.includes(\"buzzer\")) {\n                cfg.icon = \"mdi:volume-high\";\n            }\n            \n            msgs.push({\n                topic: `${discoveryPrefix}/number/${deviceID}/${cleanKey}/config`,\n                payload: JSON.stringify(cfg),\n                retain: true\n            });\n        } else {\n            // Capteur classique (sensor)\n            let cfg = {\n                name: `BMS ${key.replace(/_[A-Z]+$/, \"\").replace(/_/g, \" \")}`,\n                unique_id: `${deviceID}_${cleanKey}`,\n                state_topic: sensorTopic,\n                enabled_by_default: true,\n                device: {\n                    identifiers: [deviceID],\n                    name: deviceName,\n                    manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n                    model: payloadObj.BMS_A || \"rs485 vers MQTT\",\n                    sw_version: payloadObj.SW_N || \"3.0.1\"\n                }\n            };\n\n            // unités & classes\n            if (key.endsWith(\"_S\")) {\n                cfg.unit_of_measurement = \"s\";\n                cfg.device_class = \"duration\";\n                cfg.state_class = \"measurement\";\n            } else if (key.endsWith(\"_N\") && key.includes(\"Time\")) {\n                cfg.unit_of_measurement = \"s\";\n                cfg.device_class = \"duration\";\n                cfg.state_class = \"measurement\";\n            } else if (key.endsWith(\"_N\") && !key.includes(\"Serial\")) {\n                cfg.state_class = \"measurement\";\n            }\n\n            // icônes\n            if (key.includes(\"Password\")) cfg.icon = \"mdi:form-textbox-password\";\n            else if (key.includes(\"Serial\")) cfg.icon = \"mdi:barcode\";\n            else if (key.includes(\"protocol\")) cfg.icon = \"mdi:protocol\";\n            else if (key.includes(\"version\") || key.includes(\"SW\") || key.includes(\"FW\"))\n                cfg.icon = \"mdi:numeric-10\";\n            else if (key.includes(\"Uptime\")) {\n                cfg.icon = \"mdi:timer-outline\";\n                cfg.device_class = \"duration\";\n            } else if (key.includes(\"date\")) cfg.icon = \"mdi:calendar\";\n\n            msgs.push({\n                topic: `${discoveryPrefix}/sensor/${deviceID}/${cleanKey}/config`,\n                payload: JSON.stringify(cfg),\n                retain: true\n            });\n        }\n    }\n    return msgs;\n}\n\nfunction buildStateMessages(payloadObj) {\n    const msgs = [];\n    for (const key in payloadObj) {\n        const cleanKey = key.replace(/_[A-Z]+$/, \"\").toLowerCase();\n        msgs.push({\n            topic: `${baseTopic}/state/${cleanKey}`,\n            payload: formatValue(payloadObj[key]),\n            retain: true\n        });\n    }\n    return msgs;\n}\n\n// ------------------------------------------------------------------\n// 4. Construction des messages\nconst payload = msg.payload;\n\nconst discoveryMsgs = discoveryAlreadySent ? [] : buildDiscoveryMessages(payload);\nconst stateMsgs = buildStateMessages(payload);\n\nif (!discoveryAlreadySent) flow.set(discoveryKey, true);\n\nreturn [discoveryMsgs.concat(stateMsgs)];",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 630,
        "y": 1220,
        "wires": [
            [
                "32a6b862b301b073",
                "cb1a7697e8293f75"
            ]
        ]
    },
    {
        "id": "f62828b434e3951b",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "c06c156ddb36634e",
        "name": "Trame \"setup\" to MQTT",
        "func": "// Récupération de l'ID d'esclave\nconst slaveId = global.get(\"slaveAddress-Trame2\") || 0x01;\nconst slaveIdNumber = typeof slaveId === 'string' ? parseInt(slaveId, 16) : slaveId;\n\nconst discoveryKey = `discoverySent_SETUP_BMS_${slaveIdNumber}`;\nconst discoveryAlreadySent = flow.get(discoveryKey) || false;\n\n// ------------------------------------------------------------------\n// Constantes\nconst baseTopic = \"BMS_\" + slaveIdNumber;\nconst discoveryPrefix = \"homeassistant\";\nconst deviceName = \"BMS_\" + slaveIdNumber;\nconst deviceID = \"BMS_\" + slaveIdNumber + \"_device\";\n\nconst customBounds = {\n    max_charge_current_A: { min: 0, max: 600, step: 0.1, unit: \"A\" },\n    max_discharge_current_S: { min: 0, max: 600, step: 0.1, unit: \"A\" },\n    max_balance_current_A: { min: 0, max: 10, step: 0.1, unit: \"A\" },\n    total_battery_capacity_Ah: { min: 5, max: 2000, step: 1, unit: \"Ah\" },\n    short_circuit_protection_delay_S: { min: 0, max: 5000, step: 1, unit: \"s\" },\n    charge_overcurrent_protection_delay_S: { min: 2, max: 600, step: 1, unit: \"s\" },\n    discharge_overcurrent_protection_delay_S: { min: 2, max: 600, step: 1, unit: \"s\" },\n    charge_overcurrent_protection_recovery_time_S: { min: 2, max: 3600, step: 1, unit: \"s\" },\n    discharge_overcurrent_protection_recovery_time_S: { min: 2, max: 3600, step: 1, unit: \"s\" },\n    short_circuit_protection_recovery_time_S: { min: 2, max: 600, step: 1, unit: \"s\" },\n    smart_sleep_voltage_V: { min: 0, max: 5, step: 0.01, unit: \"V\" },\n    cell_voltage_undervoltage_protection_V: { min: 1.2, max: 4.5, step: 0.001, unit: \"V\" },\n    cell_voltage_undervoltage_recovery_V: { min: 1.2, max: 4.5, step: 0.001, unit: \"V\" },\n    cell_voltage_overvoltage_protection_V: { min: 1.2, max: 4.5, step: 0.001, unit: \"V\" },\n    cell_voltage_overvoltage_recovery_V: { min: 1.2, max: 4.5, step: 0.001, unit: \"V\" },\n    balance_trigger_voltage_V: { min: 0.003, max: 1, step: 0.001, unit: \"V\" },\n    cell_soc100_voltage_V: { min: 1.2, max: 4.5, step: 0.001, unit: \"V\" },\n    cell_soc0_voltage_V: { min: 1, max: 4.5, step: 0.001, unit: \"V\" },\n    cell_request_charge_voltage_V: { min: 1.2, max: 5, step: 0.01, unit: \"V\" },\n    cell_request_float_voltage_V: { min: 1.2, max: 5, step: 0.01, unit: \"V\" },\n    power_off_voltage_V: { min: 1.2, max: 4.5, step: 0.01, unit: \"V\" },\n    balance_starting_voltage_V: { min: 1.2, max: 4.25, step: 0.01, unit: \"V\" },\n    charge_overtemperature_protection_T: { min: -40, max: 150, step: 0.5, unit: \"°C\" },\n    charge_overtemperature_protection_recovery_T: { min: -40, max: 150, step: 0.5, unit: \"°C\" },\n    discharge_overtemperature_protection_T: { min: -40, max: 150, step: 0.5, unit: \"°C\" },\n    discharge_overtemperature_protection_recovery_T: { min: -40, max: 150, step: 0.5, unit: \"°C\" },\n    charge_undertemperature_protection_T: { min: -40, max: 50, step: 0.5, unit: \"°C\" },\n    charge_undertemperature_protection_recovery_T: { min: -40, max: 50, step: 0.5, unit: \"°C\" },\n    power_tube_overtemperature_protection_T: { min: 30, max: 100, step: 0.5, unit: \"°C\" },\n    power_tube_overtemperature_protection_recovery_T: { min: 30, max: 100, step: 0.5, unit: \"°C\" },\n    cell_count_N: { min: 1, max: 32, step: 1, unit: \"\" },\n    Connexion_wire_resistance_1_R: { min: 0, max: 1000, step: 0.1, unit: \"mΩ\" },\n    Device_address_N: { min: 1, max: 247, step: 1, unit: \"\" }\n};\n\n// ------------------------------------------------------------------\n// Fonctions utilitaires\nfunction formatBoolean(val) {\n    if (typeof val === 'boolean') return val ? 'True' : 'False';\n    const v = String(val).toLowerCase();\n    return v === 'true' ? 'True' : v === 'false' ? 'False' : val;\n}\n\nfunction buildDiscoveryMessages(payloadObj) {\n    const msgs = [];\n    for (const key in payloadObj) {\n        const cleanKey = key.replace(/_[A-Z]+$/, \"\").toLowerCase();\n        const entityType = key.endsWith(\"_B\") ? \"switch\" : \"number\";\n\n        let cfg = {\n            name: key.replace(/_[A-Z]+$/, \"\").replace(/_/g, \" \"),\n            unique_id: `${deviceID}_${cleanKey}`,\n            state_topic: `${baseTopic}/control/${cleanKey}/state`,\n            command_topic: `${baseTopic}/control/${cleanKey}/set`,\n            entity_category: \"config\",\n            device: {\n                identifiers: [deviceID],\n                name: deviceName,\n                manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n                model: \"Setup BMS\",\n                sw_version: \"3.1.5\"\n            }\n        };\n\n        if (entityType === \"number\") {\n            cfg.mode = \"box\";\n            const bounds = customBounds[key];\n            if (bounds) {\n                cfg.min = bounds.min; cfg.max = bounds.max; cfg.step = bounds.step;\n                if (bounds.unit) cfg.unit_of_measurement = bounds.unit;\n            } else {\n                // règles par défaut\n                if (key.endsWith(\"_V\")) {\n                    cfg.unit_of_measurement = \"V\"; cfg.min = 0; cfg.max = 5; cfg.step = 0.01;\n                } else if (key.endsWith(\"_A\")) {\n                    cfg.unit_of_measurement = \"A\"; cfg.min = 0; cfg.max = 400; cfg.step = 0.1;\n                } else if (key.endsWith(\"_S\")) {\n                    cfg.unit_of_measurement = \"s\"; cfg.min = 0; cfg.max = 3600; cfg.step = 1;\n                } else if (key.endsWith(\"_T\")) {\n                    cfg.unit_of_measurement = \"°C\"; cfg.min = -40; cfg.max = 150; cfg.step = 0.5;\n                } else {\n                    cfg.min = 0; cfg.max = 100; cfg.step = 1;\n                }\n            }\n        } else if (entityType === \"switch\") {\n            cfg.payload_on = \"True\"; cfg.payload_off = \"False\";\n            cfg.state_on = \"True\"; cfg.state_off = \"False\";\n        }\n\n        msgs.push({\n            topic: `${discoveryPrefix}/${entityType}/${deviceID}/${cleanKey}/config`,\n            payload: JSON.stringify(cfg),\n            retain: true\n        });\n    }\n    return msgs;\n}\n\nfunction buildStateMessages(payloadObj) {\n    const msgs = [];\n    for (const key in payloadObj) {\n        const cleanKey = key.replace(/_[A-Z]+$/, \"\").toLowerCase();\n        msgs.push({\n            topic: `${baseTopic}/control/${cleanKey}/state`,\n            payload: formatBoolean(payloadObj[key]),\n            retain: true\n        });\n    }\n    return msgs;\n}\n// ------------------------------------------------------------------\n\n// ------------------------------------------------------------------\n// 4. Construction des messages\nconst payload = msg.payload;\n\nconst discoveryMsgs = discoveryAlreadySent ? [] : buildDiscoveryMessages(payload);\nconst stateMsgs = buildStateMessages(payload);\n\n// Marquer comme traité si c’est la première fois\nif (!discoveryAlreadySent) {\n    flow.set(discoveryKey, true);\n}\n\nreturn [discoveryMsgs.concat(stateMsgs)];",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 670,
        "y": 1360,
        "wires": [
            [
                "ea72bb742b3422f7",
                "0780657340cd75cc"
            ]
        ]
    },
    {
        "id": "ea72bb742b3422f7",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "c06c156ddb36634e",
        "name": "MQTT setup",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 870,
        "y": 1320,
        "wires": []
    },
    {
        "id": "0780657340cd75cc",
        "type": "mqtt out",
        "z": "ce01fabde0618f55",
        "g": "c06c156ddb36634e",
        "name": "Onduleur",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 860,
        "y": 1360,
        "wires": []
    },
    {
        "id": "61eadd92484325e7",
        "type": "link in",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "Relecture-Trame-2-in",
        "links": [],
        "x": 545,
        "y": 700,
        "wires": [
            [
                "9df6cb4f228ce42d"
            ]
        ]
    },
    {
        "id": "fd734524924bf8a8",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "1bb1485c6f644ee6",
        "name": "Autres-topics-out",
        "mode": "link",
        "links": [],
        "x": 365,
        "y": 1060,
        "wires": []
    },
    {
        "id": "c054e6c82bc4bb0a",
        "type": "delay",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "",
        "pauseType": "delay",
        "timeout": "500",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 710,
        "y": 540,
        "wires": [
            [
                "6ca55c256080e1c0"
            ]
        ]
    },
    {
        "id": "6ca55c256080e1c0",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "Loop Modbus adresse",
        "func": "let currentAddress = global.get(\"slaveAddress-Trame1\") || 1; // Valeur par défaut : 1\nlet Number_of_BMS = global.get(\"nb_jkbms\") || 1; // Valeur par défaut : 1\n\n// Incrémenter l'adresse, revenir à 1 après 8\ncurrentAddress = currentAddress >= Number_of_BMS ? 1 : currentAddress + 1;\n\nglobal.set(\"slaveAddress-Trame1\", currentAddress);\n\n//node.warn(`Prochaine adresse esclave Trame1 : ${currentAddress}`);\nmsg.payload = currentAddress;\nreturn msg; // Continuer vers le prochain nœud\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 540,
        "wires": [
            [
                "73bb9117fd0b3a8e"
            ]
        ]
    },
    {
        "id": "73bb9117fd0b3a8e",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "Trame 1",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1100,
        "y": 540,
        "wires": []
    },
    {
        "id": "4deeee03e0b1768d",
        "type": "delay",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "",
        "pauseType": "delay",
        "timeout": "500",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 710,
        "y": 660,
        "wires": [
            [
                "16f7228e721581da"
            ]
        ]
    },
    {
        "id": "16f7228e721581da",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "Loop Modbus adresse",
        "func": "let currentAddress = global.get(\"slaveAddress-Trame2\") || 1; // Valeur par défaut : 1\nlet Number_of_BMS = global.get(\"nb_jkbms\") || 1; // Valeur par défaut : 1\n\n// Incrémenter l'adresse, revenir à 1 après 8\ncurrentAddress = currentAddress >= Number_of_BMS ? 1 : currentAddress + 1;\n\nglobal.set(\"slaveAddress-Trame2\", currentAddress);\n\n//node.warn(`Prochaine adresse esclave Trame2 : ${currentAddress}`);\nmsg.payload = currentAddress;\nreturn msg; // Continuer vers le prochain nœud\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 660,
        "wires": [
            [
                "35900806dc5fb044"
            ]
        ]
    },
    {
        "id": "2d3862f26efaad60",
        "type": "delay",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "",
        "pauseType": "delay",
        "timeout": "500",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 710,
        "y": 780,
        "wires": [
            [
                "bfc4f86c756f8e57"
            ]
        ]
    },
    {
        "id": "bfc4f86c756f8e57",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "Loop Modbus adresse",
        "func": "let currentAddress = global.get(\"slaveAddress-Trame3\") || 1; // Valeur par défaut : 1\nlet Number_of_BMS = global.get(\"nb_jkbms\") || 1; // Valeur par défaut : 1\n\n// Incrémenter l'adresse, revenir à 1 après 8\ncurrentAddress = currentAddress >= Number_of_BMS ? 1 : currentAddress + 1;\n\nglobal.set(\"slaveAddress-Trame3\", currentAddress);\n\n// node.warn(`Prochaine adresse esclave Trame3 : ${currentAddress}`);\nmsg.payload = currentAddress;\nreturn msg; // Continuer vers le prochain nœud\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 780,
        "wires": [
            [
                "348ec2d0147bf36c"
            ]
        ]
    },
    {
        "id": "348ec2d0147bf36c",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "Trame 3",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1100,
        "y": 780,
        "wires": []
    },
    {
        "id": "c6f86ca54e23c581",
        "type": "buffer-parser",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "Trame 3",
        "data": "payload",
        "dataType": "msg",
        "specification": "spec",
        "specificationType": "ui",
        "items": [
            {
                "type": "uint16le",
                "name": "Cell_1_volt_V",
                "offset": 6,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_2_volt_V",
                "offset": 8,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_3_volt_V",
                "offset": 10,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_4_volt_V",
                "offset": 12,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_5_volt_V",
                "offset": 14,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_6_volt_V",
                "offset": 16,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_7_volt_V",
                "offset": 18,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_8_volt_V",
                "offset": 20,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_9_volt_V",
                "offset": 22,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_10_volt_V",
                "offset": 24,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_11_volt_V",
                "offset": 26,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_12_volt_V",
                "offset": 28,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_13_volt_V",
                "offset": 30,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_14_volt_V",
                "offset": 32,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_15_volt_V",
                "offset": 34,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_16_volt_V",
                "offset": 36,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_1_ohm_R",
                "offset": 80,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_2_ohm_R",
                "offset": 82,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_3_ohm_R",
                "offset": 84,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_4_ohm_R",
                "offset": 86,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_5_ohm_R",
                "offset": 88,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_6_ohm_R",
                "offset": 90,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_7_ohm_R",
                "offset": 92,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_8_ohm_R",
                "offset": 94,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_9_ohm_R",
                "offset": 96,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_10_ohm_R",
                "offset": 98,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_11_ohm_R",
                "offset": 100,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_12_ohm_R",
                "offset": 102,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_13_ohm_R",
                "offset": 104,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_14_ohm_R",
                "offset": 106,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_15_ohm_R",
                "offset": 108,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_16_ohm_R",
                "offset": 110,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Mos_temp_T",
                "offset": 144,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "uint32le",
                "name": "Puissance_Totale_W",
                "offset": 154,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Courant_total_A",
                "offset": 158,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Sonde_1_temp_T",
                "offset": 162,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Sonde_2_temp_T",
                "offset": 164,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Balance_courant_A",
                "offset": 170,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "byte",
                "name": "Balance_Action_B",
                "offset": 172,
                "length": 1,
                "offsetbit": 0,
                "scale": "/100",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "SOC_pourcentage_P",
                "offset": 173,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Capacite_restante_Ah",
                "offset": 174,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Capacite_batterie_Ah",
                "offset": 178,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Nombre_Cycle_N",
                "offset": 182,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Cycle_Capacite_Ah",
                "offset": 186,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "SOH_pourcentage_P",
                "offset": 190,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint32le",
                "name": "Total_runtime_S",
                "offset": 194,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "byte",
                "name": "Switch_Charge_B",
                "offset": 198,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "byte",
                "name": "Switch_Decharge_B",
                "offset": 199,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "byte",
                "name": "Switch_Balance_B",
                "offset": 200,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Tension_Totale_volt_V",
                "offset": 234,
                "length": 1,
                "offsetbit": 0,
                "scale": "/100",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Sonde_3_temp_T",
                "offset": 258,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Sonde_4_temp_T",
                "offset": 256,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            }
        ],
        "swap1": "",
        "swap2": "",
        "swap3": "",
        "swap1Type": "swap",
        "swap2Type": "swap",
        "swap3Type": "swap",
        "msgProperty": "payload",
        "msgPropertyType": "str",
        "resultType": "keyvalue",
        "resultTypeType": "return",
        "multipleResult": false,
        "fanOutMultipleResult": false,
        "setTopic": true,
        "outputs": 1,
        "x": 500,
        "y": 1500,
        "wires": [
            [
                "60a06da8cc236522",
                "15033939a61ddd92",
                "705a77e3b053f7ca"
            ]
        ]
    },
    {
        "id": "65f7cb3119d4baa9",
        "type": "buffer-parser",
        "z": "ce01fabde0618f55",
        "d": true,
        "g": "2e57321f85689f45",
        "name": "Erreurs codes",
        "data": "payload",
        "dataType": "msg",
        "specification": "spec",
        "specificationType": "ui",
        "items": [
            {
                "type": "uint16be",
                "name": "errors-codes",
                "offset": 166,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "bit4",
                "offset": 166,
                "length": 1,
                "offsetbit": 4,
                "scale": "1",
                "mask": ""
            }
        ],
        "swap1": "",
        "swap2": "",
        "swap3": "",
        "swap1Type": "swap",
        "swap2Type": "swap",
        "swap3Type": "swap",
        "msgProperty": "payload",
        "msgPropertyType": "str",
        "resultType": "keyvalue",
        "resultTypeType": "return",
        "multipleResult": false,
        "fanOutMultipleResult": false,
        "setTopic": true,
        "outputs": 1,
        "x": 320,
        "y": 1560,
        "wires": [
            [
                "cd88b13577b5a05a"
            ]
        ]
    },
    {
        "id": "cd88b13577b5a05a",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "debug 22",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 500,
        "y": 1560,
        "wires": []
    },
    {
        "id": "609d1962222fd9ae",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "Gestion des codes d'erreurs",
        "func": "// Liste des erreurs possibles\nconst errorList = [\n    \"Charge Overtemperature\",               // bit 0\n    \"Charge Undertemperature\",              // bit 1\n    \"Coprocessor communication error\",      // bit 2\n    \"Cell Undervoltage\",                    // bit 3\n    \"Battery pack undervoltage\",            // bit 4\n    \"Discharge overcurrent\",                // bit 5\n    \"Discharge short circuit\",              // bit 6\n    \"Discharge overtemperature\",            // bit 7\n    \"Wire resistance\",                      // bit 8\n    \"Mosfet overtemperature\",               // bit 9\n    \"Cell count is not equal to settings\",  // bit 10\n    \"Current sensor anomaly\",               // bit 11\n    \"Cell Overvoltage\",                     // bit 12\n    \"Battery pack overvoltage\",             // bit 13\n    \"Charge overcurrent protection\",        // bit 14\n    \"Charge short circuit\"                  // bit 15\n];\n\n// Récupérer le buffer\nconst buffer = msg.payload;\n\n// Vérifier que le buffer est suffisamment grand\nif (buffer.length <= 167) {\n    msg.payload = \"Buffer trop petit pour extraire le code d'erreur\";\n    return msg;\n}\n\n// Extraire la valeur d'erreur à l'offset 166 (en supposant Big Endian - BE)\nconst errorCode = (buffer[166] << 8) | buffer[167];\n\n// Initialiser un tableau pour stocker les erreurs détectées\nconst activeErrors = [];\n\n// Vérifier chaque bit d'erreur\nfor (let i = 0; i < errorList.length; i++) {\n    // Si le bit correspondant est activé (1), ajouter l'erreur à la liste\n    if (errorCode & (1 << i)) {\n        activeErrors.push(errorList[i]);\n    }\n}\n\n// Si aucune erreur n'est détectée\nif (activeErrors.length === 0) {\n    msg.payload = \"Aucune erreur détectée\";\n} else {\n    // Joindre les erreurs avec des virgules\n    msg.payload = activeErrors.join(\", \");\n}\n\n// Ajouter également le code d'erreur brut pour référence\nmsg.errorCode = errorCode;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 1600,
        "wires": [
            [
                "341f048d7cd2addd"
            ]
        ]
    },
    {
        "id": "341f048d7cd2addd",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "debug 26",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 560,
        "y": 1600,
        "wires": []
    },
    {
        "id": "a3bd0a6eeb93d67f",
        "type": "inject",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "Trame 1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "host",
                "v": "gateway_ip",
                "vt": "global"
            },
            {
                "p": "port",
                "v": "gateway_port",
                "vt": "global"
            }
        ],
        "repeat": "30",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "",
        "payload": "1",
        "payloadType": "num",
        "x": 120,
        "y": 540,
        "wires": [
            [
                "5d8b1329cf980408"
            ]
        ]
    },
    {
        "id": "074c128ffe1701e8",
        "type": "inject",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "Trame 2",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "host",
                "v": "gateway_ip",
                "vt": "global"
            },
            {
                "p": "port",
                "v": "gateway_port",
                "vt": "global"
            }
        ],
        "repeat": "20",
        "crontab": "",
        "once": true,
        "onceDelay": "1.5",
        "topic": "",
        "payload": "01 10 16 20 00 01 02 00 00 D6 F1",
        "payloadType": "str",
        "x": 120,
        "y": 660,
        "wires": [
            [
                "73cf0d220e1de798"
            ]
        ]
    },
    {
        "id": "935c37a416cb0336",
        "type": "inject",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "Trame 3",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "host",
                "v": "gateway_ip",
                "vt": "global"
            },
            {
                "p": "port",
                "v": "gateway_port",
                "vt": "global"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "",
        "payload": "1",
        "payloadType": "num",
        "x": 120,
        "y": 780,
        "wires": [
            [
                "e45ebcb6cea88b4b"
            ]
        ]
    },
    {
        "id": "f1e5252af3527154",
        "type": "inject",
        "z": "ce01fabde0618f55",
        "g": "fcf5dd3bc6e97b81",
        "name": "GW IP",
        "props": [
            {
                "p": "host",
                "v": "gateway_ip",
                "vt": "global"
            },
            {
                "p": "port",
                "v": "gateway_port",
                "vt": "global"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "",
        "x": 910,
        "y": 280,
        "wires": [
            [
                "fbd3591a98eafd6d"
            ]
        ]
    },
    {
        "id": "55581e8fd2063a3b",
        "type": "tcp request",
        "z": "ce01fabde0618f55",
        "g": "fcf5dd3bc6e97b81",
        "name": "",
        "server": "",
        "port": "",
        "out": "time",
        "ret": "buffer",
        "splitc": "100",
        "newline": "",
        "trim": false,
        "tls": "",
        "x": 910,
        "y": 340,
        "wires": [
            [
                "5f1cc6f02653dd86",
                "03d54d1f353534ca",
                "b2892effe9f79e84"
            ]
        ]
    },
    {
        "id": "5f1cc6f02653dd86",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "fcf5dd3bc6e97b81",
        "name": "TCP debug ",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1090,
        "y": 340,
        "wires": []
    },
    {
        "id": "03d54d1f353534ca",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "fcf5dd3bc6e97b81",
        "name": "Serial Out",
        "mode": "link",
        "links": [
            "2621a947da028681"
        ],
        "x": 1115,
        "y": 380,
        "wires": []
    },
    {
        "id": "a632bb3545ad81d5",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "Use Gateway ?",
        "property": "use_gateway",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 1120,
        "y": 700,
        "wires": [
            [
                "bbfdd16be70fd7b0"
            ],
            [
                "389031f7d149d0e4"
            ]
        ],
        "outputLabels": [
            "Ip Gateway",
            "Serial Port"
        ]
    },
    {
        "id": "389031f7d149d0e4",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "link out 2",
        "mode": "link",
        "links": [
            "19e4f82b41b8041a"
        ],
        "x": 1235,
        "y": 720,
        "wires": []
    },
    {
        "id": "95b5286db50cb893",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "1bb1485c6f644ee6",
        "name": "Réponses",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 180,
        "y": 940,
        "wires": []
    },
    {
        "id": "bbfdd16be70fd7b0",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "link out 3",
        "mode": "link",
        "links": [
            "72408cddd3840bf2"
        ],
        "x": 1235,
        "y": 680,
        "wires": []
    },
    {
        "id": "72408cddd3840bf2",
        "type": "link in",
        "z": "ce01fabde0618f55",
        "g": "fcf5dd3bc6e97b81",
        "name": "link in 1",
        "links": [
            "bbfdd16be70fd7b0",
            "0e2831f9e2a8e7cf"
        ],
        "x": 875,
        "y": 420,
        "wires": [
            [
                "3de40e166b34cd30"
            ]
        ]
    },
    {
        "id": "b7c41933feffd518",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "bms_broadcasting ?",
        "property": "bms_broadcasting",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 500,
        "y": 540,
        "wires": [
            [],
            [
                "1430199873abea94",
                "c054e6c82bc4bb0a"
            ]
        ]
    },
    {
        "id": "7fc90ebca81725ca",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "bms_broadcasting ?",
        "property": "bms_broadcasting",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 500,
        "y": 660,
        "wires": [
            [],
            [
                "4deeee03e0b1768d",
                "9df6cb4f228ce42d"
            ]
        ]
    },
    {
        "id": "3f472b31a16a5124",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "bms_broadcasting ?",
        "property": "bms_broadcasting",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 500,
        "y": 780,
        "wires": [
            [],
            [
                "2d3862f26efaad60",
                "d84c3f32b5bee13a"
            ]
        ]
    },
    {
        "id": "5d8b1329cf980408",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "CAN_bus_usage ?",
        "property": "CAN_bus_usage",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 290,
        "y": 540,
        "wires": [
            [],
            [
                "b7c41933feffd518"
            ]
        ]
    },
    {
        "id": "73cf0d220e1de798",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "CAN_bus_usage ?",
        "property": "CAN_bus_usage",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 290,
        "y": 660,
        "wires": [
            [],
            [
                "7fc90ebca81725ca"
            ]
        ]
    },
    {
        "id": "e45ebcb6cea88b4b",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "CAN_bus_usage ?",
        "property": "CAN_bus_usage",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 290,
        "y": 780,
        "wires": [
            [],
            [
                "3f472b31a16a5124"
            ]
        ]
    },
    {
        "id": "bd13172ab7887f84",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "fc42763da6defab8",
        "name": "discoverySent_BMS_x to undefined",
        "func": "// Réinitialise toutes les clés de discovery au démarrage\nconst keys = flow.keys();\nkeys.forEach(k => {\n    if (k.startsWith(\"discoverySent_BMS_\")) {\n        flow.set(k, undefined);\n    }\n});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "8666d6cf3f8a75cc",
        "type": "inject",
        "z": "ce01fabde0618f55",
        "g": "fc42763da6defab8",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 60,
        "wires": [
            [
                "bd13172ab7887f84",
                "5b29999d7fdc4120",
                "e77b486cbdcfe2b9"
            ]
        ]
    },
    {
        "id": "15033939a61ddd92",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "Trame \"data\" to MQTT",
        "func": "// Récupération de l'ID d'esclave depuis les variables globales\nconst slaveId = global.get(\"slaveAddress-Trame3\") || 0x01;\n\n// Conversion de la valeur hexadécimale en décimal si nécessaire\nconst slaveIdNumber = typeof slaveId === 'string' ? parseInt(slaveId, 16) : slaveId;\n\nvar payload = msg.payload;\nvar baseTopic = \"BMS_\" + slaveIdNumber;\nvar discoveryPrefix = \"homeassistant/sensor\";\nvar deviceName = \"BMS_\" + slaveIdNumber;\nvar deviceID = \"BMS_\" + slaveIdNumber + \"_device\";\nvar dynamicDataTopic = `${baseTopic}/donnees_dynamiques`;\n\n// ------------------------------------------------------------------\n// 1. Clé unique par BMS pour éviter les rediscovery répétés\nconst discoveryKey = `discoverySent_BMS_${slaveIdNumber}`;\nconst discoveryAlreadySent = flow.get(discoveryKey) || false;\n// ------------------------------------------------------------------\n\n// ------------------------------------------------------------------\n// 2. Variables de travail\nvar topics = {};\nvar discoveryMsgs = [];\nvar dynamicData = {};\n\n// Clés calculées à ignorer pour le discovery (laissée vide ici)\nconst excludeFromDiscovery = [];\n// ------------------------------------------------------------------\n\n// ------------------------------------------------------------------\n// 3. Traitement des tensions de cellules\nvar cellVoltages = [];\nvar cellKeys = [];\n\nfor (var key in payload) {\n    if (key.includes(\"Cell_\") && key.includes(\"volt\") && key.endsWith(\"_V\")) {\n        let voltage = Number(payload[key]);\n        if (!isNaN(voltage)) {\n            cellVoltages.push(voltage);\n            cellKeys.push(key);\n        }\n    }\n}\n\n// Calculs des statistiques des cellules\nif (cellVoltages.length > 0) {\n    var cellAvgVolt = cellVoltages.reduce((sum, v) => sum + v, 0) / cellVoltages.length;\n    var cellMaxVolt = Math.max(...cellVoltages);\n    var cellMinVolt = Math.min(...cellVoltages);\n    var cellDeltaVolt = cellMaxVolt - cellMinVolt;\n\n    var maxVoltIndex = cellKeys[cellVoltages.indexOf(cellMaxVolt)].match(/Cell_(\\d+)/)[1];\n    var minVoltIndex = cellKeys[cellVoltages.indexOf(cellMinVolt)].match(/Cell_(\\d+)/)[1];\n\n    payload[\"cell_voltage_average_V\"]   = parseFloat(cellAvgVolt.toFixed(3));\n    payload[\"cell_voltage_delta_V\"]     = parseFloat(cellDeltaVolt.toFixed(3));\n    payload[\"cell_voltage_max_number_N\"]= parseInt(maxVoltIndex);\n    payload[\"cell_voltage_min_number_N\"]= parseInt(minVoltIndex);\n\n    // ➜ Tension réelle de la cellule la plus basse\n    payload[\"cell_voltage_min_value_V\"] = parseFloat(cellMinVolt.toFixed(3));\n    \n    // ➜ Nouvelle clé : tension réelle de la cellule la plus haute\n    payload[\"cell_voltage_max_value_V\"] = parseFloat(cellMaxVolt.toFixed(3));\n}\n// ------------------------------------------------------------------\n\n// ------------------------------------------------------------------\n// 3b. Traitement du Total_runtime pour format lisible\nif (payload[\"Total_runtime_S\"] !== undefined) {\n    var totalSeconds = parseInt(payload[\"Total_runtime_S\"]);\n    if (!isNaN(totalSeconds)) {\n        var days = Math.floor(totalSeconds / 86400);\n        var remainingSeconds = totalSeconds % 86400;\n        var hours = Math.floor(remainingSeconds / 3600);\n        var minutes = Math.floor((remainingSeconds % 3600) / 60);\n        \n        // Création du format 300D22H46M\n        payload[\"Total_runtime_formatted_T\"] = `${days}D${hours}H${minutes}M`;\n    }\n}\n// ------------------------------------------------------------------\n\n// ------------------------------------------------------------------\n// 4. Création des messages de données et (si besoin) de discovery\nconst allowedSuffixes = [\"_V\", \"_A\", \"_W\", \"_T\", \"_Ah\", \"_R\", \"_P\", \"_S\", \"_B\", \"_N\"];\n\nfor (var key in payload) {\n    if (excludeFromDiscovery.includes(key)) continue;\n\n    var hasValidSuffix = allowedSuffixes.some(s => key.endsWith(s));\n    if (!hasValidSuffix) continue;\n\n    var cleanKey = key.replace(/_[A-Z]+$/, \"\");\n    var sensorTopic = `${baseTopic}/${cleanKey}`;\n    topics[sensorTopic] = payload[key];\n    dynamicData[cleanKey] = payload[key];\n\n    if (!discoveryAlreadySent) {\n        var configTopic = `${discoveryPrefix}/${deviceID}_${cleanKey}/config`;\n        var configPayload = {\n            name: cleanKey,\n            unique_id: `${deviceID}_${cleanKey}`,\n            state_topic: sensorTopic,\n            unit_of_measurement: \"\",\n            entity_category: \"diagnostic\",\n            device: {\n                identifiers: [deviceID],\n                name: deviceName,\n                manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n                model: payload.BMS_A || \"rs485 vers MQTT\",\n                sw_version: payload.SW_N || \"3.1.5\"\n            }\n        };\n\n        if (key.endsWith(\"_V\")) configPayload.unit_of_measurement = \"V\";\n        else if (key.endsWith(\"_Ah\")) configPayload.unit_of_measurement = \"Ah\";\n        else if (key.endsWith(\"_A\")) configPayload.unit_of_measurement = \"A\";\n        else if (key.endsWith(\"_W\")) configPayload.unit_of_measurement = \"W\";\n        else if (key.endsWith(\"_T\")) {\n            // Pour le temps formaté, pas d'unité car c'est déjà dans le format\n            if (key === \"Total_runtime_formatted_T\") {\n                configPayload.unit_of_measurement = \"\";\n                configPayload.icon = \"mdi:clock-time-eight-outline\";\n            } else {\n                configPayload.unit_of_measurement = \"°C\";\n            }\n        }\n        else if (key.endsWith(\"_R\")) configPayload.unit_of_measurement = \"Ω\";\n        else if (key.endsWith(\"_P\")) {\n            configPayload.unit_of_measurement = \"%\";\n            if (key.startsWith(\"SOC\")) configPayload.device_class = \"battery\";\n        } else if (key.endsWith(\"_S\")) configPayload.unit_of_measurement = \"s\";\n\n        discoveryMsgs.push({ topic: configTopic, payload: JSON.stringify(configPayload), retain: true });\n    }\n}\n\n// Ajouter les clés calculées aux données dynamiques (sans discovery)\n[\n    \"cell_voltage_average_V\",\n    \"cell_voltage_delta_V\",\n    \"cell_voltage_max_number_N\",\n    \"cell_voltage_min_number_N\",\n    \"cell_voltage_min_value_V\",\n    \"cell_voltage_max_value_V\"\n].forEach(k => {\n    if (payload[k] !== undefined) {\n        var clean = k.replace(/_[A-Z]+$/, \"\");\n        var topic = `${baseTopic}/${clean}`;\n        topics[topic] = payload[k];\n        dynamicData[clean] = payload[k];\n    }\n});\n\n// ------------------------------------------------------------------\n// 5. Préparation des messages à retourner\n// topics[dynamicDataTopic] = JSON.stringify(dynamicData);\n\nvar outputMsgs = [];\nif (!discoveryAlreadySent) {\n    outputMsgs = discoveryMsgs;\n    flow.set(discoveryKey, true);\n}\n\nfor (var t in topics) {\n    outputMsgs.push({ topic: t, payload: topics[t] });\n}\n\nreturn [outputMsgs];",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 700,
        "y": 1500,
        "wires": [
            [
                "d8f9f00da2e3a338",
                "97a3abc79a4c67cd"
            ]
        ]
    },
    {
        "id": "5b29999d7fdc4120",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "fc42763da6defab8",
        "name": "discoverySent_SETUP_BMS_x to undefined",
        "func": "// Réinitialise toutes les clés de discovery au démarrage\nconst keys = flow.keys();\nkeys.forEach(k => {\n    if (k.startsWith(\"discoverySent_SETUP_BMS_\")) {\n        flow.set(k, undefined);\n    }\n});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "e77b486cbdcfe2b9",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "fc42763da6defab8",
        "name": "discoverySent_STATIC_BMS_x to undefined",
        "func": "// Réinitialise toutes les clés de discovery au démarrage\nconst keys = flow.keys();\nkeys.forEach(k => {\n    if (k.startsWith(\"discoverySent_STATIC_BMS_\")) {\n        flow.set(k, undefined);\n    }\n});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 140,
        "wires": [
            []
        ]
    },
    {
        "id": "1c51761e84ee5bb2",
        "type": "function",
        "z": "ce01fabde0618f55",
        "g": "bff0d4fab3ef46a5",
        "name": "SerialNb",
        "func": "var BMS = msg.payload.SerialNb_N;\n// Pour debug, affichons la valeur BMS\nnode.warn(`query BMS SerialNb: ${BMS}`);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 580,
        "y": 1160,
        "wires": [
            []
        ]
    },
    {
        "id": "35900806dc5fb044",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "0693b9727dec471d",
        "name": "Trame 2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1100,
        "y": 660,
        "wires": []
    },
    {
        "id": "993c2383b70be9f1",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "ce6083697fa14dc0",
        "name": "communication_debug ?",
        "property": "communication_debug",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 210,
        "y": 1780,
        "wires": [
            [
                "9cd19b0cda3b295b",
                "898dd8cf77551382",
                "0b8826e5e66ac591"
            ],
            []
        ],
        "outputLabels": [
            "Vrai",
            "Faux"
        ]
    },
    {
        "id": "0b8826e5e66ac591",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "ce6083697fa14dc0",
        "name": "JK-BMS response: ",
        "active": true,
        "tosidebar": false,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 460,
        "y": 1740,
        "wires": []
    },
    {
        "id": "898dd8cf77551382",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "ce6083697fa14dc0",
        "name": "host used",
        "active": true,
        "tosidebar": false,
        "console": true,
        "tostatus": false,
        "complete": "host",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 430,
        "y": 1780,
        "wires": []
    },
    {
        "id": "9cd19b0cda3b295b",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "ce6083697fa14dc0",
        "name": "port used",
        "active": true,
        "tosidebar": false,
        "console": true,
        "tostatus": false,
        "complete": "port",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 430,
        "y": 1820,
        "wires": []
    },
    {
        "id": "4c96f83e2c664c74",
        "type": "link in",
        "z": "ce01fabde0618f55",
        "g": "ce6083697fa14dc0",
        "name": "Debug In",
        "links": [
            "b2892effe9f79e84",
            "54c93e67707946a8"
        ],
        "x": 55,
        "y": 1780,
        "wires": [
            [
                "993c2383b70be9f1"
            ]
        ]
    },
    {
        "id": "b2892effe9f79e84",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "fcf5dd3bc6e97b81",
        "name": "debug-out",
        "mode": "link",
        "links": [
            "4c96f83e2c664c74"
        ],
        "x": 1115,
        "y": 420,
        "wires": []
    },
    {
        "id": "54c93e67707946a8",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "9c42cd07964fe992",
        "name": "debug-out",
        "mode": "link",
        "links": [
            "4c96f83e2c664c74"
        ],
        "x": 745,
        "y": 320,
        "wires": []
    },
    {
        "id": "705a77e3b053f7ca",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "2e57321f85689f45",
        "name": "Debug-data-in",
        "mode": "link",
        "links": [
            "8eea8a8ef9220c22"
        ],
        "x": 625,
        "y": 1460,
        "wires": []
    },
    {
        "id": "276f29f9528f1322",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "ce6083697fa14dc0",
        "name": "Live current [A] ",
        "active": true,
        "tosidebar": false,
        "console": true,
        "tostatus": false,
        "complete": "live-current",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 590,
        "y": 1900,
        "wires": []
    },
    {
        "id": "a4215bec9779ed8c",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "ce6083697fa14dc0",
        "name": "communication_debug ?",
        "property": "communication_debug",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 210,
        "y": 1900,
        "wires": [
            [
                "3c1b49123cabedb0"
            ],
            []
        ],
        "outputLabels": [
            "Vrai",
            "Faux"
        ]
    },
    {
        "id": "3c1b49123cabedb0",
        "type": "change",
        "z": "ce01fabde0618f55",
        "g": "ce6083697fa14dc0",
        "name": "Courant",
        "rules": [
            {
                "t": "set",
                "p": "live-current",
                "pt": "msg",
                "to": "payload.Courant_total_A",
                "tot": "msg"
            },
            {
                "t": "delete",
                "p": "payload",
                "pt": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 420,
        "y": 1900,
        "wires": [
            [
                "276f29f9528f1322"
            ]
        ]
    },
    {
        "id": "8eea8a8ef9220c22",
        "type": "link in",
        "z": "ce01fabde0618f55",
        "g": "ce6083697fa14dc0",
        "name": "Debug-data-in",
        "links": [
            "705a77e3b053f7ca"
        ],
        "x": 55,
        "y": 1900,
        "wires": [
            [
                "a4215bec9779ed8c"
            ]
        ]
    },
    {
        "id": "fbd3591a98eafd6d",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "fcf5dd3bc6e97b81",
        "name": "Use Gateway ?",
        "property": "use_gateway",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 1060,
        "y": 280,
        "wires": [
            [
                "55581e8fd2063a3b"
            ],
            []
        ],
        "outputLabels": [
            "Ip Gateway",
            "Serial Port"
        ]
    },
    {
        "id": "fa351cb08a5d02e9",
        "type": "link in",
        "z": "ce01fabde0618f55",
        "g": "e09fcfa37fa58cc8",
        "name": "Setup-to-serial-or-GW-in",
        "links": [
            "1b9d270fb278785c"
        ],
        "x": 205,
        "y": 360,
        "wires": [
            [
                "bb64089a3c76b396"
            ]
        ]
    },
    {
        "id": "bb64089a3c76b396",
        "type": "switch",
        "z": "ce01fabde0618f55",
        "g": "e09fcfa37fa58cc8",
        "name": "Use Gateway ?",
        "property": "use_gateway",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 150,
        "y": 320,
        "wires": [
            [
                "54a82bd9914c48e5",
                "0e2831f9e2a8e7cf"
            ],
            [
                "6542c8ba28167fbf"
            ]
        ],
        "outputLabels": [
            "Ip Gateway",
            "Serial Port"
        ]
    },
    {
        "id": "54a82bd9914c48e5",
        "type": "debug",
        "z": "ce01fabde0618f55",
        "g": "e09fcfa37fa58cc8",
        "name": "debug 9",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 150,
        "y": 280,
        "wires": []
    },
    {
        "id": "0e2831f9e2a8e7cf",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "e09fcfa37fa58cc8",
        "name": "link out 1",
        "mode": "link",
        "links": [
            "72408cddd3840bf2"
        ],
        "x": 305,
        "y": 300,
        "wires": []
    },
    {
        "id": "6542c8ba28167fbf",
        "type": "link out",
        "z": "ce01fabde0618f55",
        "g": "e09fcfa37fa58cc8",
        "name": "link out 4",
        "mode": "link",
        "links": [
            "19e4f82b41b8041a"
        ],
        "x": 305,
        "y": 340,
        "wires": []
    },
    {
        "id": "3de40e166b34cd30",
        "type": "change",
        "z": "ce01fabde0618f55",
        "g": "fcf5dd3bc6e97b81",
        "name": "Host & Port",
        "rules": [
            {
                "t": "set",
                "p": "host",
                "pt": "msg",
                "to": "gateway_ip",
                "tot": "global"
            },
            {
                "t": "set",
                "p": "port",
                "pt": "msg",
                "to": "gateway_port",
                "tot": "global"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 990,
        "y": 420,
        "wires": [
            [
                "55581e8fd2063a3b"
            ]
        ]
    },
    {
        "id": "02dd5257a29af5a6",
        "type": "mqtt out",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "Onduleur",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 700,
        "y": 260,
        "wires": []
    },
    {
        "id": "aa260e367192285d",
        "type": "link out",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "Relecture-Trame-2-out",
        "mode": "link",
        "links": [
            "61eadd92484325e7"
        ],
        "x": 815,
        "y": 220,
        "wires": []
    },
    {
        "id": "81acf21e86521b86",
        "type": "link out",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "Setup dispatch out",
        "mode": "link",
        "links": [
            "5132d56fbde6fce4"
        ],
        "x": 515,
        "y": 260,
        "wires": []
    },
    {
        "id": "d9252d611463a606",
        "type": "trigger",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "",
        "op1": "réception",
        "op2": "",
        "op1type": "str",
        "op2type": "payl",
        "duration": "2",
        "extend": true,
        "overrideDelay": false,
        "units": "s",
        "reset": "",
        "bytopic": "topic",
        "topic": "topic",
        "outputs": 2,
        "x": 140,
        "y": 220,
        "wires": [
            [
                "32701e033c9ee445"
            ],
            [
                "223504123cb3206a",
                "0e879f0b1033923c"
            ]
        ]
    },
    {
        "id": "32701e033c9ee445",
        "type": "debug",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "debug 17",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 140,
        "y": 180,
        "wires": []
    },
    {
        "id": "8f82452292423562",
        "type": "delay",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 560,
        "y": 220,
        "wires": [
            [
                "02dd5257a29af5a6",
                "d866e088f62e39db"
            ]
        ]
    },
    {
        "id": "d866e088f62e39db",
        "type": "change",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "re-lecture",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "re-lecture",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 700,
        "y": 220,
        "wires": [
            [
                "aa260e367192285d"
            ]
        ]
    },
    {
        "id": "f446b30dc2078f42",
        "type": "debug",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 380,
        "y": 260,
        "wires": []
    },
    {
        "id": "133adc320649ffd0",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write balance starting voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.42)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en valeur entière (échelle 1/1000)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x84,                           // Register address low byte (0x84)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        (voltageValue >> 24) & 0xFF,    // Valeur MSB (premier octet)\n        (voltageValue >> 16) & 0xFF,    // Deuxième octet\n        (voltageValue >> 8) & 0xFF,     // Troisième octet\n        voltageValue & 0xFF             // Valeur LSB (dernier octet)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nconst tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\nmsg.topic = \"write_balance_starting_voltage\";\nmsg.payload = generateModbusWriteCommand(tensionAEcrire);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 460,
        "wires": [
            [
                "1b9d270fb278785c",
                "842d499ea9fe3f9c"
            ]
        ]
    },
    {
        "id": "1b9d270fb278785c",
        "type": "link out",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "link out 14",
        "mode": "link",
        "links": [
            "fa351cb08a5d02e9"
        ],
        "x": 885,
        "y": 1400,
        "wires": []
    },
    {
        "id": "0f8129c7962fb889",
        "type": "switch",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Topic Setup",
        "property": "stateTopic_bis",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "control/balance_starting_voltage/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/balance_trigger_voltage/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_count/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_request_charge_voltage/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_request_float_voltage/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_soc0_voltage/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_soc100_voltage/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_voltage_overvoltage_protection/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_voltage_overvoltage_recovery/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_voltage_undervoltage_protection/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_voltage_undervoltage_recovery/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/charging_switch/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/discharging_switch/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/balance_switch/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/charge_overcurrent_protection_delay/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/charge_overcurrent_protection_recovery_time/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/charge_overtemperature_protection/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/charge_overtemperature_protection_recovery/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/discharge_overtemperature_protection/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/discharge_overtemperature_protection_recovery/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/power_tube_overtemperature_protection/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/power_tube_overtemperature_protection_recovery/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/charge_undertemperature_protection/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/charge_undertemperature_protection_recovery/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/max_balance_current/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/max_charge_current/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/max_discharge_current/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/power_off_voltage/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/display_always_on_switch/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/disable_pcl_module_switch/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/smart_sleep_switch/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/timed_stored_data_switch/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/smart_sleep_voltage/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/lcd_buzzer_trigger/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/lcd_buzzer_trigger_value/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/lcd_buzzer_release_value/state",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 37,
        "x": 230,
        "y": 1160,
        "wires": [
            [
                "133adc320649ffd0"
            ],
            [
                "5818d18351e2505a"
            ],
            [
                "e1f20160d6873a16"
            ],
            [
                "831223922b6e7a42"
            ],
            [
                "fd1c6b82e6f4c66b"
            ],
            [
                "bb7a17a27dd64e00"
            ],
            [
                "bceacd21b82896e0"
            ],
            [
                "c84672a0371bb1cc"
            ],
            [
                "57c093189c8bb8cb"
            ],
            [
                "bd140493b7942afa"
            ],
            [
                "3317efd75feda45f"
            ],
            [
                "edda4776590c41a7"
            ],
            [
                "c2528c16e766563a"
            ],
            [
                "666ac34f65df37fe"
            ],
            [
                "c939f58b7a5ce3a1"
            ],
            [
                "b9c43c59d83a114b"
            ],
            [
                "834f13ebf4e4b0aa"
            ],
            [
                "a08c1b9678760404"
            ],
            [
                "9877b4d7a594f576"
            ],
            [
                "57a2d5e590849c4c"
            ],
            [
                "b2b2a91d76d8b8ef"
            ],
            [
                "070294cbb6631c51"
            ],
            [
                "18100f82ea9b96e2"
            ],
            [
                "82a079d96e716dfb"
            ],
            [
                "a2d933bf5714917f"
            ],
            [
                "f69bb43232dd2c3b"
            ],
            [
                "e1b5d6daa74cc917"
            ],
            [
                "10d7690719c5a734"
            ],
            [
                "452323515d5b4f2d"
            ],
            [
                "ca1db571bf48ece1"
            ],
            [
                "25bbb554698f3085"
            ],
            [
                "d4b59e37e854b67d"
            ],
            [
                "4782063a6f4cbb89"
            ],
            [
                "b4210ea0e3eceeca"
            ],
            [
                "19813c881712a20f"
            ],
            [
                "1d8951e6d5cadaac"
            ],
            [
                "9cdaf1add7c8c49f"
            ]
        ]
    },
    {
        "id": "5132d56fbde6fce4",
        "type": "link in",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Setup dispatch in",
        "links": [
            "81acf21e86521b86"
        ],
        "x": 95,
        "y": 620,
        "wires": [
            [
                "0f8129c7962fb889"
            ]
        ]
    },
    {
        "id": "9cdaf1add7c8c49f",
        "type": "debug",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Autre topic setup",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 190,
        "y": 1520,
        "wires": []
    },
    {
        "id": "5818d18351e2505a",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write  balance trigger voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 0.08)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en valeur entière (échelle 1/1000)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n   \n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x14,                           // Register address low byte (0x14)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        (voltageValue >> 24) & 0xFF,    // Valeur MSB (premier octet)\n        (voltageValue >> 16) & 0xFF,    // Deuxième octet\n        (voltageValue >> 8) & 0xFF,     // Troisième octet\n        voltageValue & 0xFF             // Valeur LSB (dernier octet)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 0.001 || tensionAEcrire > 0.009) {\n    msg.error = \"Tension invalide. Valeur attendue entre 0.001V et 0.009V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_balance_trigger_voltage\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 500,
        "wires": [
            [
                "1b9d270fb278785c",
                "830726d692b9c886"
            ]
        ]
    },
    {
        "id": "e1f20160d6873a16",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write  BMS cell count",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient le nombre de cellules (ex: 16)\nfunction generateModbusWriteCommand(cellCount) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // La valeur est utilisée directement, sans échelle\n    const cellValue = parseInt(cellCount);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x6C,                           // Register address low byte (0x6C)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        (cellValue >> 24) & 0xFF,       // Valeur MSB (premier octet)\n        (cellValue >> 16) & 0xFF,       // Deuxième octet\n        (cellValue >> 8) & 0xFF,        // Troisième octet\n        cellValue & 0xFF                // Valeur LSB (dernier octet)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction du nombre de cellules et envoi de la trame\nlet nombreCellules = parseInt(msg.payload);\n\n// Validation basique\nif (isNaN(nombreCellules) || nombreCellules < 1 || nombreCellules > 32) {\n    msg.error = \"Nombre de cellules invalide. Valeur attendue entre 1 et 32\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_bms_cell_count\";\nnewMsg.payload = generateModbusWriteCommand(nombreCellules);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 540,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "831223922b6e7a42",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write  cell request charge voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n   \n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x20,                           // Register address low byte (0x20)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Pour debug, affichons la valeur en hexadécimal\n    node.warn(`Écriture de ${voltage}V soit ${voltageValue}mV`);\n    node.warn(`Valeur en hex: 0x${voltageValue.toString(16)}`);\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_cell_request_charge_voltage\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 580,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "fd1c6b82e6f4c66b",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write  cell request float voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x24,                           // Register address low byte (0x24)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_cell_request_float_voltage\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 620,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "bb7a17a27dd64e00",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write BMS cell soc0 voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x1C,                           // Register address low byte (0x1C)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_bms_cell_soc0_voltage\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 660,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "bceacd21b82896e0",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write BMS cell soc100 voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x18,                           // Register address low byte (0x18)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_bms_cell_soc100_voltage\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 700,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "c84672a0371bb1cc",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write BMS cell voltage overvoltage protection",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x0c,                           // Register address low byte (0x0c)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_cell_voltage_overvoltage_protection\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 740,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "57c093189c8bb8cb",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write BMS cell voltage overvoltage recovery",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x10,                           // Register address low byte (0x0c)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_cell_voltage_overvoltage_recovery\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 780,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "bd140493b7942afa",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write BMS cell voltage undervoltage protection",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x04,                           // Register address low byte (0x0c)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_cell_voltage_undervoltage_protection\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 580,
        "y": 820,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "3317efd75feda45f",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write BMS cell voltage undervoltage recovery",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x08,                           // Register address low byte (0x0c)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_cell_voltage_undervoltage_recovery\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 860,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "edda4776590c41a7",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write  Charging switch",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload peut être \"true\"/\"True\"/\"false\"/\"False\" ou true/false\n\nfunction generateModbusWriteCommand(input) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Conversion de l'entrée en booléen\n    let isOn = false;\n    if (typeof input === 'string') {\n        isOn = input.toLowerCase() === 'true';\n    } else if (typeof input === 'boolean') {\n        isOn = input;\n    }\n\n    // Debug\n    console.log(\"Input value:\", input);\n    console.log(\"Converted to:\", isOn);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x70,                           // Register address low byte (0x70)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        0x00,                           // Octet de poids fort (MSB)\n        0x00,                           // \n        0x00,                           // \n        isOn ? 1 : 0                    // Octet de poids faible (LSB)\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'boolean' && typeof msg.payload !== 'string') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: true/false, 'true'/'false', 'True'/'False'\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_balancer_charging_switch\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\n// Debug\nconsole.log(\"Message payload:\", msg.payload);\nconsole.log(\"Type of payload:\", typeof msg.payload);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 900,
        "wires": [
            [
                "1b9d270fb278785c",
                "969bfbdc6ff80482"
            ]
        ]
    },
    {
        "id": "c2528c16e766563a",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write  BMS Décharge switch",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload peut être \"true\"/\"True\"/\"false\"/\"False\" ou true/false\n\nfunction generateModbusWriteCommand(input) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Conversion de l'entrée en booléen\n    let isOn = false;\n    if (typeof input === 'string') {\n        isOn = input.toLowerCase() === 'true';\n    } else if (typeof input === 'boolean') {\n        isOn = input;\n    }\n\n    // Debug\n    console.log(\"Input value:\", input);\n    console.log(\"Converted to:\", isOn);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x74,                           // Register address low byte (0x74)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        0x00,                           // Octet de poids fort (MSB)\n        0x00,                           // \n        0x00,                           // \n        isOn ? 1 : 0                    // Octet de poids faible (LSB)\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'boolean' && typeof msg.payload !== 'string') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: true/false, 'true'/'false', 'True'/'False'\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_bms_discharging_switch\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\n// Debug\nconsole.log(\"Message payload:\", msg.payload);\nconsole.log(\"Type of payload:\", typeof msg.payload);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 940,
        "wires": [
            [
                "1b9d270fb278785c",
                "b997b486b520ba66"
            ]
        ]
    },
    {
        "id": "666ac34f65df37fe",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write  BMS Balance switch",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload peut être \"true\"/\"True\"/\"false\"/\"False\" ou true/false\n\nfunction generateModbusWriteCommand(input) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Conversion de l'entrée en booléen\n    let isOn = false;\n    if (typeof input === 'string') {\n        isOn = input.toLowerCase() === 'true';\n    } else if (typeof input === 'boolean') {\n        isOn = input;\n    }\n\n    // Debug\n    console.log(\"Input value:\", input);\n    console.log(\"Converted to:\", isOn);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x78,                           // Register address low byte (0x78)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        0x00,                           // Octet de poids fort (MSB)\n        0x00,                           // \n        0x00,                           // \n        isOn ? 1 : 0                    // Octet de poids faible (LSB)\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'boolean' && typeof msg.payload !== 'string') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: true/false, 'true'/'false', 'True'/'False'\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_charging_float_mode_switch\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\n// Debug\nconsole.log(\"Message payload:\", msg.payload);\nconsole.log(\"Type of payload:\", typeof msg.payload);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 980,
        "wires": [
            [
                "1b9d270fb278785c",
                "b545eac4a5a827f8"
            ]
        ]
    },
    {
        "id": "c939f58b7a5ce3a1",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write  BMS BMS charge overcurrent protection delay",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre en secondes (ex: 4)\n\nfunction generateModbusWriteCommand(seconds) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof seconds !== 'number' || seconds < 0 || !Number.isInteger(seconds)) {\n        throw new Error(\"La valeur d'entrée doit être un entier positif représentant des secondes.\");\n    }\n\n    // Conversion en uint32 (deux registres de 16 bits en Big-Endian)\n    let highWord = (seconds >> 16) & 0xFFFF;\n    let lowWord = seconds & 0xFFFF;\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x30,                           // Register address low byte (0x30)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        (highWord >> 8) & 0xFF,         // Octet de poids fort du premier registre\n        highWord & 0xFF,                // Octet de poids faible du premier registre\n        (lowWord >> 8) & 0xFF,          // Octet de poids fort du second registre\n        lowWord & 0xFF                  // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number' || msg.payload < 0 || !Number.isInteger(msg.payload)) {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un entier positif en secondes.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_charge_overcurrent_protection_delay\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 1020,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "b9c43c59d83a114b",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write  BMS charge overcurrent protection recovery time",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre en secondes (ex: 4)\n\nfunction generateModbusWriteCommand(seconds) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof seconds !== 'number' || seconds < 0 || !Number.isInteger(seconds)) {\n        throw new Error(\"La valeur d'entrée doit être un entier positif représentant des secondes.\");\n    }\n\n    // Conversion en uint32 (deux registres de 16 bits en Big-Endian)\n    let highWord = (seconds >> 16) & 0xFFFF;\n    let lowWord = seconds & 0xFFFF;\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x34,                           // Register address low byte (0x30)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        (highWord >> 8) & 0xFF,         // Octet de poids fort du premier registre\n        highWord & 0xFF,                // Octet de poids faible du premier registre\n        (lowWord >> 8) & 0xFF,          // Octet de poids fort du second registre\n        lowWord & 0xFF                  // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number' || msg.payload < 0 || !Number.isInteger(msg.payload)) {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un entier positif en secondes.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_charge_overcurrent_protection_recovery_time\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 1060,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "834f13ebf4e4b0aa",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write charge overtemperature protection",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x4C,                           // Register address low byte (0x4C)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_charge_overtemperature_protection\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 560,
        "y": 1100,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "a08c1b9678760404",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write charge overtemperature protection recovery",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x1050)\n        0x50,                           // Register address low byte (0x1050)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_charge_overtemperature_protection_recovery\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 1140,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "9877b4d7a594f576",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write discharge overtemperature protection",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x1050)\n        0x54,                           // Register address low byte (0x1050)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_discharge_overtemperature_protection\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 1180,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "57a2d5e590849c4c",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write discharge overtemperature protection recovery",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x1050)\n        0x58,                           // Register address low byte (0x1050)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_discharge_overtemperature_protection_recovery\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 1220,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "b2b2a91d76d8b8ef",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write power tube overtemperature protection",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x1050)\n        0x64,                           // Register address low byte (0x1050)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_power_tube_overtemperature_protection\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 1260,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "070294cbb6631c51",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write power tube overtemperature protection recovery",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x1050)\n        0x68,                           // Register address low byte (0x1050)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_power tube_overtemperature_protection_recovery\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 1300,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "18100f82ea9b96e2",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write charge undertemperature protection",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x1050)\n        0x5C,                           // Register address low byte (0x1050)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_charge_undertemperature_protection\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 560,
        "y": 1340,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "82a079d96e716dfb",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write charge undertemperature protection recovery",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x1050)\n        0x60,                           // Register address low byte (0x1050)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_charge_undertemperature_protection_recovery\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 1380,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "a2d933bf5714917f",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write max balance current",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient le courant en ampères (ex: 1.5)\nfunction generateModbusWriteCommand(current) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion du courant selon l'échelle (2A = 2000)\n    // Exemple: 1.5A -> 1500\n    const currentValue = Math.round(current * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x48,                           // Register address low byte (0x48)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (currentValue >> 8) & 0xFF,     // Octet 3\n        currentValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Pour debug, affichons la valeur\n    node.warn(`Écriture de ${current}A soit ${currentValue} unités`);\n    node.warn(`Valeur en hex: 0x${currentValue.toString(16)}`);\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de courant et envoi de la trame\nlet courantAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(courantAEcrire) || courantAEcrire < 0 || courantAEcrire > 2) {\n    msg.error = \"Courant invalide. Valeur attendue entre 0A et 2A\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_max_balance_current\";\nnewMsg.payload = generateModbusWriteCommand(courantAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 1420,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "f69bb43232dd2c3b",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write max charge current",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient le courant en ampères (ex: 5)\nfunction generateModbusWriteCommand(current) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion du courant selon l'échelle observée (140A = 140000)\n    // Exemple: 5A -> 5000\n    const currentValue = Math.round(current * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x2C,                           // Register address low byte (0x2C)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32, on envoie les 4 octets (du plus significatif au moins significatif)\n        (currentValue >> 24) & 0xFF,    // Octet 1 (MSB)\n        (currentValue >> 16) & 0xFF,    // Octet 2\n        (currentValue >> 8) & 0xFF,     // Octet 3\n        currentValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Pour debug, affichons la valeur\n    node.warn(`Écriture de ${current}A soit ${currentValue} unités`);\n    node.warn(`Valeur en hex: 0x${currentValue.toString(16).padStart(8, '0')}`);\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de courant et envoi de la trame\nlet courantAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(courantAEcrire) || courantAEcrire < 0 || courantAEcrire > 150) {\n    msg.error = \"Courant invalide. Valeur attendue entre 0A et 150A\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_max_charge_current\";\nnewMsg.payload = generateModbusWriteCommand(courantAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 1460,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "e1b5d6daa74cc917",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write BMS max discharge current",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient le courant en ampères (ex: 5)\nfunction generateModbusWriteCommand(current) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion du courant selon l'échelle observée (140A = 140000)\n    // Exemple: 5A -> 5000\n    const currentValue = Math.round(current * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x38,                           // Register address low byte (0x38)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32, on envoie les 4 octets (du plus significatif au moins significatif)\n        (currentValue >> 24) & 0xFF,    // Octet 1 (MSB)\n        (currentValue >> 16) & 0xFF,    // Octet 2\n        (currentValue >> 8) & 0xFF,     // Octet 3\n        currentValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Pour debug, affichons la valeur\n    node.warn(`Écriture de ${current}A soit ${currentValue} unités`);\n    node.warn(`Valeur en hex: 0x${currentValue.toString(16).padStart(8, '0')}`);\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de courant et envoi de la trame\nlet courantAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(courantAEcrire) || courantAEcrire < 0 || courantAEcrire > 150) {\n    msg.error = \"Courant invalide. Valeur attendue entre 0A et 150A\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_bms_max_discharge_current\";\nnewMsg.payload = generateModbusWriteCommand(courantAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 1500,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "10d7690719c5a734",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write BMS power off voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension en volts (ex: 2.5)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (2.5V -> 2500mV)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x28,                           // Register address low byte (0x28)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32, on envoie les 4 octets (du plus significatif au moins significatif)\n        (voltageValue >> 24) & 0xFF,    // Octet 1 (MSB)\n        (voltageValue >> 16) & 0xFF,    // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Pour debug, affichons la valeur\n    node.warn(`Écriture de ${voltage}V soit ${voltageValue}mV`);\n    node.warn(`Valeur en hex: 0x${voltageValue.toString(16).padStart(8, '0')}`);\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 1.8 || tensionAEcrire > 3.0) {\n    msg.error = \"Tension invalide. Valeur attendue entre 1.8V et 3.0V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_power_off_voltage\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 1540,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "452323515d5b4f2d",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write LCD-on-off",
        "func": "// Node-RED function node pour générer la trame Modbus\nfunction generateModbusCommand(setLCDOn) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,       // Slave ID\n        0x10,       // Function code (16 - Write Multiple Registers)\n        0x11,       // Register address high byte (0x11)\n        0x14,       // Register address low byte (0x14)\n        0x00,       // Quantity of registers high byte\n        0x01,       // Quantity of registers low byte\n        0x02,       // Byte count\n        0x00,       // Data high byte\n        setLCDOn ? 0x10 : 0x00  // Data low byte (bit 4 set or unset)\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    return Buffer.from(command);\n}\n\n// Traitement du payload d'entrée\nlet setLCDOn = msg.payload.toLowerCase() === \"true\";\n\n// Envoi de la trame\nmsg.topic = \"LCD\";\nmsg.payload = generateModbusCommand(setLCDOn);\n\n// Fonction pour extraire les 9 premiers bits de la réponse\nmsg.extractBits = function(response) {\n    if (response && response.length >= 5) {\n        const uint16Value = (response[3] << 8) | response[4];\n        let bitStates = {};\n        for (let i = 0; i < 9; i++) {\n            bitStates[`bit${i}`] = (uint16Value >> i) & 1;\n        }\n        return bitStates;\n    }\n    return null;\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 1580,
        "wires": [
            [
                "1b9d270fb278785c",
                "bcb6622b78752c20"
            ]
        ]
    },
    {
        "id": "ca1db571bf48ece1",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write PCL_Disable",
        "func": "// Node-RED function node pour générer la trame Modbus\nfunction generateModbusCommand(setPCLDisabled) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,       // Slave ID\n        0x10,       // Function code (16 - Write Multiple Registers)\n        0x11,       // Register address high byte (0x11)\n        0x14,       // Register address low byte (0x14)\n        0x00,       // Quantity of registers high byte\n        0x01,       // Quantity of registers low byte\n        0x02,       // Byte count\n        0x00,       // Data high byte\n        setPCLDisabled ? 0x80 : 0x00  // Data low byte (bit 7 set or unset)\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    return Buffer.from(command);\n}\n\n// Traitement du payload d'entrée\nlet setPCLDisabled = msg.payload.toLowerCase() === \"true\";\n\n// Envoi de la trame\nmsg.topic = \"PCL_Disable\";\nmsg.payload = generateModbusCommand(setPCLDisabled);\n\n// Fonction pour extraire les 9 premiers bits de la réponse\nmsg.extractBits = function(response) {\n    if (response && response.length >= 5) {\n        const uint16Value = (response[3] << 8) | response[4];\n        let bitStates = {};\n        for (let i = 0; i < 9; i++) {\n            bitStates[`bit${i}`] = (uint16Value >> i) & 1;\n        }\n        return bitStates;\n    }\n    return null;\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 1620,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "25bbb554698f3085",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write smart sleep switch",
        "func": "// Node-RED function node pour générer la trame Modbus\nfunction generateModbusCommand(setSmartSleepOn) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,       // Slave ID\n        0x10,       // Function code (16 - Write Multiple Registers)\n        0x11,       // Register address high byte (0x11)\n        0x14,       // Register address low byte (0x14)\n        0x00,       // Quantity of registers high byte\n        0x01,       // Quantity of registers low byte\n        0x02,       // Byte count\n        0x00,       // Data high byte\n        setSmartSleepOn ? 0x40 : 0x00  // Data low byte (bit 6 set or unset)\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    return Buffer.from(command);\n}\n\n// Traitement du payload d'entrée\nlet setSmartSleepOn = msg.payload.toLowerCase() === \"true\";\n\n// Envoi de la trame\nmsg.topic = \"Smart_Sleep\";\nmsg.payload = generateModbusCommand(setSmartSleepOn);\n\n// Fonction pour extraire les 9 premiers bits de la réponse\nmsg.extractBits = function(response) {\n    if (response && response.length >= 5) {\n        const uint16Value = (response[3] << 8) | response[4];\n        let bitStates = {};\n        for (let i = 0; i < 9; i++) {\n            bitStates[`bit${i}`] = (uint16Value >> i) & 1;\n        }\n        return bitStates;\n    }\n    return null;\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 1660,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "d4b59e37e854b67d",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write Timed_Stored_Data",
        "func": "// Node-RED function node pour générer la trame Modbus\nfunction generateModbusCommand(setTimedStoredDataOn) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,       // Slave ID\n        0x10,       // Function code (16 - Write Multiple Registers)\n        0x11,       // Register address high byte (0x11)\n        0x14,       // Register address low byte (0x14)\n        0x00,       // Quantity of registers high byte\n        0x01,       // Quantity of registers low byte\n        0x02,       // Byte count\n        setTimedStoredDataOn ? 0x01 : 0x00,  // Data high byte (bit 8 set or unset)\n        0x00        // Data low byte\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    return Buffer.from(command);\n}\n\n// Traitement du payload d'entrée\nlet setTimedStoredDataOn = msg.payload.toLowerCase() === \"true\";\n\n// Envoi de la trame\nmsg.topic = \"Timed_Stored_Data\";\nmsg.payload = generateModbusCommand(setTimedStoredDataOn);\n\n// Fonction pour extraire les 9 premiers bits de la réponse\nmsg.extractBits = function(response) {\n    if (response && response.length >= 5) {\n        const uint16Value = (response[3] << 8) | response[4];\n        let bitStates = {};\n        for (let i = 0; i < 9; i++) {\n            bitStates[`bit${i}`] = (uint16Value >> i) & 1;\n        }\n        return bitStates;\n    }\n    return null;\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 1700,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "4782063a6f4cbb89",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "Write BMS_smart_sleep_voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue : msg.payload contient la tension (exemple : 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Conversion de la tension en millivolts (par exemple, 3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x00,                           // Register address low byte (0x00)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en Big Endian (BE), on envoie d'abord les octets de poids fort\n        (voltageValue >> 24) & 0xFF,    // Octet 1 (MSB)\n        (voltageValue >> 16) & 0xFF,    // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n\n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet smartSleepVoltage = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(smartSleepVoltage) || smartSleepVoltage < 2.5 || smartSleepVoltage > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_smart_sleep_voltage\";\nnewMsg.payload = generateModbusWriteCommand(smartSleepVoltage);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 1740,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "b545eac4a5a827f8",
        "type": "debug",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "debug 18",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 740,
        "y": 980,
        "wires": []
    },
    {
        "id": "b997b486b520ba66",
        "type": "debug",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "debug 12",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 730,
        "y": 940,
        "wires": []
    },
    {
        "id": "969bfbdc6ff80482",
        "type": "debug",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "debug 11",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 690,
        "y": 900,
        "wires": []
    },
    {
        "id": "223504123cb3206a",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "function 1",
        "func": "// Handle incoming commands from Home Assistant\nvar parameter = msg.topic.split('/')[2]; // Extract parameter name\nvar value = msg.payload;  // Création du stateTopic original\nvar stateTopic = msg.topic.replace('/set', '/state');  \n\n// Récupère le numéro du BMS et met à jour la variable globale\nconst topicParts = msg.topic.split('_');\nconst slaveAddress = parseInt(topicParts[1].split('/')[0]);\nglobal.set('slaveAddress-setup', slaveAddress);  \n\n// Création du stateTopic_bis en retirant \"BMS_n/\" et remplaçant \"/set\" par \"/state\"\nconst stateTopic_bis = msg.topic.replace(/BMS_\\d+\\//, '').replace('/set', '/state');\n\nreturn [\n    { \n        topic: stateTopic, \n        payload: value, \n        retain: true,\n        stateTopic_bis: stateTopic_bis  // Ajoutez stateTopic_bis ici\n    },\n    { \n        payload: { \n            parameter: parameter, \n            value: value\n        } \n    }\n];",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 220,
        "wires": [
            [
                "81acf21e86521b86",
                "8f82452292423562",
                "f446b30dc2078f42"
            ]
        ]
    },
    {
        "id": "3b20d857112c188b",
        "type": "inject",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "BMS_n/",
        "props": [
            {
                "p": "topic",
                "v": "[\"control/+/set\",\"BMS_1/control/+/set\",\"BMS_2/control/+/set\",\"BMS_3/control/+/set\",\"BMS_4/control/+/set\",\"BMS_5/control/+/set\",\"BMS_6/control/+/set\",\"BMS_7/control/+/set\",\"BMS_8/control/+/set\",\"BMS_9/control/+/set\",\"BMS_10/control/+/set\",\"BMS_11/control/+/set\",\"BMS_12/control/+/set\",\"BMS_13/control/+/set\",\"BMS_14/control/+/set\",\"BMS_15/control/+/set\"]",
                "vt": "json"
            },
            {
                "p": "action",
                "v": "subscribe",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "0.2",
        "topic": "",
        "x": 120,
        "y": 100,
        "wires": [
            [
                "b6ad66b9c7594229"
            ]
        ]
    },
    {
        "id": "0feab4f81e28026c",
        "type": "mqtt in",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "",
        "topic": "",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "56f7b2737cce493b",
        "nl": false,
        "rap": false,
        "inputs": 1,
        "x": 710,
        "y": 100,
        "wires": [
            [
                "d9252d611463a606"
            ]
        ]
    },
    {
        "id": "842d499ea9fe3f9c",
        "type": "debug",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "debug 30",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 770,
        "y": 460,
        "wires": []
    },
    {
        "id": "830726d692b9c886",
        "type": "debug",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "debug 6",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 750,
        "y": 500,
        "wires": []
    },
    {
        "id": "37a35ec9033764b1",
        "type": "switch",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "bms_broadcasting ?",
        "property": "bms_broadcasting",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 520,
        "y": 100,
        "wires": [
            [],
            [
                "0feab4f81e28026c"
            ]
        ]
    },
    {
        "id": "b6ad66b9c7594229",
        "type": "switch",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "CAN_bus_usage ?",
        "property": "CAN_bus_usage",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 290,
        "y": 100,
        "wires": [
            [],
            [
                "37a35ec9033764b1"
            ]
        ]
    },
    {
        "id": "0e879f0b1033923c",
        "type": "debug",
        "z": "348d851bc48bb663",
        "g": "18188dc49c4fd89a",
        "name": "debug 3",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 140,
        "y": 260,
        "wires": []
    },
    {
        "id": "b4210ea0e3eceeca",
        "type": "function",
        "z": "348d851bc48bb663",
        "d": true,
        "g": "0bbb61cb5f6504ae",
        "name": "BMS LCD buzzer trigger",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la valeur (0 à 3)\n\nfunction generateModbusWriteCommand(value) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion en UINT8 (valeur non signée sur 8 bits)\n    const uint8Value = Math.round(value) & 0xFF;\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01;\n    \n    // Pour un UINT8, on écrit 1 registre (16 bits) mais seulement l'octet de poids faible est utilisé\n    const command = [\n        slaveId,                           // Slave ID\n        0x06,                              // Function code (06/0x06 - Write Single Register)\n        0x14,                              // Register address high byte (0x14)\n        0xE4,                              // Register address low byte (0xE4)\n        0x00,                              // Data high byte (0x00 pour UINT8)\n        uint8Value                         // Data low byte (valeur UINT8)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur et envoi de la trame\nlet valeurAEcrire = parseInt(msg.payload);\n\n// Validation basique\nif (isNaN(valeurAEcrire) || valeurAEcrire < 0 || valeurAEcrire > 12) {\n    msg.error = \"Valeur invalide. Valeur attendue entre 0 et 12\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_lcd_buzzer_trigger\";\nnewMsg.payload = generateModbusWriteCommand(valeurAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 1780,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "19813c881712a20f",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "BMS LCD buzzer trigger value",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient le pourcentage (0 à 100)\n\nfunction generateModbusWriteCommand(percentage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion en INT32 (valeur signée sur 32 bits)\n    const value = Math.round(percentage);\n    \n    // Conversion INT32 en buffer 4 octets (Big Endian)\n    const buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(value, 0);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01;\n    \n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                              // Function code (16/0x10 - Write Multiple Registers)\n        0x14,                              // Register address high byte (0x14)\n        0xE8,                              // Register address low byte (0xE8)\n        0x00,                              // Quantity high byte (2 registres pour int32)\n        0x02,                              // Quantity low byte (2 registres pour int32)\n        0x04,                              // Byte count (4 bytes pour int32)\n        buffer[0],                         // Octet 1 (MSB)\n        buffer[1],                         // Octet 2\n        buffer[2],                         // Octet 3\n        buffer[3]                          // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de pourcentage et envoi de la trame\nlet percentageAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(percentageAEcrire) || percentageAEcrire < 0 || percentageAEcrire > 100) {\n    msg.error = \"Valeur invalide. Pourcentage attendu entre 0 et 100\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_lcd_buzzer_trigger_value\";\nnewMsg.payload = generateModbusWriteCommand(percentageAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 1820,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "1d8951e6d5cadaac",
        "type": "function",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "BMS LCD buzzer release value",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient le pourcentage (0 à 100)\n\nfunction generateModbusWriteCommand(percentage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion en INT32 (valeur signée sur 32 bits)\n    const value = Math.round(percentage);\n    \n    // Conversion INT32 en buffer 4 octets (Big Endian)\n    const buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(value, 0);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01;\n    \n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                              // Function code (16/0x10 - Write Multiple Registers)\n        0x14,                              // Register address high byte (0x14)\n        0xEC,                              // Register address low byte (0xEC)\n        0x00,                              // Quantity high byte (2 registres pour int32)\n        0x02,                              // Quantity low byte (2 registres pour int32)\n        0x04,                              // Byte count (4 bytes pour int32)\n        buffer[0],                         // Octet 1 (MSB)\n        buffer[1],                         // Octet 2\n        buffer[2],                         // Octet 3\n        buffer[3]                          // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de pourcentage et envoi de la trame\nlet percentageAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(percentageAEcrire) || percentageAEcrire < 0 || percentageAEcrire > 100) {\n    msg.error = \"Valeur invalide. Pourcentage attendu entre 0 et 100\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_lcd_buzzer_release_value\";\nnewMsg.payload = generateModbusWriteCommand(percentageAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 1860,
        "wires": [
            [
                "1b9d270fb278785c"
            ]
        ]
    },
    {
        "id": "bcb6622b78752c20",
        "type": "debug",
        "z": "348d851bc48bb663",
        "g": "0bbb61cb5f6504ae",
        "name": "debug 5",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 890,
        "y": 1600,
        "wires": []
    },
    {
        "id": "24f7bb18c1109510",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "71ff535abf2657b3",
        "name": "Modbus Out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 130,
        "y": 460,
        "wires": []
    },
    {
        "id": "74c53c8fdd7c6f6e",
        "type": "link in",
        "z": "7eba58462314a0d7",
        "g": "c7bb4746ce710cb1",
        "name": "Broadcast-in",
        "links": [
            "44c1946af35b4bf2",
            "a760f49cb3f03843"
        ],
        "x": 75,
        "y": 660,
        "wires": [
            [
                "88b164ac7026be0e",
                "40053a1d91143e21"
            ]
        ]
    },
    {
        "id": "1bb4998cb85dda4e",
        "type": "link out",
        "z": "7eba58462314a0d7",
        "g": "c7bb4746ce710cb1",
        "name": "data-out",
        "mode": "link",
        "links": [
            "e207f8c07a156191"
        ],
        "x": 765,
        "y": 680,
        "wires": []
    },
    {
        "id": "a65a870d600bb230",
        "type": "link out",
        "z": "7eba58462314a0d7",
        "g": "c7bb4746ce710cb1",
        "name": "setup-out",
        "mode": "link",
        "links": [
            "a4be995f90fc779c"
        ],
        "x": 765,
        "y": 640,
        "wires": []
    },
    {
        "id": "bc098ac8e7c2a80e",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "b75a55c2aaa3b2b6",
        "name": "Trame 3",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 140,
        "y": 1040,
        "wires": []
    },
    {
        "id": "e207f8c07a156191",
        "type": "link in",
        "z": "7eba58462314a0d7",
        "g": "b75a55c2aaa3b2b6",
        "name": "data-in",
        "links": [
            "1bb4998cb85dda4e"
        ],
        "x": 75,
        "y": 1000,
        "wires": [
            [
                "bc098ac8e7c2a80e",
                "2773a8c67764f19a"
            ]
        ]
    },
    {
        "id": "ace79b04ef5d3953",
        "type": "mqtt out",
        "z": "7eba58462314a0d7",
        "g": "b75a55c2aaa3b2b6",
        "name": "Onduleur",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 620,
        "y": 1000,
        "wires": []
    },
    {
        "id": "b8c6447a9aadb290",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "b75a55c2aaa3b2b6",
        "name": "debug 15",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 620,
        "y": 1040,
        "wires": []
    },
    {
        "id": "6ac6b1debaf96f4e",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "b75a55c2aaa3b2b6",
        "name": "Trame Data",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 410,
        "y": 1040,
        "wires": []
    },
    {
        "id": "e3768062bfabfaf0",
        "type": "function",
        "z": "7eba58462314a0d7",
        "g": "b75a55c2aaa3b2b6",
        "name": "Data To MQTT",
        "func": "// Récupération de l'adresse BMS depuis msg.bms_adresse\nlet bmsAdresse = msg.bms_adresse;\n\n// Gestion du cas où bmsAdresse est \"master\" (string) ou un nombre\nlet slaveIdStr;\nif (typeof bmsAdresse === \"string\" && bmsAdresse.toLowerCase() === \"master\") {\n    slaveIdStr = \"master\";\n} else if (typeof bmsAdresse === \"number\") {\n    slaveIdStr = String(bmsAdresse);\n} else if (!isNaN(Number(bmsAdresse))) {\n    slaveIdStr = String(Number(bmsAdresse));\n} else {\n    // Valeur par défaut si jamais la donnée est absente ou invalide\n    slaveIdStr = \"1\";\n}\n\n// Debug pour vérifier la valeur prise\nconsole.log(`BMS utilisé: ${slaveIdStr}`);\n// node.warn(`BMS utilisé: ${slaveIdStr}`);\n\nvar payload = msg.payload;\nvar baseTopic = \"BMS_\" + slaveIdStr;\nvar discoveryPrefix = \"homeassistant/sensor\";\nvar deviceName = \"BMS_\" + slaveIdStr;\nvar deviceID = \"BMS_\" + slaveIdStr + \"_device\";\nvar dynamicDataTopic = `${baseTopic}/donnees_dynamiques`;\n\nvar topics = {};\nvar discoveryMsgs = [];\nvar dynamicData = {};\n\n// Extraire uniquement les tensions des cellules\nvar cellVoltages = [];\nvar cellKeys = [];\nfor (var key in payload) {\n    if (key.includes(\"Cell_\") && key.includes(\"volt\") && key.endsWith(\"_V\")) {\n        let voltage = Number(payload[key]);\n        if (!isNaN(voltage)) {\n            cellVoltages.push(voltage);\n            cellKeys.push(key);\n        }\n    }\n}\n\n// Calculs des statistiques des cellules\nif (cellVoltages.length > 0) {\n    var cellAvgVolt = cellVoltages.reduce((sum, voltage) => sum + voltage, 0) / cellVoltages.length;\n    var cellMaxVolt = Math.max(...cellVoltages);\n    var cellMinVolt = Math.min(...cellVoltages);\n    var cellDeltaVolt = cellMaxVolt - cellMinVolt;\n    var maxVoltIndex = cellKeys[cellVoltages.indexOf(cellMaxVolt)].match(/Cell_(\\d+)/)[1];\n    var minVoltIndex = cellKeys[cellVoltages.indexOf(cellMinVolt)].match(/Cell_(\\d+)/)[1];\n    payload[\"cell_voltage_average_V\"] = parseFloat(cellAvgVolt.toFixed(3));\n    payload[\"cell_voltage_delta_V\"] = parseFloat(cellDeltaVolt.toFixed(3));\n    payload[\"cell_voltage_max_number_N\"] = parseInt(maxVoltIndex);\n    payload[\"cell_voltage_min_number_N\"] = parseInt(minVoltIndex);\n}\n\n// Ajouter toutes les valeurs dynamiquement\nfor (var key in payload) {\n    var cleanKey = key.replace(/_[A-Z]+$/, \"\");\n    var sensorTopic = `${baseTopic}/${cleanKey}`;\n    topics[sensorTopic] = payload[key];\n    dynamicData[cleanKey] = payload[key];\n\n    var configTopic = `${discoveryPrefix}/${deviceID}_${cleanKey}/config`;\n    var configPayload = {\n        name: cleanKey,\n        unique_id: `${deviceID}_${cleanKey}`,\n        state_topic: sensorTopic,\n        unit_of_measurement: \"\",\n        entity_category: \"diagnostic\",\n        device: {\n            identifiers: [deviceID],\n            name: deviceName,\n            manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n            model: \"JK-BMS - RS485 - Ip Gateway\",\n            sw_version: \"2.0.0\"\n        }\n    };\n\n    if (key.endsWith(\"_V\")) configPayload.unit_of_measurement = \"V\";\n    if (key.endsWith(\"_Ah\")) configPayload.unit_of_measurement = \"Ah\";\n    if (key.endsWith(\"_A\")) configPayload.unit_of_measurement = \"A\";\n    if (key.endsWith(\"_W\")) configPayload.unit_of_measurement = \"W\";\n    if (key.endsWith(\"_T\")) configPayload.unit_of_measurement = \"°C\";\n    if (key.endsWith(\"_R\")) configPayload.unit_of_measurement = \"Ω\";\n    if (key.endsWith(\"_P\")) {\n        configPayload.unit_of_measurement = \"%\";\n        if (key.startsWith(\"SOC\")) {\n            configPayload.device_class = \"battery\";\n        }\n    }\n    if (key.endsWith(\"_S\")) configPayload.unit_of_measurement = \"s\";\n\n    discoveryMsgs.push({ topic: configTopic, payload: JSON.stringify(configPayload), retain: true });\n}\n\n// Publier les données dynamiques sous un seul topic\ntopics[dynamicDataTopic] = JSON.stringify(dynamicData);\n\nvar outputMsgs = discoveryMsgs;\nfor (var topic in topics) {\n    outputMsgs.push({ topic: topic, payload: topics[topic] });\n}\n\nreturn [outputMsgs];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 1000,
        "wires": [
            [
                "b8c6447a9aadb290",
                "ace79b04ef5d3953"
            ]
        ]
    },
    {
        "id": "2773a8c67764f19a",
        "type": "buffer-parser",
        "z": "7eba58462314a0d7",
        "g": "b75a55c2aaa3b2b6",
        "name": "Trame 3",
        "data": "payload",
        "dataType": "msg",
        "specification": "spec",
        "specificationType": "ui",
        "items": [
            {
                "type": "uint16le",
                "name": "Cell_1_volt_V",
                "offset": 6,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_2_volt_V",
                "offset": 8,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_3_volt_V",
                "offset": 10,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_4_volt_V",
                "offset": 12,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_5_volt_V",
                "offset": 14,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_6_volt_V",
                "offset": 16,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_7_volt_V",
                "offset": 18,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_8_volt_V",
                "offset": 20,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_9_volt_V",
                "offset": 22,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_10_volt_V",
                "offset": 24,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_11_volt_V",
                "offset": 26,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_12_volt_V",
                "offset": 28,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_13_volt_V",
                "offset": 30,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_14_volt_V",
                "offset": 32,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_15_volt_V",
                "offset": 34,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_16_volt_V",
                "offset": 36,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_1_ohm_R",
                "offset": 80,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_2_ohm_R",
                "offset": 82,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_3_ohm_R",
                "offset": 84,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_4_ohm_R",
                "offset": 86,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_5_ohm_R",
                "offset": 88,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_6_ohm_R",
                "offset": 90,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_7_ohm_R",
                "offset": 92,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_8_ohm_R",
                "offset": 94,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_9_ohm_R",
                "offset": 96,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_10_ohm_R",
                "offset": 98,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_11_ohm_R",
                "offset": 100,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_12_ohm_R",
                "offset": 102,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_13_ohm_R",
                "offset": 104,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_14_ohm_R",
                "offset": 106,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_15_ohm_R",
                "offset": 108,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_16_ohm_R",
                "offset": 110,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Mos_temp_T",
                "offset": 144,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "uint32le",
                "name": "Puissance_Totale_W",
                "offset": 154,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Courant_total_A",
                "offset": 158,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Sonde_1_temp_T",
                "offset": 162,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Sonde_2_temp_T",
                "offset": 164,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Balance_courant_A",
                "offset": 170,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "byte",
                "name": "Balance_Action_B",
                "offset": 172,
                "length": 1,
                "offsetbit": 0,
                "scale": "/100",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "SOC_pourcentage_P",
                "offset": 173,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Capacite_restante_Ah",
                "offset": 174,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Capacite_batterie_Ah",
                "offset": 178,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Nombre_Cycle_N",
                "offset": 182,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Cycle_Capacite_Ah",
                "offset": 186,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "SOH_pourcentage_P",
                "offset": 190,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint32le",
                "name": "Total_runtime_S",
                "offset": 194,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "byte",
                "name": "Switch_Charge_B",
                "offset": 198,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "byte",
                "name": "Switch_Decharge_B",
                "offset": 199,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "byte",
                "name": "Switch_Balance_B",
                "offset": 200,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Tension_Totale_volt_V",
                "offset": 234,
                "length": 1,
                "offsetbit": 0,
                "scale": "/100",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Sonde_3_temp_T",
                "offset": 254,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Sonde_4_temp_T",
                "offset": 258,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            }
        ],
        "swap1": "",
        "swap2": "",
        "swap3": "",
        "swap1Type": "swap",
        "swap2Type": "swap",
        "swap3Type": "swap",
        "msgProperty": "payload",
        "msgPropertyType": "str",
        "resultType": "keyvalue",
        "resultTypeType": "return",
        "multipleResult": false,
        "fanOutMultipleResult": false,
        "setTopic": true,
        "outputs": 1,
        "x": 200,
        "y": 1000,
        "wires": [
            [
                "6ac6b1debaf96f4e",
                "e3768062bfabfaf0"
            ]
        ]
    },
    {
        "id": "d0b96287555baddd",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "a1697c874f4c5e2d",
        "name": "Trame Setup",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 410,
        "y": 900,
        "wires": []
    },
    {
        "id": "5379d0376efbcee9",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "a1697c874f4c5e2d",
        "name": "Trame 2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 200,
        "y": 900,
        "wires": []
    },
    {
        "id": "a4be995f90fc779c",
        "type": "link in",
        "z": "7eba58462314a0d7",
        "g": "a1697c874f4c5e2d",
        "name": "setup-in",
        "links": [
            "a65a870d600bb230"
        ],
        "x": 75,
        "y": 860,
        "wires": [
            [
                "5379d0376efbcee9",
                "6ca68da351cc699c"
            ]
        ]
    },
    {
        "id": "6ca68da351cc699c",
        "type": "buffer-parser",
        "z": "7eba58462314a0d7",
        "g": "a1697c874f4c5e2d",
        "name": "Trame 2",
        "data": "payload",
        "dataType": "msg",
        "specification": "spec",
        "specificationType": "ui",
        "items": [
            {
                "type": "int32le",
                "name": "smart_sleep_voltage_V",
                "offset": 6,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_voltage_undervoltage_protection_V",
                "offset": 10,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_voltage_undervoltage_recovery_V",
                "offset": 14,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_voltage_overvoltage_protection_V",
                "offset": 18,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_voltage_overvoltage_recovery_V",
                "offset": 22,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "balance_trigger_voltage_V",
                "offset": 26,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_soc100_voltage_V",
                "offset": 30,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_soc0_voltage_V",
                "offset": 34,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_request_charge_voltage_V",
                "offset": 38,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_request_float_voltage_V",
                "offset": 42,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "power_off_voltage_V",
                "offset": 46,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "max_charge_current_A",
                "offset": 50,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_overcurrent_protection_delay_S",
                "offset": 54,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_overcurrent_protection_recovery_time_S",
                "offset": 58,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "max_discharge_current_S",
                "offset": 62,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "discharge_overcurrent_protection_delay_S",
                "offset": 66,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "discharge_overcurrent_protection_recovery_time_S",
                "offset": 70,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "short_circuit_protection_recovery_time_S",
                "offset": 74,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "max_balance_current_A",
                "offset": 78,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_overtemperature_protection_T",
                "offset": 82,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_overtemperature_protection_recovery_T",
                "offset": 86,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "discharge_overtemperature_protection_T",
                "offset": 90,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "discharge_overtemperature_protection_recovery_T",
                "offset": 94,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_undertemperature_protection_T",
                "offset": 98,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_undertemperature_protection_recovery_T",
                "offset": 102,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "power_tube_overtemperature_protection_T",
                "offset": 106,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "power_tube_overtemperature_protection_recovery_T",
                "offset": 110,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_count_N",
                "offset": 114,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "charging_switch_B",
                "offset": 118,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "discharging_switch_B",
                "offset": 122,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "balance_switch_B",
                "offset": 126,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "total_battery_capacity_Ah",
                "offset": 130,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "short_circuit_protection_delay_S",
                "offset": 134,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "balance_starting_voltage_V",
                "offset": 138,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Connexion_wire_resistance_1_R",
                "offset": 158,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": " Device_address_N",
                "offset": 270,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "display_always_on_switch_B",
                "offset": 282,
                "length": 1,
                "offsetbit": 4,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "smart_sleep_switch_B",
                "offset": 282,
                "length": 1,
                "offsetbit": 7,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "disable_pcl_module_switch_B",
                "offset": 282,
                "length": 1,
                "offsetbit": 8,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "timed_stored_data_switch_B",
                "offset": 283,
                "length": 1,
                "offsetbit": 1,
                "scale": "1",
                "mask": ""
            }
        ],
        "swap1": "",
        "swap2": "",
        "swap3": "",
        "swap1Type": "swap",
        "swap2Type": "swap",
        "swap3Type": "swap",
        "msgProperty": "payload",
        "msgPropertyType": "str",
        "resultType": "keyvalue",
        "resultTypeType": "return",
        "multipleResult": false,
        "fanOutMultipleResult": false,
        "setTopic": true,
        "outputs": 1,
        "x": 200,
        "y": 860,
        "wires": [
            [
                "d0b96287555baddd",
                "4716f48d98903bbc"
            ]
        ]
    },
    {
        "id": "4716f48d98903bbc",
        "type": "function",
        "z": "7eba58462314a0d7",
        "g": "a1697c874f4c5e2d",
        "name": "Setup To MQTT",
        "func": "// --- Récupération de l'adresse BMS depuis msg.bms_adresse ---\nlet bmsAdresse = msg.bms_adresse;\n\n// Gestion du cas où bmsAdresse est \"master\" (string) ou un nombre\nlet slaveIdStr;\nif (typeof bmsAdresse === \"string\" && bmsAdresse.toLowerCase() === \"master\") {\n    slaveIdStr = \"master\";\n} else if (typeof bmsAdresse === \"number\") {\n    slaveIdStr = String(bmsAdresse);\n} else if (!isNaN(Number(bmsAdresse))) {\n    slaveIdStr = String(Number(bmsAdresse));\n} else {\n    // Valeur par défaut si jamais la donnée est absente ou invalide\n    slaveIdStr = \"1\";\n}\n\n// --- Définition des variables de base ---\nvar payload = msg.payload;\nvar baseTopic = \"BMS_\" + slaveIdStr;\nvar discoveryPrefix = \"homeassistant\";\nvar deviceName = \"BMS_\" + slaveIdStr;\nvar deviceID = \"BMS_\" + slaveIdStr + \"_device\";\n\nvar discoveryMsgs = [];\n\n// --- Fonction de conversion des booléens ---\nfunction formatBoolean(value) {\n    if (typeof value === 'boolean') {\n        return value ? 'True' : 'False';\n    }\n    if (typeof value === 'string') {\n        const lowerVal = value.toLowerCase();\n        return lowerVal === 'true' ? 'True' : lowerVal === 'false' ? 'False' : value;\n    }\n    return value;\n}\n\n// --- Fonction de création du payload de config Home Assistant ---\nfunction createConfigPayload(key, value) {\n    var cleanKey = key.replace(/_[A-Z]+$/, \"\").toLowerCase();\n    var entityType = \"number\";\n    if (key.endsWith(\"_B\")) {\n        entityType = \"switch\";\n    }\n    var configTopic = `${discoveryPrefix}/${entityType}/${deviceID}/${cleanKey}/config`;\n\n    var configPayload = {\n        name: `BMS ${key.replace(/_[A-Z]+$/, \"\").replace(/_/g, \" \")}`,\n        unique_id: `${deviceID}_${cleanKey}`,\n        state_topic: `${baseTopic}/control/${cleanKey}/state`,\n        command_topic: `${baseTopic}/control/${cleanKey}/set`,\n        entity_category: \"config\",\n        device: {\n            identifiers: [deviceID],\n            name: deviceName,\n            manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n            model: payload.BMS_A || \"JK-BMS - RS485 - Ip Gateway\",\n            sw_version: \"2.0.0\"\n        }\n    };\n\n    if (entityType === \"number\") {\n        configPayload.mode = \"box\";\n        if (key.endsWith(\"_V\")) {\n            configPayload.unit_of_measurement = \"V\";\n            configPayload.min = 0;\n            configPayload.max = 5;\n            configPayload.step = 0.01;\n        }\n        // Ajoute ici d'autres unités si besoin\n    } else if (entityType === \"switch\") {\n        configPayload.payload_on = \"True\";\n        configPayload.payload_off = \"False\";\n        configPayload.state_on = \"True\";\n        configPayload.state_off = \"False\";\n    }\n\n    return {\n        topic: configTopic,\n        payload: JSON.stringify(configPayload),\n        retain: true\n    };\n}\n\n// --- Génération des messages de découverte et d'état ---\nfor (var key in payload) {\n    // Message de découverte Home Assistant\n    discoveryMsgs.push(createConfigPayload(key, payload[key]));\n\n    // Message d'état pour chaque entité\n    var cleanKey = key.replace(/_[A-Z]+$/, \"\").toLowerCase();\n    var formattedValue = formatBoolean(payload[key]);\n    discoveryMsgs.push({\n        topic: `${baseTopic}/control/${cleanKey}/state`,\n        payload: formattedValue,\n        retain: true\n    });\n}\n\n// --- Retourne le tableau de messages MQTT ---\nreturn [discoveryMsgs];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 860,
        "wires": [
            [
                "13e4f2a13df6fe21",
                "34aa954d066715d4"
            ]
        ]
    },
    {
        "id": "13e4f2a13df6fe21",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "a1697c874f4c5e2d",
        "name": "debug 20",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 620,
        "y": 900,
        "wires": []
    },
    {
        "id": "34aa954d066715d4",
        "type": "mqtt out",
        "z": "7eba58462314a0d7",
        "g": "a1697c874f4c5e2d",
        "name": "Onduleur",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 620,
        "y": 860,
        "wires": []
    },
    {
        "id": "88b164ac7026be0e",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "c7bb4746ce710cb1",
        "name": "debug 23",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 180,
        "y": 700,
        "wires": []
    },
    {
        "id": "a760f49cb3f03843",
        "type": "link out",
        "z": "7eba58462314a0d7",
        "g": "71ff535abf2657b3",
        "name": "Broadcast-serial-Out",
        "mode": "link",
        "links": [
            "74c53c8fdd7c6f6e"
        ],
        "x": 735,
        "y": 440,
        "wires": []
    },
    {
        "id": "b28c235f729ec2af",
        "type": "switch",
        "z": "7eba58462314a0d7",
        "g": "71ff535abf2657b3",
        "name": "bms_broadcasting ?",
        "property": "bms_broadcasting",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 580,
        "y": 400,
        "wires": [
            [
                "d2613e804a5c9e0d",
                "cdc3910800c7d95b",
                "a760f49cb3f03843"
            ],
            []
        ]
    },
    {
        "id": "d2613e804a5c9e0d",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "71ff535abf2657b3",
        "name": "Broadcast-serial-Out",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 820,
        "y": 400,
        "wires": []
    },
    {
        "id": "bb4281bfb6b9a0ef",
        "type": "comment",
        "z": "7eba58462314a0d7",
        "name": "Cas du BMS défini en Master Modbus RS485",
        "info": "",
        "x": 270,
        "y": 40,
        "wires": []
    },
    {
        "id": "563e3f15cff0f735",
        "type": "comment",
        "z": "7eba58462314a0d7",
        "name": "C'est lui qui demande les informations aux autres BMS.",
        "info": "",
        "x": 380,
        "y": 80,
        "wires": []
    },
    {
        "id": "768cb6f2c7f68b49",
        "type": "comment",
        "z": "7eba58462314a0d7",
        "name": "Dans cette configuration, on ne peut pas changer les paramètres !!!",
        "info": "",
        "x": 520,
        "y": 120,
        "wires": []
    },
    {
        "id": "4f858553df8efd17",
        "type": "comment",
        "z": "7eba58462314a0d7",
        "name": "Car il ne peut pas y avoir 2 Master sur le bus en Modbus.",
        "info": "",
        "x": 650,
        "y": 160,
        "wires": []
    },
    {
        "id": "41542c3844b4344a",
        "type": "serial in",
        "z": "7eba58462314a0d7",
        "g": "71ff535abf2657b3",
        "name": "",
        "serial": "6e1abcbcc6ebb714",
        "x": 120,
        "y": 400,
        "wires": [
            [
                "24f7bb18c1109510",
                "76ddac3ef98c9d5f"
            ]
        ]
    },
    {
        "id": "cc1ee5cb46e0c0b3",
        "type": "file",
        "z": "7eba58462314a0d7",
        "g": "71ff535abf2657b3",
        "name": "",
        "filename": "/config/temp/broadcast-bms-1-8.txt",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 820,
        "y": 480,
        "wires": [
            []
        ]
    },
    {
        "id": "cdc3910800c7d95b",
        "type": "function",
        "z": "7eba58462314a0d7",
        "d": true,
        "g": "71ff535abf2657b3",
        "name": "debug en hexa",
        "func": "// Vérifie que le payload est un Buffer\nif (Buffer.isBuffer(msg.payload)) {\n    // Convertit chaque octet en hexadécimal sur 2 chiffres\n    msg.payload = msg.payload\n        .toString('hex')                // Convertit tout le buffer en une chaîne hexadécimale continue\n        .match(/.{1,2}/g)               // Coupe la chaîne tous les 2 caractères\n        .join(' ') + '\\n';              // Ajoute un espace entre chaque octet et un retour à la ligne\n} else if (Array.isArray(msg.payload)) {\n    // Si c'est un tableau, on le traite aussi\n    msg.payload = msg.payload\n        .map(x => x.toString(16).padStart(2, '0'))\n        .join(' ') + '\\n';\n} else {\n    // Sinon, on ne fait rien ou on peut lever une erreur\n    msg.payload = 'Payload non reconnu\\n';\n}\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 560,
        "y": 480,
        "wires": [
            [
                "cc1ee5cb46e0c0b3"
            ]
        ]
    },
    {
        "id": "40053a1d91143e21",
        "type": "function",
        "z": "7eba58462314a0d7",
        "g": "c7bb4746ce710cb1",
        "name": "Type trames + adresse modbus",
        "func": "// On suppose que msg.payload est un Buffer ou un Array d'octets\nlet payload = msg.payload;\nif (Buffer.isBuffer(payload)) payload = Array.from(payload);\n\n// Fonction utilitaire pour décoder le type de trame\nfunction typeTrame(byte) {\n    if (byte === 1) return \"setup\";\n    if (byte === 2) return \"data\";\n    return \"autre\";\n}\n\n// Trame \"master\" (broadcast) : commence par 55 aa eb 90\nif (\n    payload.length > 5 &&\n    payload[0] === 0x55 &&\n    payload[1] === 0xaa &&\n    payload[2] === 0xeb &&\n    payload[3] === 0x90\n) {\n    msg.bms_adresse = \"master\";\n    msg.bms_type = typeTrame(payload[4]); // offset 4\n    // On garde le payload tel quel\n    return msg;\n}\n\n// Trame \"courte\" : premier byte = adresse (de 1 à 15)\nif (\n    payload.length > 16 &&\n    payload[0] >= 0x01 &&\n    payload[0] <= 0x0F\n) {\n    msg.bms_adresse = payload[0];\n    msg.bms_type = typeTrame(payload[15]); // offset 15\n\n    // On cherche le début de la vraie trame (0x55, 0xAA)\n    let start = -1;\n    for (let i = 0; i < payload.length - 1; i++) {\n        if (payload[i] === 0x55 && payload[i+1] === 0xAA) {\n            start = i;\n            break;\n        }\n    }\n    if (start !== -1) {\n  let newPayload = payload.slice(start);\n  // Conversion explicite en Buffer pour compatibilité parser\n  msg.payload = Buffer.from(newPayload);\n  return msg;\n} else {\n  // Si pas de 0x55 0xAA trouvé, on ignore ou on passe la trame brute\n  return null;\n}\n\n}\n\n// Pour les autres trames, ignorer ou traiter différemment\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 270,
        "y": 660,
        "wires": [
            [
                "06b6d386a10741c2",
                "9bf8da3dfdb70216"
            ]
        ]
    },
    {
        "id": "06b6d386a10741c2",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "c7bb4746ce710cb1",
        "name": " Types de trames analysées",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 420,
        "y": 700,
        "wires": []
    },
    {
        "id": "9bf8da3dfdb70216",
        "type": "switch",
        "z": "7eba58462314a0d7",
        "g": "c7bb4746ce710cb1",
        "name": "Trame type ?",
        "property": "bms_type",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "setup",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "data",
                "vt": "str"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 610,
        "y": 660,
        "wires": [
            [
                "a65a870d600bb230"
            ],
            [
                "1bb4998cb85dda4e"
            ]
        ]
    },
    {
        "id": "54f13db307ef04c6",
        "type": "debug",
        "z": "7eba58462314a0d7",
        "g": "8db7330998795c6b",
        "name": "TCP debug ",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1010,
        "y": 240,
        "wires": []
    },
    {
        "id": "44c1946af35b4bf2",
        "type": "link out",
        "z": "7eba58462314a0d7",
        "g": "8db7330998795c6b",
        "name": "Broadcast-Out",
        "mode": "link",
        "links": [
            "74c53c8fdd7c6f6e"
        ],
        "x": 955,
        "y": 280,
        "wires": []
    },
    {
        "id": "ac5e2007494e8ec7",
        "type": "inject",
        "z": "7eba58462314a0d7",
        "g": "8db7330998795c6b",
        "name": "GW IP close",
        "props": [
            {
                "p": "action",
                "v": "close",
                "vt": "str"
            },
            {
                "p": "host",
                "v": "gateway_ip",
                "vt": "global"
            },
            {
                "p": "port",
                "v": "gateway_port",
                "vt": "global"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 690,
        "y": 280,
        "wires": [
            [
                "39deea4e80f940dc"
            ]
        ]
    },
    {
        "id": "39deea4e80f940dc",
        "type": "tcp-client",
        "z": "7eba58462314a0d7",
        "g": "8db7330998795c6b",
        "action": "action",
        "actionType": "msg",
        "host": "host",
        "hostType": "msg",
        "port": "port",
        "portType": "msg",
        "datamode": "stream",
        "datatype": "buffer",
        "newline": "",
        "write": "payload",
        "writeType": "msg",
        "maxRetries": "5",
        "retryDelay": "3000",
        "indefiniteRetries": false,
        "topic": "",
        "name": "",
        "debug": "warning",
        "x": 860,
        "y": 240,
        "wires": [
            [
                "54f13db307ef04c6",
                "44c1946af35b4bf2"
            ]
        ]
    },
    {
        "id": "36740c8949df9213",
        "type": "change",
        "z": "7eba58462314a0d7",
        "g": "8db7330998795c6b",
        "name": "GW IP Connect",
        "rules": [
            {
                "t": "set",
                "p": "action",
                "pt": "msg",
                "to": "connect",
                "tot": "str"
            },
            {
                "t": "set",
                "p": "host",
                "pt": "msg",
                "to": "gateway_ip",
                "tot": "global"
            },
            {
                "t": "set",
                "p": "port",
                "pt": "msg",
                "to": "gateway_port",
                "tot": "global"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 680,
        "y": 240,
        "wires": [
            [
                "39deea4e80f940dc"
            ]
        ]
    },
    {
        "id": "9065a93867dab80e",
        "type": "switch",
        "z": "7eba58462314a0d7",
        "g": "8db7330998795c6b",
        "name": "bms_broadcasting ?",
        "property": "bms_broadcasting",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 280,
        "y": 280,
        "wires": [
            [
                "73d8b350243362a9"
            ],
            []
        ]
    },
    {
        "id": "73d8b350243362a9",
        "type": "switch",
        "z": "7eba58462314a0d7",
        "g": "8db7330998795c6b",
        "name": "Use Gateway ?",
        "property": "use_gateway",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 480,
        "y": 280,
        "wires": [
            [
                "36740c8949df9213"
            ],
            []
        ]
    },
    {
        "id": "312ad2b56727f9b0",
        "type": "inject",
        "z": "7eba58462314a0d7",
        "g": "8db7330998795c6b",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "3",
        "topic": "",
        "payload": "1",
        "payloadType": "num",
        "x": 110,
        "y": 240,
        "wires": [
            [
                "69b1ce57af6c5821"
            ]
        ]
    },
    {
        "id": "69b1ce57af6c5821",
        "type": "switch",
        "z": "7eba58462314a0d7",
        "g": "8db7330998795c6b",
        "name": "CAN_bus_usage ?",
        "property": "CAN_bus_usage",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 270,
        "y": 240,
        "wires": [
            [],
            [
                "9065a93867dab80e"
            ]
        ]
    },
    {
        "id": "76ddac3ef98c9d5f",
        "type": "switch",
        "z": "7eba58462314a0d7",
        "g": "71ff535abf2657b3",
        "name": "CAN_bus_usage ?",
        "property": "CAN_bus_usage",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 350,
        "y": 400,
        "wires": [
            [],
            [
                "b28c235f729ec2af"
            ]
        ]
    },
    {
        "id": "db723bbce9cd2eb7",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "Autre",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 150,
        "y": 1120,
        "wires": []
    },
    {
        "id": "c3de74fe6e67e34d",
        "type": "exec",
        "z": "2e99fd421b434bcb",
        "g": "d03facb97e5d14d1",
        "command": "candump can0",
        "addpay": "",
        "append": "",
        "useSpawn": "true",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "CANdump",
        "x": 310,
        "y": 420,
        "wires": [
            [
                "0efe20eac7430343"
            ],
            [
                "b1930c0f7c133e97"
            ],
            []
        ]
    },
    {
        "id": "3228a87076560c09",
        "type": "inject",
        "z": "2e99fd421b434bcb",
        "g": "d03facb97e5d14d1",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 420,
        "wires": [
            [
                "c3de74fe6e67e34d"
            ]
        ]
    },
    {
        "id": "b1930c0f7c133e97",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "d03facb97e5d14d1",
        "name": "CAN dump",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 510,
        "y": 460,
        "wires": []
    },
    {
        "id": "0efe20eac7430343",
        "type": "rbe",
        "z": "2e99fd421b434bcb",
        "g": "d03facb97e5d14d1",
        "name": "",
        "func": "rbe",
        "gap": "",
        "start": "",
        "inout": "out",
        "septopics": true,
        "property": "payload",
        "topi": "topic",
        "x": 490,
        "y": 420,
        "wires": [
            [
                "a382ef9233e091ce",
                "f42caadb5356ae1d"
            ]
        ]
    },
    {
        "id": "edddd5764795e5e8",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "d03facb97e5d14d1",
        "name": "CAN décodées",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 780,
        "y": 460,
        "wires": []
    },
    {
        "id": "a382ef9233e091ce",
        "type": "function",
        "z": "2e99fd421b434bcb",
        "g": "d03facb97e5d14d1",
        "name": "Décodage protocole 6 - 500000 bds",
        "func": "// === Décodage trames CAN JKBMS - Dernière mise à jour ===\n\nfunction parseCanFrame(payload) {\n    const regex = /can0\\s+([A-F0-9]+)\\s+\\[8\\]\\s+([A-F0-9\\s]+)/;\n    const match = payload.match(regex);\n    if (!match) return null;\n    const canId = match[1];\n    const dataHex = match[2].trim().split(/\\s+/);\n    const data = dataHex.map(hex => parseInt(hex, 16));\n    return { canId, data };\n}\n\nfunction decode2F4(data) {\n    const totalVoltage = ((data[1] << 8) | data[0]) * 0.1;\n    const soc = data[4];\n    let rawCurrent = (data[3] << 8) | data[2];\n    if (rawCurrent > 32767) rawCurrent -= 65536;\n    const current = (rawCurrent * 0.1) - 400;\n    return {\n        type: \"main_status\",\n        totalVoltage,\n        soc,\n        current\n    };\n}\n\nfunction decode07F4(data) {\n    let alarmBits = 0;\n    for (let i = 0; i < 4; i++) {\n        alarmBits |= data[i] << (8 * i);\n    }\n    const alarmList = [\n        \"Cell overvoltage\",\n        \"Cell undervoltage\",\n        \"Total voltage overvoltage\",\n        \"Total voltage undervoltage\",\n        \"Large pressure difference of monomer\",\n        \"Discharge overcurrent\",\n        \"Charge overcurrent\",\n        \"Temperature is too high\",\n        \"Temperature is too low\",\n        \"Excessive temperature difference\",\n        \"SOC too low\",\n        \"Insulation is too low\",\n        \"High voltage interlock fault\",\n        \"External communication failure\",\n        \"Internal communication failure\"\n    ];\n    const alarms = [];\n    for (let i = 0; i < alarmList.length; i++) {\n        const level = (alarmBits >> (i * 2)) & 0x03;\n        if (level > 0) {\n            alarms.push({\n                code: i + 1,\n                name: alarmList[i],\n                level,\n                levelText: [\"\", \"Serious\", \"Important\", \"General\"][level]\n            });\n        }\n    }\n    return {\n        type: \"alarm_info\",\n        alarms,\n        alarmCount: alarms.length,\n        rawAlarmBits: alarmBits\n    };\n}\n\nfunction decode4F4(data) {\n    const deltaCellVoltage = data[0] * 0.001;\n    const maxCellVoltage = ((data[1] << 8) | data[0]) * 0.001;\n    const maxCellPosition = data[2];\n    const minCellVoltage = ((data[4] << 8) | data[3]) * 0.001;\n    const minCellPosition = data[5];\n    return {\n        type: \"cell_minmax\",\n        deltaCellVoltage,\n        maxCellVoltage,\n        maxCellPosition,\n        minCellVoltage,\n        minCellPosition\n    };\n}\n\nfunction decode5F4(data) {\n    const maxTemp = data[0] - 50;\n    const maxTempPosition = data[1];\n    const minTemp = data[2] - 50;\n    const minTempPosition = data[3];\n    const avgTemp = data[4] - 50;\n    return {\n        type: \"temperatures\",\n        maxTemp,\n        maxTempPosition,\n        minTemp,\n        minTempPosition,\n        avgTemp\n    };\n}\n\nfunction decode18F128F4(data) {\n    let current = (data[1] << 8) | data[0];\n    if (current > 32767) current -= 65536;\n    current *= 0.001;\n    const power = ((data[3] << 8) | data[2]) * 0.1;\n    const cycleCount = (data[7] << 8) | data[6];\n    return {\n        type: \"power_current\",\n        current,\n        power,\n        cycleCount\n    };\n}\n\n// ✅ MISE À JOUR : ID 01F21400\nfunction decode01F21400(data) {\n    // Byte 0–1 : Voltage (unsigned), × 0.01\n    const voltage = ((data[1] << 8) | data[0]) * 0.01;\n\n    // Byte 2–3 : Current (signed), × 0.1\n    let rawCurrent = (data[3] << 8) | data[2];\n    if (rawCurrent > 32767) rawCurrent -= 65536;\n    const current = rawCurrent * 0.1;\n\n    // Byte 4–5 : Temperature (signed), ÷ 10\n    let rawTemp = (data[5] << 8) | data[4];\n    if (rawTemp > 32767) rawTemp -= 65536;\n    const temperature = rawTemp / 10;\n\n    // Byte 6–7 : Cycle count (unsigned)\n    const cycleCount = (data[7] << 8) | data[6];\n\n    return {\n        type: \"monitoring\",\n        voltage,       // en V\n        current,       // en A\n        temperature,   // en °C\n        cycleCount\n    };\n}\n\nfunction decode18F528F4(data) {\n    const alarmCode = data[0];\n    const cycleCount = (data[2] << 8) | data[1];\n    const alarmMap = {\n        0: \"Normal\",\n        1: \"Cell overvoltage\",\n        2: \"Cell undervoltage\",\n        3: \"Pack overvoltage\",\n        4: \"Pack undervoltage\",\n        5: \"Charge overcurrent\",\n        6: \"Discharge overcurrent\",\n        7: \"Charge overtemp\",\n        8: \"Discharge overtemp\",\n        9: \"Charge undertemp\",\n        10: \"Discharge undertemp\",\n        11: \"MOS overtemp\",\n        12: \"Short circuit\",\n        13: \"BMS overtemp\",\n        14: \"BMS undertemp\",\n        23: \"Cell imbalance\",\n        35: \"System normal\"\n    };\n    return {\n        type: \"cycle_count\",\n        alarmCode,\n        alarmText: alarmMap[alarmCode] || `Unknown alarm ${alarmCode}`,\n        cycleCount\n    };\n}\n\nfunction decode1806E5F4(data) {\n    const value = (data[3] << 8) | data[2];\n    return {\n        type: \"status_data\",\n        value,\n        byte0: data[0],\n        byte1: data[1],\n        rawBytes: data\n    };\n}\n\nfunction decode18F228F4(data) {\n    const temps = [];\n    let mosTemp = null;\n    for (let i = 1; i < 6; i++) {\n        if (data[i] !== 0) {\n            const temp = data[i] - 50;\n            temps.push(temp);\n        }\n    }\n    if (temps.length > 0) {\n        mosTemp = temps[0];\n    }\n    return {\n        type: \"individual_temps\",\n        temperatures: temps,\n        mosTemp,\n        sensorCount: temps.length,\n        byte0: data[0]\n    };\n}\n\nfunction decode18F428F4(data) {\n    const systemData = (data[1] << 8) | data[0];\n    const socAlt = data[6];\n    return {\n        type: \"alt_soc_data\",\n        systemData,\n        socAlt,\n        byte2: data[2],\n        rawBytes: data\n    };\n}\n\nfunction decodeCellVoltages(canId, data) {\n    const baseId = parseInt(canId.substring(3, 4));\n    const cellStart = baseId * 4;\n    const voltages = [];\n    for (let i = 0; i < 8; i += 2) {\n        const voltage = ((data[i + 1] << 8) | data[i]) * 0.001;\n        voltages.push({\n            cellNumber: cellStart + (i / 2) + 1,\n            voltage\n        });\n    }\n    return {\n        type: \"cell_voltages\",\n        group: baseId,\n        voltages\n    };\n}\n\nfunction decodeExperimental(canId, data) {\n    const patterns = [];\n    for (let i = 0; i < data.length; i++) {\n        if (data[i] >= 70 && data[i] <= 80) {\n            patterns.push({\n                type: \"possible_mos_temp\",\n                position: i,\n                value: data[i] - 50,\n                rawValue: data[i]\n            });\n        }\n    }\n    for (let i = 0; i < data.length - 1; i++) {\n        const value16 = (data[i + 1] << 8) | data[i];\n        if (value16 >= 10 && value16 <= 50) {\n            patterns.push({\n                type: \"possible_cycle_count\",\n                position: i,\n                value: value16,\n                rawBytes: [data[i], data[i + 1]]\n            });\n        }\n    }\n    return {\n        type: \"experimental\",\n        canId,\n        patterns,\n        rawData: data\n    };\n}\n\n// === LOGIQUE PRINCIPALE ===\nconst parsed = parseCanFrame(msg.payload);\nif (!parsed) {\n    return {\n        payload: {\n            timestamp: new Date().toISOString(),\n            canId: \"\",\n            type: \"parse_error\",\n            note: \"Erreur parsing trame CAN\"\n        }\n    };\n}\n\nconst { canId, data } = parsed;\nlet decoded;\n\nswitch (canId) {\n    case \"2F4\":\n        decoded = decode2F4(data);\n        break;\n    case \"4F4\":\n        decoded = decode4F4(data);\n        break;\n    case \"5F4\":\n        decoded = decode5F4(data);\n        break;\n    case \"7F4\":\n        decoded = decode07F4(data);\n        break;\n    case \"18F128F4\":\n        decoded = decode18F128F4(data);\n        break;\n    case \"01F21400\":\n        decoded = decode01F21400(data);\n        break;\n    case \"18F528F4\":\n        decoded = decode18F528F4(data);\n        break;\n    case \"1806E5F4\":\n        decoded = decode1806E5F4(data);\n        break;\n    case \"18F228F4\":\n        decoded = decode18F228F4(data);\n        break;\n    case \"18F428F4\":\n        decoded = decode18F428F4(data);\n        break;\n    default:\n        if (canId.match(/^18E[0-3]28F4$/)) {\n            decoded = decodeCellVoltages(canId, data);\n        } else {\n            decoded = decodeExperimental(canId, data);\n        }\n        break;\n}\n\nlet bmsId = \"unknown\";\nif (decoded.type === \"cycle_count\") {\n    bmsId = decoded.cycleCount === 35 ? \"BMS2\" : \"BMS1\";\n} else if (decoded.type === \"power_current\" && typeof decoded.cycleCount !== \"undefined\") {\n    bmsId = decoded.cycleCount === 35 ? \"BMS2\" : (decoded.cycleCount === 12 ? \"BMS1\" : \"unknown\");\n} else if (decoded.type === \"individual_temps\" && typeof decoded.mosTemp === \"number\") {\n    bmsId = decoded.mosTemp > 24 ? \"BMS2\" : \"BMS1\";\n}\n\nreturn {\n    payload: {\n        timestamp: new Date().toISOString(),\n        canId,\n        bmsId,\n        rawData: data,\n        rawHex: data.map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' '),\n        ...decoded\n    }\n};\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 740,
        "y": 420,
        "wires": [
            [
                "edddd5764795e5e8",
                "3468acfdfe712e73"
            ]
        ]
    },
    {
        "id": "427020bec4bb2db0",
        "type": "switch",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "",
        "property": "payload.canId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "2F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "4F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "5F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "7F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "01F21400",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "1806E5F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18E028F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18E128F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18E228F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18E328F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18F128F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18F228F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18F328F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18F428F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18F528F4",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 16,
        "x": 120,
        "y": 900,
        "wires": [
            [
                "21eb77fc0deb7df8"
            ],
            [
                "91aacf4dfc2f6b45"
            ],
            [
                "8144d8148f4c0840"
            ],
            [
                "1daa9e6390671ea8"
            ],
            [
                "72b36b4609b42dba"
            ],
            [
                "b84f87970c11f14e"
            ],
            [
                "7d97f7131d3497a0"
            ],
            [
                "32e8d6abd9ac44d0"
            ],
            [
                "740e7dc1d40c5efa"
            ],
            [
                "4be4303ae0f078dc"
            ],
            [
                "2a10c4fd52fdcdbf"
            ],
            [
                "0005b67220843057"
            ],
            [
                "f28c4eb22257478c"
            ],
            [
                "c2369537eb2295bb"
            ],
            [
                "cf375bcb018ce6c2"
            ],
            [
                "db723bbce9cd2eb7"
            ]
        ]
    },
    {
        "id": "cf375bcb018ce6c2",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "18F528F4 - ? compteur ??",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 380,
        "y": 1260,
        "wires": []
    },
    {
        "id": "c2369537eb2295bb",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "18F428F4 - ?",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 340,
        "y": 1220,
        "wires": []
    },
    {
        "id": "f42caadb5356ae1d",
        "type": "file",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "d03facb97e5d14d1",
        "name": "",
        "filename": "/config/temp/CAN-dump.txt",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 720,
        "y": 380,
        "wires": [
            []
        ]
    },
    {
        "id": "2a10c4fd52fdcdbf",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "18F128F4 - ?",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 340,
        "y": 1060,
        "wires": []
    },
    {
        "id": "f28c4eb22257478c",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "18F328F4 - ?",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 340,
        "y": 1180,
        "wires": []
    },
    {
        "id": "b84f87970c11f14e",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "1806E5F4 - status_data",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 370,
        "y": 780,
        "wires": []
    },
    {
        "id": "e7576279e8153b1b",
        "type": "function",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "totalVoltage - soc -current",
        "func": "// Récupération des données depuis le payload\nlet data = msg.payload || {};\nlet prefix = \"CANbus-1\";\nlet discoveryPrefix = \"homeassistant\";\nlet uniq_id_prefix = \"canbus1_\";\nlet deviceID = \"canbus1_device\";\nlet deviceName = \"CANbus-1\";\n\nlet messages = [];\n\n// -- Liste des capteurs à publier, avec config Home Assistant --\nlet sensors = [\n    {\n        key: \"totalVoltage\",\n        name: \"Total voltage\",\n        unit: \"V\",\n        device_class: \"voltage\",\n        value: data.totalVoltage ? Number(data.totalVoltage).toFixed(2) : \"0.00\",\n        icon: \"mdi:car-battery\"\n    },\n    {\n        key: \"soc\",\n        name: \"State of Charge\",\n        unit: \"%\",\n        device_class: \"battery\",\n        value: data.soc || 0,\n        icon: \"mdi:battery-high\"\n    },\n    {\n        key: \"current\",\n        name: \"Current\",\n        unit: \"A\",\n        device_class: \"current\",\n        value: data.current ? Number(data.current).toFixed(1) : \"0.0\",\n        icon: \"mdi:current-dc\"\n    }\n];\n\n// -- Formatage & publication des valeurs sur topics MQTT --\nfor (let s of sensors) {\n    // Envoi de la valeur sur le topic\n    messages.push({\n        topic: `${prefix}/${s.key}`,\n        payload: String(s.value),\n        retain: true\n    });\n\n    // Génération d'un message autodiscovery Home Assistant\n    let discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/${s.key}/config`;\n    let config = {\n        name: `${s.name}`,\n        device_class: s.device_class,\n        state_topic: `${prefix}/${s.key}`,\n        unique_id: uniq_id_prefix + s.key,\n        unit_of_measurement: s.unit,\n        icon: s.icon,\n        expire_after: 600,\n        force_update: true,\n        device: {\n            identifiers: [deviceID],\n            name: deviceName,\n            manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n            model: \"CANbus vers MQTT\",\n            sw_version: \"v1.0\"\n        }\n    };\n    messages.push({\n        topic: discoveryTopic,\n        payload: JSON.stringify(config),\n        retain: true\n    });\n}\n\nreturn [messages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 630,
        "y": 580,
        "wires": [
            [
                "80a3b32d9f0f0730",
                "ecea4cb337311c7f"
            ]
        ]
    },
    {
        "id": "80a3b32d9f0f0730",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "debug 36",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 580,
        "wires": []
    },
    {
        "id": "459611fc12f08799",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "Autre",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 150,
        "y": 1860,
        "wires": []
    },
    {
        "id": "70175f15e3a96645",
        "type": "switch",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "",
        "property": "payload.canId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "2F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "4F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "5F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "7F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "01F21400",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "1806E5F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18E028F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18E128F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18E228F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18E328F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18F128F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18F228F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18F328F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18F428F4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "18F528F4",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 16,
        "x": 120,
        "y": 1640,
        "wires": [
            [
                "a11b6d0e18d66357"
            ],
            [
                "cc58661e52c4af01"
            ],
            [
                "49530b441302aacc"
            ],
            [
                "851759d8657506d7"
            ],
            [
                "a518317b59bd58da"
            ],
            [
                "840d9bc33fc7e3e4"
            ],
            [
                "181f7ced3cb4faf7"
            ],
            [
                "8264c8cacce70110"
            ],
            [
                "95ae122462034c80"
            ],
            [
                "890d83e4ddd29134"
            ],
            [
                "0114fcc43bfd35e2"
            ],
            [
                "0d4939b7cbb31bb3"
            ],
            [
                "5c3517a74be5a7e7"
            ],
            [
                "5832fe6540f56826"
            ],
            [
                "cc70f856bb715e58"
            ],
            [
                "459611fc12f08799"
            ]
        ]
    },
    {
        "id": "851759d8657506d7",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "7F4 - Alarm",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 1500,
        "wires": []
    },
    {
        "id": "a11b6d0e18d66357",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "2F4 - main_status",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 410,
        "y": 1380,
        "wires": []
    },
    {
        "id": "cc70f856bb715e58",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "18F528F4 - ? compteur ??",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 440,
        "y": 2020,
        "wires": []
    },
    {
        "id": "5832fe6540f56826",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "18F428F4 - ?",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 400,
        "y": 1980,
        "wires": []
    },
    {
        "id": "cc58661e52c4af01",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "4F4 - cell_minmax",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 410,
        "y": 1420,
        "wires": []
    },
    {
        "id": "0114fcc43bfd35e2",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "18F128F4 - ?",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 400,
        "y": 1860,
        "wires": []
    },
    {
        "id": "a518317b59bd58da",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "01F21400 - monitoring",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 420,
        "y": 1540,
        "wires": []
    },
    {
        "id": "5c3517a74be5a7e7",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "18F328F4 - ?",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 400,
        "y": 1940,
        "wires": []
    },
    {
        "id": "840d9bc33fc7e3e4",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "1806E5F4 - status_data",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 430,
        "y": 1580,
        "wires": []
    },
    {
        "id": "49530b441302aacc",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "5F4 - temperatures",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 410,
        "y": 1460,
        "wires": []
    },
    {
        "id": "0d4939b7cbb31bb3",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "18F228F4 - individual_temps",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 440,
        "y": 1900,
        "wires": []
    },
    {
        "id": "181f7ced3cb4faf7",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "646f282c0dd63a6e",
        "name": "18E028F4 - cell_voltages 0 à 3",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 450,
        "y": 1660,
        "wires": []
    },
    {
        "id": "8264c8cacce70110",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "646f282c0dd63a6e",
        "name": "18E128F4 - cell_voltages 4 à 7",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 450,
        "y": 1700,
        "wires": []
    },
    {
        "id": "95ae122462034c80",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "646f282c0dd63a6e",
        "name": "18E228F4 - cell_voltages 8 à 11",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 450,
        "y": 1740,
        "wires": []
    },
    {
        "id": "890d83e4ddd29134",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "646f282c0dd63a6e",
        "name": "18F328F4 - cell_voltages 12 à 15",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 460,
        "y": 1780,
        "wires": []
    },
    {
        "id": "156de1e34b3811c8",
        "type": "link in",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "9ca59e5665a543ec",
        "name": "Debug-CAN-in",
        "links": [
            "3468acfdfe712e73"
        ],
        "x": 105,
        "y": 1440,
        "wires": [
            [
                "70175f15e3a96645"
            ]
        ]
    },
    {
        "id": "8603c29f2c2105d4",
        "type": "link in",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "Debug-CAN-in",
        "links": [
            "3468acfdfe712e73"
        ],
        "x": 90.33332824707031,
        "y": 673.1666259765625,
        "wires": [
            [
                "427020bec4bb2db0"
            ]
        ]
    },
    {
        "id": "3468acfdfe712e73",
        "type": "link out",
        "z": "2e99fd421b434bcb",
        "g": "d03facb97e5d14d1",
        "name": "Debug-CAN-out",
        "mode": "link",
        "links": [
            "156de1e34b3811c8",
            "8603c29f2c2105d4"
        ],
        "x": 945,
        "y": 420,
        "wires": []
    },
    {
        "id": "7821b4f3d5cbe3df",
        "type": "function",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "4F4 - cell_minmax",
        "func": "// Récupération du payload\nlet data = msg.payload || {};\nlet prefix = \"CANbus-1\";\nlet discoveryPrefix = \"homeassistant\";\nlet uniq_id_prefix = \"canbus1_\";\nlet deviceID = \"canbus1_device\";\nlet deviceName = \"CANbus-1\";\n\nlet messages = [];\n\n// Définition des capteurs & paramètres à publier\nlet sensors = [\n    {\n        key: \"deltaCellVoltage\",\n        name: \"Delta Cell Votage\",\n        unit: \"V\",\n        device_class: \"voltage\",\n        value: data.deltaCellVoltage !== undefined ? data.deltaCellVoltage : 0,\n        icon: \"mdi:battery-minus-variant\"\n    },\n    {\n        key: \"maxCellVoltage\",\n        name: \"Cell max voltage\",\n        unit: \"V\",\n        device_class: \"voltage\",\n        value: data.maxCellVoltage !== undefined ? Number(data.maxCellVoltage).toFixed(2) : \"0.00\",\n        icon: \"mdi:battery-high\"\n    },\n    {\n        key: \"maxCellPosition\",\n        name: \"Cell max position\",\n        unit: \"\",\n        device_class: \"none\",\n        value: data.maxCellPosition !== undefined ? data.maxCellPosition : 0,\n        icon: \"mdi:numeric\"\n    },\n    {\n        key: \"minCellVoltage\",\n        name: \"Cell min votage\",\n        unit: \"V\",\n        device_class: \"voltage\",\n        value: data.minCellVoltage !== undefined ? data.minCellVoltage : 0,\n        icon: \"mdi:battery-low\"\n    },\n    {\n        key: \"minCellPosition\",\n        name: \"Cell min position\",\n        unit: \"\",\n        device_class: \"none\",\n        value: data.minCellPosition !== undefined ? data.minCellPosition : 0,\n        icon: \"mdi:numeric\"\n    }\n];\n\n// Loop de publication/value/discovery\nfor (let s of sensors) {\n    messages.push({\n        topic: `${prefix}/${s.key}`,\n        payload: String(s.value),\n        retain: true\n    });\n\n    let discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/${s.key}/config`;\n    let config = {\n        name: s.name,\n        state_topic: `${prefix}/${s.key}`,\n        unique_id: uniq_id_prefix + s.key,\n        icon: s.icon,\n        expire_after: 600,\n        force_update: true,\n        device: {\n            identifiers: [deviceID],\n            name: deviceName,\n            manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n            model: \"CANbus vers MQTT\",\n            sw_version: \"v1.0\"\n        }\n    };\n\n    // Ajoute unit_of_measurement et device_class seulement si pertinent\n    if (s.unit) config.unit_of_measurement = s.unit;\n    if (s.device_class && s.device_class !== \"none\") config.device_class = s.device_class;\n\n    messages.push({\n        topic: discoveryTopic,\n        payload: JSON.stringify(config),\n        retain: true\n    });\n}\n\nreturn [messages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 620,
        "wires": [
            [
                "ecea4cb337311c7f",
                "0a5f6e32247b194d"
            ]
        ]
    },
    {
        "id": "0a5f6e32247b194d",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "debug 33",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 620,
        "wires": []
    },
    {
        "id": "75044b278b31a047",
        "type": "function",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "5F4 - temperatures",
        "func": "// Récupération du payload\nlet data = msg.payload || {};\nlet prefix = \"CANbus-1\";\nlet discoveryPrefix = \"homeassistant\";\nlet uniq_id_prefix = \"canbus1_\";\nlet deviceID = \"canbus1_device\";\nlet deviceName = \"CANbus-1\";\n\nlet messages = [];\n\n// Définition des capteurs & paramètres à publier (avec nouveaux noms)\nlet sensors = [\n    {\n        key: \"maxTemp\",\n        name: \"Temp. Maxi\",\n        unit: \"°C\",\n        device_class: \"temperature\",\n        value: data.maxTemp !== undefined ? data.maxTemp : 0,\n        icon: \"mdi:thermometer-high\"\n    },\n    {\n        key: \"maxTempPosition\",\n        name: \"Temp. position Maxi\",\n        unit: \"\",\n        device_class: \"none\",\n        value: data.maxTempPosition !== undefined ? data.maxTempPosition : 0,\n        icon: \"mdi:numeric\"\n    },\n    {\n        key: \"minTemp\",\n        name: \"Temp. Mini\",\n        unit: \"°C\",\n        device_class: \"temperature\",\n        value: data.minTemp !== undefined ? data.minTemp : 0,\n        icon: \"mdi:thermometer-low\"\n    },\n    {\n        key: \"minTempPosition\",\n        name: \"Temp. position Mini\",\n        unit: \"\",\n        device_class: \"none\",\n        value: data.minTempPosition !== undefined ? data.minTempPosition : 0,\n        icon: \"mdi:numeric\"\n    },\n    {\n        key: \"avgTemp\",\n        name: \"Temp. Avg\",\n        unit: \"°C\",\n        device_class: \"temperature\",\n        value: data.avgTemp !== undefined ? data.avgTemp : 0,\n        icon: \"mdi:thermometer\"\n    }\n];\n\n// Publication des valeurs & autodiscovery Home Assistant\nfor (let s of sensors) {\n    messages.push({\n        topic: `${prefix}/${s.key}`,\n        payload: String(s.value),\n        retain: true\n    });\n\n    let discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/${s.key}/config`;\n    let config = {\n        name: s.name,\n        state_topic: `${prefix}/${s.key}`,\n        unique_id: uniq_id_prefix + s.key,\n        icon: s.icon,\n        expire_after: 600,\n        force_update: true,\n        device: {\n            identifiers: [deviceID],\n            name: deviceName,\n            manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n            model: \"CANbus vers MQTT\",\n            sw_version: \"v1.0\"\n        }\n    };\n    if (s.unit) config.unit_of_measurement = s.unit;\n    if (s.device_class && s.device_class !== \"none\") config.device_class = s.device_class;\n\n    messages.push({\n        topic: discoveryTopic,\n        payload: JSON.stringify(config),\n        retain: true\n    });\n}\n\nreturn [messages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 660,
        "wires": [
            [
                "ecea4cb337311c7f",
                "89d6590a094825e7"
            ]
        ]
    },
    {
        "id": "89d6590a094825e7",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "debug 14",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 660,
        "wires": []
    },
    {
        "id": "788e057cc57fcb4c",
        "type": "function",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "01F21400 - monitoring",
        "func": "// Récupération du payload\nlet data = msg.payload || {};\nlet prefix = \"CANbus-1\";\nlet discoveryPrefix = \"homeassistant\";\nlet uniq_id_prefix = \"canbus1_\";\nlet deviceID = \"canbus1_device\";\nlet deviceName = \"CANbus-1\";\n\nlet messages = [];\n\n// ----------- Publication cycleCount uniquement ----------\nlet s = {\n    key: \"cycleCount\",\n    name: \"Cycles number\",\n    unit: \"\",\n    device_class: \"none\",\n    value: data.cycleCount !== undefined ? data.cycleCount : 0,\n    icon: \"mdi:counter\"\n};\n\n// Publication valeur brute\nmessages.push({\n    topic: `${prefix}/${s.key}`,\n    payload: String(s.value),\n    retain: true\n});\n\n// Publication auto-discovery Home Assistant\nlet discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/${s.key}/config`;\nlet config = {\n    name: s.name,\n    state_topic: `${prefix}/${s.key}`,\n    unique_id: uniq_id_prefix + s.key,\n    icon: s.icon,\n    expire_after: 600,\n    force_update: true,\n    device: {\n        identifiers: [deviceID],\n        name: deviceName,\n        manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n        model: \"CANbus vers MQTT\",\n        sw_version: \"v1.0\"\n    }\n};\nmessages.push({\n    topic: discoveryTopic,\n    payload: JSON.stringify(config),\n    retain: true\n});\n\nreturn [messages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 620,
        "y": 740,
        "wires": [
            [
                "ecea4cb337311c7f",
                "ed8a4b44d9f1a840"
            ]
        ]
    },
    {
        "id": "ed8a4b44d9f1a840",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "debug 35",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 740,
        "wires": []
    },
    {
        "id": "c955aacbd7372820",
        "type": "function",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "7F4 - Alarm",
        "func": "// Récupération du payload\nlet data = msg.payload || {};\nlet prefix = \"CANbus-1\";\nlet discoveryPrefix = \"homeassistant\";\nlet uniq_id_prefix = \"canbus1_\";\nlet deviceID = \"canbus1_device\";\nlet deviceName = \"CANbus-1\";\n\nlet messages = [];\n\n// Extraction du nom de la première alarme (s'il existe)\nlet alarmName = \"\";\nif (Array.isArray(data.alarms) && data.alarms.length > 0 && data.alarms[0].name) {\n    alarmName = data.alarms[0].name;\n}\n\n// Définition du capteur\nlet s = {\n    key: \"alarmName\",\n    name: \"Alarme descr.\",\n    value: alarmName,\n    icon: \"mdi:alert-circle\"\n};\n\n// Publication de la valeur sur le topic MQTT\nmessages.push({\n    topic: `${prefix}/${s.key}`,\n    payload: s.value,\n    retain: true\n});\n\n// Configuration autodiscovery Home Assistant - sensor texte (pas d'unité)\nlet discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/${s.key}/config`;\nlet config = {\n    name: s.name,\n    state_topic: `${prefix}/${s.key}`,\n    unique_id: uniq_id_prefix + s.key,\n    icon: s.icon,\n    expire_after: 600,\n    device: {\n        identifiers: [deviceID],\n        name: deviceName,\n        manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n        model: \"CANbus vers MQTT\",\n        sw_version: \"v1.0\"\n    }\n};\nmessages.push({\n    topic: discoveryTopic,\n    payload: JSON.stringify(config),\n    retain: true\n});\n\nreturn [messages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 700,
        "wires": [
            [
                "ecea4cb337311c7f",
                "33664bc1723b2cde"
            ]
        ]
    },
    {
        "id": "33664bc1723b2cde",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "debug 38",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 700,
        "wires": []
    },
    {
        "id": "59a32da84f1d558f",
        "type": "function",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "18E028F4 - cell_voltages 0 à 3",
        "func": "// Récupération du payload\nlet data = msg.payload || {};\nlet prefix = \"CANbus-1/cellVoltage_\";  // <-- maintenant underscore\nlet discoveryPrefix = \"homeassistant\";\nlet uniq_id_prefix = \"canbus1_cell_\";\nlet deviceID = \"canbus1_device\";\nlet deviceName = \"CANbus-1\";\n\nlet messages = [];\n\nif (Array.isArray(data.voltages)) {\n    for (let cell of data.voltages) {\n        let cellNumber = cell.cellNumber || 0;\n        let voltage = cell.voltage !== undefined ? Number(cell.voltage).toFixed(3) : \"0.000\";\n        let key = `${cellNumber}`;\n\n        // 1) Publication de la tension de cette cellule sur son topic dédié\n        messages.push({\n            topic: `${prefix}${key}`,\n            payload: voltage,\n            retain: true\n        });\n\n        // 2) Autodiscovery HA pour cette cellule\n        let discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/cell_voltage_${key}/config`;\n        let config = {\n            name: `Cell ${cellNumber}`,\n            state_topic: `${prefix}${key}`,\n            unique_id: uniq_id_prefix + key,\n            device_class: \"voltage\",\n            unit_of_measurement: \"V\",\n            icon: \"mdi:battery\",\n            expire_after: 600,\n            force_update: true,\n            device: {\n                identifiers: [deviceID],\n                name: deviceName,\n                manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n                model: \"CANbus vers MQTT\",\n                sw_version: \"v1.0\"\n            }\n        };\n        messages.push({\n            topic: discoveryTopic,\n            payload: JSON.stringify(config),\n            retain: true\n        });\n    }\n}\n\nreturn [messages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 860,
        "wires": [
            [
                "1b8d8f8af7b7474f",
                "6012cd81c0bcf535"
            ]
        ]
    },
    {
        "id": "6012cd81c0bcf535",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "debug 39",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 960,
        "y": 860,
        "wires": []
    },
    {
        "id": "7052b31a5e638f20",
        "type": "function",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "18E128F4 - cell_voltages 4 à 7",
        "func": "// Récupération du payload\nlet data = msg.payload || {};\nlet prefix = \"CANbus-1/cellVoltage_\"; // underscore\nlet discoveryPrefix = \"homeassistant\";\nlet uniq_id_prefix = \"canbus1_cell_\";\nlet deviceID = \"canbus1_device\";\nlet deviceName = \"CANbus-1\";\n\nlet messages = [];\n\nif (Array.isArray(data.voltages)) {\n    for (let cell of data.voltages) {\n        let cellNumber = cell.cellNumber || 0;\n        let voltage = cell.voltage !== undefined ? Number(cell.voltage).toFixed(3) : \"0.000\";\n        let key = `${cellNumber}`;\n\n        // 1) Publication de la tension de cette cellule sur son topic dédié\n        messages.push({\n            topic: `${prefix}${key}`,\n            payload: voltage,\n            retain: true\n        });\n\n        // 2) Autodiscovery HA pour cette cellule\n        let discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/cell_voltage_${key}/config`;\n        let config = {\n            name: `Cell ${cellNumber}`,\n            state_topic: `${prefix}${key}`,\n            unique_id: uniq_id_prefix + key,\n            device_class: \"voltage\",\n            unit_of_measurement: \"V\",\n            icon: \"mdi:battery\",\n            expire_after: 600,\n            force_update: true,\n            device: {\n                identifiers: [deviceID],\n                name: deviceName,\n                manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n                model: \"CANbus vers MQTT\",\n                sw_version: \"v1.0\"\n            }\n        };\n        messages.push({\n            topic: discoveryTopic,\n            payload: JSON.stringify(config),\n            retain: true\n        });\n    }\n}\n\nreturn [messages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 900,
        "wires": [
            [
                "1b8d8f8af7b7474f",
                "13609daae25e3257"
            ]
        ]
    },
    {
        "id": "13609daae25e3257",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "debug 40",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 960,
        "y": 900,
        "wires": []
    },
    {
        "id": "52d83545146677d4",
        "type": "function",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "18E228F4 - cell_voltages 8 à 11",
        "func": "// Récupération du payload\nlet data = msg.payload || {};\nlet prefix = \"CANbus-1/cellVoltage_\"; // underscore\nlet discoveryPrefix = \"homeassistant\";\nlet uniq_id_prefix = \"canbus1_cell_\";\nlet deviceID = \"canbus1_device\";\nlet deviceName = \"CANbus-1\";\n\nlet messages = [];\n\nif (Array.isArray(data.voltages)) {\n    for (let cell of data.voltages) {\n        let cellNumber = cell.cellNumber || 0;\n        let voltage = cell.voltage !== undefined ? Number(cell.voltage).toFixed(3) : \"0.000\";\n        let key = `${cellNumber}`;\n\n        // 1) Publication de la tension de cette cellule sur son topic dédié\n        messages.push({\n            topic: `${prefix}${key}`,\n            payload: voltage,\n            retain: true\n        });\n\n        // 2) Autodiscovery HA pour cette cellule\n        let discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/cell_voltage_${key}/config`;\n        let config = {\n            name: `Cell ${cellNumber}`,\n            state_topic: `${prefix}${key}`,\n            unique_id: uniq_id_prefix + key,\n            device_class: \"voltage\",\n            unit_of_measurement: \"V\",\n            icon: \"mdi:battery\",\n            expire_after: 600,\n            force_update: true,\n            device: {\n                identifiers: [deviceID],\n                name: deviceName,\n                manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n                model: \"CANbus vers MQTT\",\n                sw_version: \"v1.0\"\n            }\n        };\n        messages.push({\n            topic: discoveryTopic,\n            payload: JSON.stringify(config),\n            retain: true\n        });\n    }\n}\n\nreturn [messages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 940,
        "wires": [
            [
                "1b8d8f8af7b7474f",
                "5902f421447b046d"
            ]
        ]
    },
    {
        "id": "5902f421447b046d",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "debug 41",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 960,
        "y": 940,
        "wires": []
    },
    {
        "id": "e78e87fb719b450d",
        "type": "function",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "18F328F4 - cell_voltages 12 à 15",
        "func": "// Récupération du payload\nlet data = msg.payload || {};\nlet prefix = \"CANbus-1/cellVoltage_\"; // underscore\nlet discoveryPrefix = \"homeassistant\";\nlet uniq_id_prefix = \"canbus1_cell_\";\nlet deviceID = \"canbus1_device\";\nlet deviceName = \"CANbus-1\";\n\nlet messages = [];\n\nif (Array.isArray(data.voltages)) {\n    for (let cell of data.voltages) {\n        let cellNumber = cell.cellNumber || 0;\n        let voltage = cell.voltage !== undefined ? Number(cell.voltage).toFixed(3) : \"0.000\";\n        let key = `${cellNumber}`;\n\n        // 1) Publication de la tension sur le topic dédié\n        messages.push({\n            topic: `${prefix}${key}`,\n            payload: voltage,\n            retain: true\n        });\n\n        // 2) Autodiscovery Home Assistant pour cette cellule\n        let discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/cell_voltage_${key}/config`;\n        let config = {\n            name: `Cell ${cellNumber}`,\n            state_topic: `${prefix}${key}`,\n            unique_id: uniq_id_prefix + key,\n            device_class: \"voltage\",\n            unit_of_measurement: \"V\",\n            icon: \"mdi:battery\",\n            expire_after: 600,\n            force_update: true,\n            device: {\n                identifiers: [deviceID],\n                name: deviceName,\n                manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n                model: \"CANbus vers MQTT\",\n                sw_version: \"v1.0\"\n            }\n        };\n        messages.push({\n            topic: discoveryTopic,\n            payload: JSON.stringify(config),\n            retain: true\n        });\n    }\n}\n\nreturn [messages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 660,
        "y": 980,
        "wires": [
            [
                "1b8d8f8af7b7474f",
                "c50f23a0e0297de8"
            ]
        ]
    },
    {
        "id": "c50f23a0e0297de8",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "debug 42",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 960,
        "y": 980,
        "wires": []
    },
    {
        "id": "8c4ae23f7fadd63d",
        "type": "function",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "18F228F4 - individual_temps",
        "func": "let data = msg.payload || {};\nlet prefix = \"CANbus-1\";\nlet discoveryPrefix = \"homeassistant\";\nlet uniq_id_prefix = \"canbus1_\";\nlet deviceID = \"canbus1_device\";\nlet deviceName = \"CANbus-1\";\n\nlet messages = [];\n\n// 1) Températures individuelles\nif (Array.isArray(data.temperatures)) {\n    for (let i = 0; i < data.temperatures.length; i++) {\n        let temp = data.temperatures[i];\n        let key = `temperature_${i+1}`;\n\n        messages.push({\n            topic: `${prefix}/${key}`,\n            payload: temp !== undefined ? String(temp) : \"\",\n            retain: true\n        });\n\n        let discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/${key}/config`;\n        let config = {\n            name: `Temp. Sonde ${i+1}`,\n            state_topic: `${prefix}/${key}`,\n            unique_id: uniq_id_prefix + key,\n            device_class: \"temperature\",\n            unit_of_measurement: \"°C\",\n            icon: \"mdi:thermometer\",\n            expire_after: 600,\n            force_update: true,\n            device: {\n                identifiers: [deviceID],\n                name: deviceName,\n                manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n                model: \"CANbus vers MQTT\",\n                sw_version: \"v1.0\"\n            }\n        };\n        messages.push({\n            topic: discoveryTopic,\n            payload: JSON.stringify(config),\n            retain: true\n        });\n    }\n}\n\n// 2) Température MOSFET\nif (data.mosTemp !== undefined) {\n    messages.push({\n        topic: `${prefix}/mosTemp`,\n        payload: String(data.mosTemp),\n        retain: true\n    });\n    let discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/mosTemp/config`;\n    let config = {\n        name: `Temp. MOSFET`,\n        state_topic: `${prefix}/mosTemp`,\n        unique_id: uniq_id_prefix + \"mosTemp\",\n        device_class: \"temperature\",\n        unit_of_measurement: \"°C\",\n        icon: \"mdi:thermometer-lines\",\n        expire_after: 600,\n        force_update: true,\n        device: {\n            identifiers: [deviceID],\n            name: deviceName,\n            manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n            model: \"CANbus vers MQTT\",\n            sw_version: \"v1.0\"\n        }\n    };\n    messages.push({\n        topic: discoveryTopic,\n        payload: JSON.stringify(config),\n        retain: true\n    });\n}\n\n// 3) Nombre de sondes\nif (data.sensorCount !== undefined) {\n    messages.push({\n        topic: `${prefix}/TempSensorCount`,\n        payload: String(data.sensorCount),\n        retain: true\n    });\n    let discoveryTopic = `${discoveryPrefix}/sensor/${deviceID}/TempSensorCount/config`;\n    let config = {\n        name: `Nb. of probes temp.`,\n        state_topic: `${prefix}/TempSensorCount`,\n        unique_id: uniq_id_prefix + \"TempSensorCount\",\n        icon: \"mdi:counter\",\n        expire_after: 600,\n        force_update: true,\n        device: {\n            identifiers: [deviceID],\n            name: deviceName,\n            manufacturer: \"Smartphoton-JK-BMS / ©JLM 2025\",\n            model: \"CANbus vers MQTT\",\n            sw_version: \"v1.0\"\n        }\n    };\n    messages.push({\n        topic: discoveryTopic,\n        payload: JSON.stringify(config),\n        retain: true\n    });\n}\n\nreturn [messages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 640,
        "y": 1120,
        "wires": [
            [
                "5db3845569e2eacb",
                "cf27fc9e687cec75"
            ]
        ]
    },
    {
        "id": "cf27fc9e687cec75",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "debug 43",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 960,
        "y": 1120,
        "wires": []
    },
    {
        "id": "ecea4cb337311c7f",
        "type": "link out",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "CAN-to-MQTT-out",
        "mode": "link",
        "links": [
            "7cdddbdff16d1585"
        ],
        "x": 835,
        "y": 680,
        "wires": []
    },
    {
        "id": "7cdddbdff16d1585",
        "type": "link in",
        "z": "2e99fd421b434bcb",
        "g": "b188deca5d12b002",
        "name": "CAN-to-MQTT-in",
        "links": [
            "ecea4cb337311c7f",
            "1b8d8f8af7b7474f",
            "5db3845569e2eacb"
        ],
        "x": 745,
        "y": 1240,
        "wires": [
            [
                "f491a2b292a65e24"
            ]
        ]
    },
    {
        "id": "f491a2b292a65e24",
        "type": "mqtt out",
        "z": "2e99fd421b434bcb",
        "g": "b188deca5d12b002",
        "name": "Onduleur",
        "topic": "",
        "qos": "0",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 840,
        "y": 1240,
        "wires": []
    },
    {
        "id": "1b8d8f8af7b7474f",
        "type": "link out",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "CAN-to-MQTT-out",
        "mode": "link",
        "links": [
            "7cdddbdff16d1585"
        ],
        "x": 855,
        "y": 920,
        "wires": []
    },
    {
        "id": "5db3845569e2eacb",
        "type": "link out",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "CAN-to-MQTT-out",
        "mode": "link",
        "links": [
            "7cdddbdff16d1585"
        ],
        "x": 815,
        "y": 1140,
        "wires": []
    },
    {
        "id": "21eb77fc0deb7df8",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "",
        "pauseType": "rate",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "3",
        "nbRateUnits": "15",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 340,
        "y": 580,
        "wires": [
            [
                "e7576279e8153b1b"
            ]
        ]
    },
    {
        "id": "91aacf4dfc2f6b45",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "",
        "pauseType": "rate",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "4",
        "nbRateUnits": "20",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 340,
        "y": 620,
        "wires": [
            [
                "7821b4f3d5cbe3df"
            ]
        ]
    },
    {
        "id": "8144d8148f4c0840",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "",
        "pauseType": "rate",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "4",
        "nbRateUnits": "20",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 340,
        "y": 660,
        "wires": [
            [
                "75044b278b31a047"
            ]
        ]
    },
    {
        "id": "1daa9e6390671ea8",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "",
        "pauseType": "rate",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "4",
        "nbRateUnits": "20",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 340,
        "y": 700,
        "wires": [
            [
                "c955aacbd7372820"
            ]
        ]
    },
    {
        "id": "72b36b4609b42dba",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "",
        "pauseType": "rate",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "4",
        "nbRateUnits": "20",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 340,
        "y": 740,
        "wires": [
            [
                "788e057cc57fcb4c"
            ]
        ]
    },
    {
        "id": "7d97f7131d3497a0",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "",
        "pauseType": "rate",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "4",
        "nbRateUnits": "20",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 340,
        "y": 860,
        "wires": [
            [
                "59a32da84f1d558f"
            ]
        ]
    },
    {
        "id": "32e8d6abd9ac44d0",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "",
        "pauseType": "rate",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "4",
        "nbRateUnits": "20",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 340,
        "y": 900,
        "wires": [
            [
                "7052b31a5e638f20"
            ]
        ]
    },
    {
        "id": "740e7dc1d40c5efa",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "",
        "pauseType": "rate",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "4",
        "nbRateUnits": "20",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 340,
        "y": 940,
        "wires": [
            [
                "52d83545146677d4"
            ]
        ]
    },
    {
        "id": "4be4303ae0f078dc",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "9de87061f754ddf9",
        "name": "",
        "pauseType": "rate",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "4",
        "nbRateUnits": "20",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 340,
        "y": 980,
        "wires": [
            [
                "e78e87fb719b450d"
            ]
        ]
    },
    {
        "id": "0005b67220843057",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "2584ccec0ec42693",
        "name": "",
        "pauseType": "rate",
        "timeout": "2",
        "timeoutUnits": "seconds",
        "rate": "4",
        "nbRateUnits": "20",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 340,
        "y": 1120,
        "wires": [
            [
                "8c4ae23f7fadd63d"
            ]
        ]
    },
    {
        "id": "5cfaee00ed1d945e",
        "type": "switch",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "name": "CAN_bus_usage ?",
        "property": "CAN_bus_usage",
        "propertyType": "global",
        "rules": [
            {
                "t": "false"
            },
            {
                "t": "true"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 330,
        "y": 60,
        "wires": [
            [],
            [
                "81797f8435ea4090",
                "918a82299c32dcf9"
            ]
        ]
    },
    {
        "id": "93acca2bdf879a01",
        "type": "inject",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 60,
        "wires": [
            [
                "5cfaee00ed1d945e"
            ]
        ]
    },
    {
        "id": "81797f8435ea4090",
        "type": "exec",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "command": "ip link set can0 down",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 220,
        "y": 120,
        "wires": [
            [
                "b5fefa24fa332bb0",
                "b3cc6af46b5e8003"
            ],
            [],
            []
        ]
    },
    {
        "id": "33e185e362f95f82",
        "type": "exec",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "command": "ip link set can0 up type can bitrate 500000",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 280,
        "y": 180,
        "wires": [
            [
                "a1212ebb1907b570",
                "89480d3fdae61266"
            ],
            [],
            []
        ]
    },
    {
        "id": "d09a3cc293255be2",
        "type": "exec",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "command": "ip link set can0 up",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 210,
        "y": 240,
        "wires": [
            [
                "4c7382e365ab7a48",
                "606759ae352bbf73"
            ],
            [],
            []
        ]
    },
    {
        "id": "4c7382e365ab7a48",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "name": "",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 540,
        "y": 240,
        "wires": [
            [
                "c3de74fe6e67e34d"
            ]
        ]
    },
    {
        "id": "0ef8fc221e14acf6",
        "type": "exec",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "command": "ip link set can0 down",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 1040,
        "y": 1700,
        "wires": [
            [
                "ab0eed874c8d277a"
            ],
            [],
            [
                "505be46f8eda2768"
            ]
        ]
    },
    {
        "id": "bfc557c471275022",
        "type": "inject",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 850,
        "y": 1700,
        "wires": [
            [
                "0ef8fc221e14acf6"
            ]
        ]
    },
    {
        "id": "ab0eed874c8d277a",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "name": "debug 29",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1220,
        "y": 1680,
        "wires": []
    },
    {
        "id": "505be46f8eda2768",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "name": "debug 31",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1220,
        "y": 1720,
        "wires": []
    },
    {
        "id": "f73071ac18154111",
        "type": "exec",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "command": "ip link set can0 up",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 1030,
        "y": 1620,
        "wires": [
            [
                "876fccdff470c9e9"
            ],
            [],
            [
                "7dc27bfd806f5368"
            ]
        ]
    },
    {
        "id": "f5dfca4e639fa942",
        "type": "inject",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 850,
        "y": 1620,
        "wires": [
            [
                "f73071ac18154111"
            ]
        ]
    },
    {
        "id": "876fccdff470c9e9",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "name": "debug 32",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1220,
        "y": 1600,
        "wires": []
    },
    {
        "id": "7dc27bfd806f5368",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "name": "debug 34",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1220,
        "y": 1640,
        "wires": []
    },
    {
        "id": "c3b71c2f1a714c85",
        "type": "exec",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "command": "ip link set can0 up type can bitrate 500000",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 1120,
        "y": 1500,
        "wires": [
            [
                "4b1f866ae32190f9"
            ],
            [],
            [
                "ac59461acfb2cc71"
            ]
        ]
    },
    {
        "id": "64ae959294b9f406",
        "type": "inject",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 850,
        "y": 1500,
        "wires": [
            [
                "c3b71c2f1a714c85"
            ]
        ]
    },
    {
        "id": "4b1f866ae32190f9",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "name": "debug 2",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1380,
        "y": 1480,
        "wires": []
    },
    {
        "id": "ac59461acfb2cc71",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "d": true,
        "g": "1d5b0e71e0a2eba5",
        "name": "debug 28",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1380,
        "y": 1520,
        "wires": []
    },
    {
        "id": "0d119ba5972c169a",
        "type": "exec",
        "z": "2e99fd421b434bcb",
        "g": "ccc1258cc5051fb2",
        "command": "ip link show can0",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 1050,
        "y": 1880,
        "wires": [
            [
                "e568cd8b91c96fff"
            ],
            [],
            [
                "19e2a3758a49f532"
            ]
        ]
    },
    {
        "id": "91b2a628817de544",
        "type": "inject",
        "z": "2e99fd421b434bcb",
        "g": "ccc1258cc5051fb2",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 850,
        "y": 1880,
        "wires": [
            [
                "0d119ba5972c169a"
            ]
        ]
    },
    {
        "id": "e568cd8b91c96fff",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "ccc1258cc5051fb2",
        "name": "debug 19",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1210,
        "y": 1860,
        "wires": []
    },
    {
        "id": "19e2a3758a49f532",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "ccc1258cc5051fb2",
        "name": "debug 27",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1210,
        "y": 1900,
        "wires": []
    },
    {
        "id": "b3cc6af46b5e8003",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "name": "CAN Down",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 750,
        "y": 120,
        "wires": []
    },
    {
        "id": "69e938ba030b7546",
        "type": "change",
        "z": "2e99fd421b434bcb",
        "g": "fcb249897b0ead9e",
        "name": "CAN_bus_usage ? False",
        "rules": [
            {
                "t": "set",
                "p": "CAN_bus_usage",
                "pt": "global",
                "to": "false",
                "tot": "bool"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1250,
        "y": 140,
        "wires": [
            []
        ]
    },
    {
        "id": "795828b453f64b9b",
        "type": "inject",
        "z": "2e99fd421b434bcb",
        "g": "fcb249897b0ead9e",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 1030,
        "y": 100,
        "wires": [
            [
                "748d73da83bca2cf"
            ]
        ]
    },
    {
        "id": "748d73da83bca2cf",
        "type": "change",
        "z": "2e99fd421b434bcb",
        "g": "fcb249897b0ead9e",
        "name": "CAN_bus_usage ? True",
        "rules": [
            {
                "t": "set",
                "p": "CAN_bus_usage",
                "pt": "global",
                "to": "true",
                "tot": "bool"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1250,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "b30c7fb6356f631e",
        "type": "inject",
        "z": "2e99fd421b434bcb",
        "g": "fcb249897b0ead9e",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 1030,
        "y": 140,
        "wires": [
            [
                "69e938ba030b7546"
            ]
        ]
    },
    {
        "id": "b5fefa24fa332bb0",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "name": "",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 540,
        "y": 120,
        "wires": [
            [
                "33e185e362f95f82"
            ]
        ]
    },
    {
        "id": "a1212ebb1907b570",
        "type": "delay",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "name": "",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 540,
        "y": 180,
        "wires": [
            [
                "d09a3cc293255be2"
            ]
        ]
    },
    {
        "id": "89480d3fdae61266",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "name": "bds",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 730,
        "y": 180,
        "wires": []
    },
    {
        "id": "606759ae352bbf73",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "name": "CAN Up",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 740,
        "y": 240,
        "wires": []
    },
    {
        "id": "918a82299c32dcf9",
        "type": "debug",
        "z": "2e99fd421b434bcb",
        "g": "c002b2b718abc28f",
        "name": "Using CANbus",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 760,
        "y": 60,
        "wires": []
    }
]