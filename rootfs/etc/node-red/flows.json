[
    {
        "id": "a1b94e47fdb804f8",
        "type": "tab",
        "label": "Warning - Avertissement",
        "disabled": false,
        "info": ""
    },
    {
        "id": "2d882136a35b2d36",
        "type": "tab",
        "label": "Initialisations",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "e437f2f44495aeb9",
        "type": "tab",
        "label": "Lecture JK-BMS",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "63221fce04fce9a1",
        "type": "tab",
        "label": "Setup",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "dfa2ea8601dc4518",
        "type": "tab",
        "label": "Dashboard",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "c42476a3aa2dd79c",
        "type": "tab",
        "label": "Divers",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "6fc9763d4087338c",
        "type": "subflow",
        "name": "Subflow 1",
        "info": "",
        "category": "",
        "in": [],
        "out": [],
        "env": [],
        "meta": {},
        "color": "#DDAA99"
    },
    {
        "id": "6b5bd0bba4a26d99",
        "type": "group",
        "z": "e437f2f44495aeb9",
        "name": "Phase initialisation & lecture automatique (1 seule demande modbus)",
        "style": {
            "stroke": "#000000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "prepare_command",
            "48962018a6c0050f",
            "cb31b781d9bcb31e",
            "020c19662d54639e",
            "42b39467dd4b0da2",
            "33128f050c7a6d40",
            "bdc67ff77d388fd4",
            "612e601399a564be",
            "47c0ebe01c623676",
            "c15a66e8901ebb92",
            "57c7fc5e6af725a8",
            "588a28b52bca3c97",
            "6aaaa309d4c3a50c",
            "307f2a35426531d7",
            "45e89eb282d2510b",
            "cc5072db2fb56b16",
            "a6457f1b4018e210",
            "d3854248aace5164",
            "366518e9212a6b71",
            "771632eaf7af77e3"
        ],
        "x": 14,
        "y": 199,
        "w": 982,
        "h": 382
    },
    {
        "id": "efcb27eee8e0e602",
        "type": "group",
        "z": "e437f2f44495aeb9",
        "name": "Port Série Out",
        "style": {
            "stroke": "#ff0000",
            "label": true,
            "color": "#000000",
            "fill": "#ffbfbf"
        },
        "nodes": [
            "305e1cac13589b0d",
            "8d8489f730e79441",
            "cfbb3e70d43124da",
            "d9ef164688871372",
            "9c7f34f8f23e6ba9"
        ],
        "x": 104,
        "y": 39,
        "w": 472,
        "h": 122
    },
    {
        "id": "554f91ffdbfbfc68",
        "type": "group",
        "z": "e437f2f44495aeb9",
        "name": "Décodage des trames 1 - 2 - 3",
        "style": {
            "stroke": "#ffC000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "87cae6741d4eba43",
            "ef22a3d568844d0a",
            "6a62d2d49420f2ef",
            "31a51f2f45d84be6",
            "5f01f1a8c86201ad",
            "58ef70ea1beab86a",
            "8d42d70f697c6b57",
            "6ec0cd904988f0ff",
            "f8bc911f73526834",
            "c5358579966ea944",
            "bb5385e5fa6e8f58",
            "8941479643260a23",
            "dc8be2eb9f379046",
            "722fcc3b75fdf46e"
        ],
        "x": 18,
        "y": 739,
        "w": 903,
        "h": 908
    },
    {
        "id": "c5544de409dc3632",
        "type": "group",
        "z": "c42476a3aa2dd79c",
        "name": "Essais divers",
        "style": {
            "label": true
        },
        "nodes": [
            "5b14b666e62da67d",
            "63b5b654057c4381",
            "2d239cf871fcdd0f",
            "754c40640a559f32",
            "39449a18b64acb51",
            "8bc9c72eb8f36ff2",
            "d3d5c2188bb8b56e"
        ],
        "x": 34,
        "y": 39,
        "w": 928,
        "h": 488
    },
    {
        "id": "49a4091113d20136",
        "type": "group",
        "z": "c42476a3aa2dd79c",
        "name": "Ecran LCD On / Off",
        "style": {
            "stroke": "#000000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "ea5ef01450d064c2",
            "1a7ba77a039ff8a5",
            "7d10fe7928d35c9e",
            "5df172e294de3c89",
            "f1dc521817c84612",
            "496e4bb443b0bf0b",
            "edd8784d0c5d79c2"
        ],
        "x": 34,
        "y": 559,
        "w": 682,
        "h": 162
    },
    {
        "id": "784cf280be8f9617",
        "type": "group",
        "z": "63221fce04fce9a1",
        "name": "Lecture des setup arrivant depuis HAOS",
        "style": {
            "stroke": "#ff0000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "40c53f7ceb572ff5",
            "32422263e19ea107",
            "c3fe04450213c840",
            "55b993c941334789",
            "d0a21ee58c34740e",
            "195a17138b42ee08",
            "08624c75c29f1a0d",
            "70d583469e139f77",
            "c827a1a690486903",
            "b8969f5c95ec96c0",
            "1905f9987eb5b3fd",
            "7989336bb8bc11db"
        ],
        "x": 14,
        "y": 39,
        "w": 752,
        "h": 282
    },
    {
        "id": "219ec3c4c0c62dcb",
        "type": "group",
        "z": "63221fce04fce9a1",
        "name": "Write Setup Valeurs",
        "style": {
            "stroke": "#6f2fa0",
            "label": true,
            "color": "#6f2fa0"
        },
        "nodes": [
            "e5a60eb34250469e",
            "eb2f9a902aaa89d4",
            "1eae5ec0352d7054",
            "3b2397378287cde4",
            "991a64f8c51375eb",
            "0d83f03d4fe31ec7",
            "d7d7e9cdde18feea",
            "3c7d8632a04715ee",
            "2a33af3acfb1a757",
            "7062d7dac3d1708c",
            "1ce89be89438eff9",
            "23416caeb8f58587",
            "dbf778beb308a432",
            "d8fb1f44a0b34cb0",
            "13a18dea6847dcd9",
            "98b856c602c300ed",
            "97cc6b2d5b15ec56",
            "272cc4c342d5d912",
            "970884cba0b3a3b7",
            "92db9540d65530ec",
            "e2b657959bd108d7",
            "25a9d6ef8e4679d9",
            "3e6d34126eb8086d",
            "8c0ff28b33260428",
            "b6bae1307ec91a38",
            "f5b0b7204cb1eb25",
            "47ea910caf54107a",
            "9422ad975c55488b",
            "093a767a45da5e96",
            "4b03b3f62c267409",
            "80b77b7957818d4c",
            "40113a24a46cdb3b",
            "1558e7d444dba0cb",
            "56dd1878273cb1f8",
            "5b2b55fee59d0e82",
            "678c2f4b43673b7d",
            "adf49a702d6ba9dc",
            "8643c3a547c69160",
            "cb9d4157ead46059",
            "913ddde7f0deadf0",
            "2331437f356ceafd",
            "3907fa3c80ee4655",
            "e74995e51759d290"
        ],
        "x": 54,
        "y": 419,
        "w": 872,
        "h": 1362
    },
    {
        "id": "3309ffc04a216e40",
        "type": "group",
        "z": "dfa2ea8601dc4518",
        "name": "MQTT Broker",
        "style": {
            "label": true,
            "stroke": "#000000",
            "color": "#000000"
        },
        "nodes": [
            "95136cbde35b3056",
            "2123d252804f6de2",
            "836bea324c6df2ca",
            "1cd47d6c2f768f5f",
            "3cb083ba64129d24",
            "852b53befbd1075b",
            "dee0d6711b426449",
            "27b1591610853483",
            "698f6870ab9ffea7",
            "fd5bbf99e156f067",
            "70d27fecf9d0f6b3",
            "f295b7dfa1823e2a",
            "e5f2093494699767",
            "d1d53addb7c64437",
            "3ce30d1dddc257b6"
        ],
        "x": 74,
        "y": 579,
        "w": 772,
        "h": 242
    },
    {
        "id": "8ca20acee7a5ced4",
        "type": "group",
        "z": "dfa2ea8601dc4518",
        "name": "BMS number",
        "style": {
            "label": true,
            "stroke": "#000000",
            "color": "#000000"
        },
        "nodes": [
            "323d60d4baaf7cef",
            "a2b0648cb046cfbe",
            "4622780f4abd4ac3",
            "ea324554d0bd9024"
        ],
        "x": 34,
        "y": 479,
        "w": 612,
        "h": 82
    },
    {
        "id": "259fe46998b37b22",
        "type": "group",
        "z": "dfa2ea8601dc4518",
        "name": "Initialtisation des variables par défaut si pas renseignées",
        "style": {
            "label": true,
            "stroke": "#000000",
            "color": "#000000"
        },
        "nodes": [
            "15f1710cf5093fb0",
            "6cae3649dec819a4",
            "bbe4431a1216286d",
            "0716aa3cd0eb7183",
            "ad72afbb71279da9",
            "b40d86ff8814acd6",
            "10d32db96de1049b",
            "9c7d6f179e710814",
            "bce7a24ea78cde8e",
            "2372cd84fe52e55c",
            "91b88a5031c60415",
            "b67ac1233f0da57e",
            "cff79b090ba46671",
            "8ea8e26d1fdd001e",
            "081a4d809dc9018e",
            "43c4f85eafb7dc6b",
            "8eba824391b30950",
            "9e1ff26caf038053",
            "42c42f151143fc33",
            "5d682238eaebc0e9",
            "2b3a79e14d5983b1"
        ],
        "x": 34,
        "y": 58,
        "w": 822,
        "h": 363
    },
    {
        "id": "331dfcc16357afd3",
        "type": "group",
        "z": "dfa2ea8601dc4518",
        "name": "USB_serial_port",
        "style": {
            "label": true,
            "stroke": "#000000",
            "color": "#000000"
        },
        "nodes": [
            "f046317729829edf",
            "504a0728ea25b990",
            "08f864ae8a8410af",
            "a860585537cd655c"
        ],
        "x": 74,
        "y": 839,
        "w": 582,
        "h": 82
    },
    {
        "id": "90972d3c7f38ea12",
        "type": "group",
        "z": "2d882136a35b2d36",
        "name": "Configuration du port USB RS485",
        "style": {
            "stroke": "#000000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "b1df428df7a432e7",
            "f5943e5ca4b7e848",
            "867a03823f8deac3",
            "a14480dd30524258"
        ],
        "x": 14,
        "y": 259,
        "w": 842,
        "h": 82
    },
    {
        "id": "4f414bd4941422a3",
        "type": "group",
        "z": "2d882136a35b2d36",
        "name": "Initialisation des variables",
        "style": {
            "stroke": "#000000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "3721fb908989cdb8",
            "c8edea76be99bfc1"
        ],
        "x": 14,
        "y": 19,
        "w": 562,
        "h": 82
    },
    {
        "id": "44faab0d8759f989",
        "type": "group",
        "z": "2d882136a35b2d36",
        "name": "MQTT définitions",
        "style": {
            "stroke": "#000000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "7b4899cb440ff2f9",
            "1886e97a550fdebe",
            "4ef89226ddebe9b3",
            "cc37c11c33756143",
            "5ee485bdb3085557",
            "358d596529460ec8"
        ],
        "x": 34,
        "y": 379,
        "w": 772,
        "h": 142
    },
    {
        "id": "58578674e7f69c99",
        "type": "group",
        "z": "2d882136a35b2d36",
        "name": "Récupération des variables définies dans la configuration du module depuis l'onglet configuration de HAOS",
        "style": {
            "stroke": "#000000",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "e3d2b4d505d7c3b1",
            "d3a91a0be3d32cfa",
            "6a484576febf2df9",
            "697f593b67e21ceb",
            "307c4ac37254eba4",
            "c5b68a34de9a9c28"
        ],
        "x": 34,
        "y": 119,
        "w": 1032,
        "h": 122
    },
    {
        "id": "67d16682a4904961",
        "type": "group",
        "z": "e437f2f44495aeb9",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "47904917111ec14c",
            "8d56499e5fd78d16",
            "6ba5ab19ca0baf49",
            "502b03bbf1fa8f13"
        ],
        "x": 714,
        "y": 599,
        "w": 372,
        "h": 122
    },
    {
        "id": "1c9e2e84f7764473",
        "type": "group",
        "z": "e437f2f44495aeb9",
        "name": "Gateway Ethernet or Wifi",
        "style": {
            "stroke": "#0070c0",
            "fill": "#bfdbef",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "fb941bfb8f075284",
            "374bbe6e8c64a12a",
            "710b79fc70fe4146",
            "d132c36160191dc5",
            "22c8417438319190"
        ],
        "x": 614,
        "y": 39,
        "w": 512,
        "h": 122
    },
    {
        "id": "8d42d70f697c6b57",
        "type": "group",
        "z": "e437f2f44495aeb9",
        "g": "554f91ffdbfbfc68",
        "name": "Trame 1",
        "style": {
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "20642f46d6ad8f27",
            "1555b1456f9f113e",
            "780b5889dad59c22",
            "1c533d251a90da41",
            "1967c318d9216a54",
            "55ea9406b130a136",
            "1a9a7bee6083f2b1",
            "f0baa88edd6cc075"
        ],
        "x": 44,
        "y": 959,
        "w": 821,
        "h": 122
    },
    {
        "id": "6ec0cd904988f0ff",
        "type": "group",
        "z": "e437f2f44495aeb9",
        "g": "554f91ffdbfbfc68",
        "name": "Trame 3",
        "style": {
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "6b802ba3d2772465",
            "27c1423f6c9aada6",
            "8a804f30a6c6f20f",
            "5ee439284855bf6e",
            "3c4c2b0ec268a41f",
            "a57eec1d77cfb03e",
            "da663fa50d94c63c",
            "64590862f9d3a361",
            "f2fbf57365769c2d",
            "0b480948b60d645d",
            "8ccdcf5d7075d4c7",
            "653bf583b3edc452",
            "55785a4118180011",
            "ec8b2fdc37713423"
        ],
        "x": 54,
        "y": 1279,
        "w": 841,
        "h": 202
    },
    {
        "id": "f8bc911f73526834",
        "type": "group",
        "z": "e437f2f44495aeb9",
        "g": "554f91ffdbfbfc68",
        "name": "Trame 2",
        "style": {
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "e6d9f6f2ecbfa12e",
            "9b9034a8b404274d",
            "23a113423703427c",
            "3775966e34cef950",
            "6ddc941d8fc09996",
            "2dca953e4985c420",
            "e8ed5df6828f9f8f",
            "08b1d0bb4085f9c1"
        ],
        "x": 44,
        "y": 1119,
        "w": 842,
        "h": 122
    },
    {
        "id": "c5358579966ea944",
        "type": "group",
        "z": "e437f2f44495aeb9",
        "g": "554f91ffdbfbfc68",
        "name": "Debug si nécessaire",
        "style": {
            "label": true
        },
        "nodes": [
            "b8914948fca3fdf5",
            "019f592e42a7a3e6"
        ],
        "x": 54,
        "y": 1539,
        "w": 372,
        "h": 82
    },
    {
        "id": "754c40640a559f32",
        "type": "group",
        "z": "c42476a3aa2dd79c",
        "g": "c5544de409dc3632",
        "name": "LCD-on-off",
        "style": {
            "stroke": "#6f2fa0",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "0e2e65e40bcb2ac0",
            "dbee32cce099fa83",
            "d5dca54b28d74f18",
            "0e22f5085190544e",
            "3d4605eb10a3d1dc"
        ],
        "x": 374,
        "y": 99,
        "w": 562,
        "h": 122
    },
    {
        "id": "39449a18b64acb51",
        "type": "group",
        "z": "c42476a3aa2dd79c",
        "g": "c5544de409dc3632",
        "name": "Lire - DIVERS: 0xabcd",
        "style": {
            "stroke": "#6f2fa0",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "e9a62d58d10aea04",
            "991b73c0d7830977",
            "a627048a1842edd0",
            "347c975cf903685a",
            "30ec269020be3cfd"
        ],
        "x": 374,
        "y": 239,
        "w": 562,
        "h": 122
    },
    {
        "id": "d3d5c2188bb8b56e",
        "type": "group",
        "z": "c42476a3aa2dd79c",
        "g": "c5544de409dc3632",
        "name": "Lire - DIVERS bit's",
        "style": {
            "stroke": "#6f2fa0",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "3d490c4684163fca",
            "142bf6609d8a7858",
            "33a274fa6b859154",
            "d1d7ba8380ba4e39",
            "8cf65bc85374df94"
        ],
        "x": 374,
        "y": 379,
        "w": 562,
        "h": 122
    },
    {
        "id": "a144206f0ce5be54",
        "type": "ui_base",
        "theme": {
            "name": "theme-light",
            "lightTheme": {
                "default": "#0094CE",
                "baseColor": "#0094CE",
                "baseFont": "-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif",
                "edited": true,
                "reset": false
            },
            "darkTheme": {
                "default": "#097479",
                "baseColor": "#097479",
                "baseFont": "-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif",
                "edited": false
            },
            "customTheme": {
                "name": "Untitled Theme 1",
                "default": "#4B7930",
                "baseColor": "#4B7930",
                "baseFont": "-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif"
            },
            "themeState": {
                "base-color": {
                    "default": "#0094CE",
                    "value": "#0094CE",
                    "edited": false
                },
                "page-titlebar-backgroundColor": {
                    "value": "#0094CE",
                    "edited": false
                },
                "page-backgroundColor": {
                    "value": "#fafafa",
                    "edited": false
                },
                "page-sidebar-backgroundColor": {
                    "value": "#ffffff",
                    "edited": false
                },
                "group-textColor": {
                    "value": "#1bbfff",
                    "edited": false
                },
                "group-borderColor": {
                    "value": "#ffffff",
                    "edited": false
                },
                "group-backgroundColor": {
                    "value": "#ffffff",
                    "edited": false
                },
                "widget-textColor": {
                    "value": "#111111",
                    "edited": false
                },
                "widget-backgroundColor": {
                    "value": "#0094ce",
                    "edited": false
                },
                "widget-borderColor": {
                    "value": "#ffffff",
                    "edited": false
                },
                "base-font": {
                    "value": "-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif"
                }
            },
            "angularTheme": {
                "primary": "indigo",
                "accents": "blue",
                "warn": "red",
                "background": "grey",
                "palette": "light"
            }
        },
        "site": {
            "name": "Node-RED Dashboard",
            "hideToolbar": "false",
            "allowSwipe": "false",
            "lockMenu": "false",
            "allowTempTheme": "true",
            "dateFormat": "DD/MM/YYYY",
            "sizes": {
                "sx": 48,
                "sy": 48,
                "gx": 6,
                "gy": 6,
                "cx": 6,
                "cy": 6,
                "px": 0,
                "py": 0
            }
        }
    },
    {
        "id": "5752eb1b8caab0c9",
        "type": "ui_tab",
        "name": "Junctek",
        "icon": "dashboard",
        "order": 18,
        "disabled": true,
        "hidden": true
    },
    {
        "id": "cba66bb9ef46fb85",
        "type": "ui_group",
        "name": "Jauges",
        "tab": "5752eb1b8caab0c9",
        "order": 2,
        "disp": true,
        "width": 15,
        "collapse": false,
        "className": ""
    },
    {
        "id": "d3d8016d23d6cfdc",
        "type": "ui_spacer",
        "z": "a1b94e47fdb804f8",
        "name": "spacer",
        "group": "cba66bb9ef46fb85",
        "order": 7,
        "width": 12,
        "height": 1
    },
    {
        "id": "0d11c7e9e1c9694f",
        "type": "ui_spacer",
        "z": "a1b94e47fdb804f8",
        "name": "spacer",
        "group": "cba66bb9ef46fb85",
        "order": 9,
        "width": 12,
        "height": 1
    },
    {
        "id": "0dd2e420a2181a0a",
        "type": "ui-base",
        "name": "Setup",
        "path": "/dashboard",
        "appIcon": "",
        "includeClientData": true,
        "acceptsClientConfig": [
            "ui-notification",
            "ui-control"
        ],
        "showPathInSidebar": false,
        "headerContent": "page",
        "navigationStyle": "default",
        "titleBarStyle": "default",
        "showReconnectNotification": true,
        "notificationDisplayTime": 1,
        "showDisconnectNotification": true
    },
    {
        "id": "71b1a03690005ff7",
        "type": "ui-theme",
        "name": "Default Theme",
        "colors": {
            "surface": "#ffffff",
            "primary": "#0094CE",
            "bgPage": "#eeeeee",
            "groupBg": "#ffffff",
            "groupOutline": "#cccccc"
        },
        "sizes": {
            "density": "default",
            "pagePadding": "12px",
            "groupGap": "12px",
            "groupBorderRadius": "4px",
            "widgetGap": "12px"
        }
    },
    {
        "id": "e5d49fabb6dd43f4",
        "type": "ui-page",
        "name": "Setup",
        "ui": "0dd2e420a2181a0a",
        "path": "/page1",
        "icon": "home",
        "layout": "grid",
        "theme": "71b1a03690005ff7",
        "breakpoints": [
            {
                "name": "Default",
                "px": "0",
                "cols": "4"
            },
            {
                "name": "Tablet",
                "px": "576",
                "cols": "6"
            },
            {
                "name": "Small Desktop",
                "px": "768",
                "cols": "9"
            },
            {
                "name": "Desktop",
                "px": "1024",
                "cols": "12"
            }
        ],
        "order": 1,
        "className": "",
        "visible": "true",
        "disabled": "false"
    },
    {
        "id": "858d2c8bdccf259b",
        "type": "ui-group",
        "name": "Setup JK-BMS's",
        "page": "e5d49fabb6dd43f4",
        "width": "7",
        "height": 1,
        "order": 1,
        "showTitle": true,
        "className": "",
        "visible": "true",
        "disabled": "false",
        "groupType": "default"
    },
    {
        "id": "d7bba5b6c3974417",
        "type": "ui-spacer",
        "group": "858d2c8bdccf259b",
        "name": "spacer",
        "tooltip": "",
        "order": 2,
        "width": "4",
        "height": 1,
        "className": ""
    },
    {
        "id": "99d1b89194675707",
        "type": "ui-spacer",
        "group": "858d2c8bdccf259b",
        "name": "spacer",
        "tooltip": "",
        "order": 8,
        "width": "2",
        "height": 1,
        "className": ""
    },
    {
        "id": "6e1abcbcc6ebb714",
        "type": "serial-port",
        "name": "JKBMS-RS485",
        "serialport": "/dev/JKBMS",
        "serialbaud": "115200",
        "databits": 8,
        "parity": "none",
        "stopbits": 1,
        "waitfor": "",
        "dtr": "none",
        "rts": "none",
        "cts": "none",
        "dsr": "none",
        "newline": "200",
        "bin": "bin",
        "out": "time",
        "addchar": "",
        "responsetimeout": "500"
    },
    {
        "id": "56f7b2737cce493b",
        "type": "mqtt-broker",
        "name": "",
        "broker": "core-mosquitto.local.hass.io",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "bd32d7ad2e41fd6b",
        "type": "inject",
        "z": "6fc9763d4087338c",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "url",
                "v": "https://domosimple.eu/valide/check_license.php?license_key=LIC-675AA47154DF52.6175956",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "",
        "payload": "",
        "payloadType": "str",
        "x": 100,
        "y": 100,
        "wires": [
            [
                "baef5c9129331285"
            ]
        ]
    },
    {
        "id": "1ce6a7eabb31a0e3",
        "type": "function",
        "z": "6fc9763d4087338c",
        "name": "function 99",
        "func": "// Vérifier si le payload est une chaîne JSON\ntry {\n    // Tenter de parser la chaîne JSON dans le payload\n    var jsonData = JSON.parse(msg.payload);\n\n    // Maintenant vous pouvez accéder aux propriétés de jsonData\n    msg.payload = {\n        status: jsonData.status,\n        expiration: jsonData.expiration\n    };\n\n} catch (e) {\n    // Si le parsing échoue, afficher une erreur et conserver l'ancienne valeur\n    node.error(\"Erreur de parsing JSON : \" + e.message);\n\n    // En cas d'erreur de parsing, récupérer la date d'expiration depuis les paramètres globaux\n    msg.payload = {\n        expiration: global.get('parametre.li.expiration'),\n        erreur: \"Problème serveur, mais licence toujours valide\",\n        status: true // Le statut reste à true, indiquant que la licence existe toujours\n    };\n}\n\n// Fonction pour vérifier la date d'expiration avec le serveur\nif (msg.payload.status === \"true\" || msg.payload.status === true) {\n    // Licence existe, vérifier la date d'expiration\n    const expirationDate = new Date(msg.payload.expiration); // Convertir la date d'expiration au format Date\n    const currentDate = new Date();\n\n    // Comparer les deux dates\n    if (expirationDate < currentDate) {\n        msg.payload.status = false;  // Licence expirée\n        global.set('parametre.li.active', false); // Mettre à jour le statut dans les paramètres globaux\n        global.set('parametre.li.expiration', expirationDate.toISOString()); // Enregistrer la date d'expiration\n        msg.erreur = \"License expirer\"\n        node.send(msg);\n    } else {\n        msg.payload.status = true; // Licence valide\n        global.set('parametre.li.active', true); // Mettre à jour le statut dans les paramètres globaux\n        global.set('parametre.li.expiration', expirationDate.toISOString()); // Enregistrer la date d'expiration\n    }\n} else {\n    // Licence n'existe pas ou problème de serveur\n    msg.payload.status = false; // Licence n'existe pas\n    global.set('parametre.li.active', false); // Mettre à jour le statut dans les paramètres globaux\n    global.set('parametre.li.expiration', null); // Pas de date d'expiration car la licence n'existe pas\n    msg.erreur = \"Licence n'existe pas\"\n    node.send(msg);\n}\n\n\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 750,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "a7bf12e890b893de",
        "type": "http request",
        "z": "6fc9763d4087338c",
        "name": "",
        "method": "GET",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 550,
        "y": 100,
        "wires": [
            [
                "1ce6a7eabb31a0e3"
            ]
        ]
    },
    {
        "id": "baef5c9129331285",
        "type": "function",
        "z": "6fc9763d4087338c",
        "name": "function 100",
        "func": "msg.license = global.get(\"parametre.li.num\");\nmsg.url = \"https://domosimple.eu/valide/valide.php?license_key=\" + msg.license\nmsg.headers = {\n    'Cache-Control': 'no-store, no-cache, must-revalidate, proxy-revalidate',\n    'Pragma': 'no-cache',\n    'Expires': '0'\n};\nreturn msg",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 310,
        "y": 100,
        "wires": [
            [
                "a7bf12e890b893de"
            ]
        ]
    },
    {
        "id": "d343819a3f85f8d6",
        "type": "comment",
        "z": "a1b94e47fdb804f8",
        "name": "This software is the property of JLM . It is subject to intellectual property and copyright laws.",
        "info": "",
        "x": 330,
        "y": 134,
        "wires": []
    },
    {
        "id": "23018b5d9a6674ce",
        "type": "comment",
        "z": "a1b94e47fdb804f8",
        "name": "copyright ©JLM 2025",
        "info": "",
        "x": 120,
        "y": 74,
        "wires": []
    },
    {
        "id": "424908b1975ed598",
        "type": "comment",
        "z": "a1b94e47fdb804f8",
        "name": "Only JLM has the right to modify all or part of this software.",
        "info": "",
        "x": 230,
        "y": 260,
        "wires": []
    },
    {
        "id": "d76ddb17291daf57",
        "type": "comment",
        "z": "a1b94e47fdb804f8",
        "name": "It has been designed to manage JK-KONG BMS type: PBxA1xS1xP",
        "info": "",
        "x": 260,
        "y": 200,
        "wires": []
    },
    {
        "id": "0962412f9331473c",
        "type": "comment",
        "z": "a1b94e47fdb804f8",
        "name": "Do not transmit, copy or modify this software without the written consent of its authors.",
        "info": "",
        "x": 320,
        "y": 320,
        "wires": []
    },
    {
        "id": "d5937ff37aa8f2e6",
        "type": "comment",
        "z": "a1b94e47fdb804f8",
        "name": "According to article L335-3 of the French Intellectual Property Code, “infringement of one of the rights of the author of a software program as defined in article L122-6” constitutes an offence of counterfeiting.",
        "info": "",
        "x": 690,
        "y": 380,
        "wires": []
    },
    {
        "id": "712b7bd29f2ba376",
        "type": "comment",
        "z": "a1b94e47fdb804f8",
        "name": "Any infringement of a software author's rights can therefore be qualified as counterfeiting.",
        "info": "",
        "x": 330,
        "y": 440,
        "wires": []
    },
    {
        "id": "f5943e5ca4b7e848",
        "type": "function",
        "z": "2d882136a35b2d36",
        "g": "90972d3c7f38ea12",
        "name": "Setup USB Port",
        "func": "// récupère le port série à utiliser\n    msg.payload = {\n    \"serialport\": global.get(\"path\"),\n    \"serialbaud\": 115800,\n    \"databits\": 8,\n    \"parity\": \"none\",\n    \"stopbits\": 1,\n    \"enabled\": true\n    }\n\n    node.send(msg)",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 330,
        "y": 300,
        "wires": [
            [
                "a14480dd30524258"
            ]
        ]
    },
    {
        "id": "867a03823f8deac3",
        "type": "inject",
        "z": "2d882136a35b2d36",
        "g": "90972d3c7f38ea12",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1.5",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 130,
        "y": 300,
        "wires": [
            [
                "f5943e5ca4b7e848"
            ]
        ]
    },
    {
        "id": "a14480dd30524258",
        "type": "serial control",
        "z": "2d882136a35b2d36",
        "g": "90972d3c7f38ea12",
        "name": "JKBMS-RS485",
        "serial": "6e1abcbcc6ebb714",
        "x": 530,
        "y": 300,
        "wires": [
            [
                "b1df428df7a432e7"
            ]
        ]
    },
    {
        "id": "b1df428df7a432e7",
        "type": "debug",
        "z": "2d882136a35b2d36",
        "g": "90972d3c7f38ea12",
        "name": "Serial Control",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 730,
        "y": 300,
        "wires": []
    },
    {
        "id": "3721fb908989cdb8",
        "type": "inject",
        "z": "2d882136a35b2d36",
        "g": "4f414bd4941422a3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 130,
        "y": 60,
        "wires": [
            [
                "c8edea76be99bfc1"
            ]
        ]
    },
    {
        "id": "c8edea76be99bfc1",
        "type": "change",
        "z": "2d882136a35b2d36",
        "g": "4f414bd4941422a3",
        "name": "initialisation slaveAddress-Trame-1-2-3",
        "rules": [
            {
                "t": "set",
                "p": "slaveAddress-Trame1",
                "pt": "global",
                "to": "1",
                "tot": "num"
            },
            {
                "t": "set",
                "p": "slaveAddress-Trame2",
                "pt": "global",
                "to": "1",
                "tot": "num"
            },
            {
                "t": "set",
                "p": "slaveAddress-Trame3",
                "pt": "global",
                "to": "1",
                "tot": "num"
            },
            {
                "t": "set",
                "p": "slaveAddress-setup",
                "pt": "global",
                "to": "1",
                "tot": "num"
            },
            {
                "t": "set",
                "p": "gateway_ip",
                "pt": "global",
                "to": "192.168.1.238",
                "tot": "str"
            },
            {
                "t": "set",
                "p": "gateway_port",
                "pt": "global",
                "to": "8887",
                "tot": "num"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 400,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "1886e97a550fdebe",
        "type": "inject",
        "z": "2d882136a35b2d36",
        "g": "44faab0d8759f989",
        "name": "disconnect",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "action",
                "v": "disconnect",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "0.5",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 420,
        "wires": [
            [
                "358d596529460ec8"
            ]
        ]
    },
    {
        "id": "4ef89226ddebe9b3",
        "type": "inject",
        "z": "2d882136a35b2d36",
        "g": "44faab0d8759f989",
        "name": "connect",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 480,
        "wires": [
            [
                "cc37c11c33756143"
            ]
        ]
    },
    {
        "id": "cc37c11c33756143",
        "type": "function",
        "z": "2d882136a35b2d36",
        "g": "44faab0d8759f989",
        "name": "Défiition du Broker",
        "func": "msg.action = \"connect\";\nmsg.broker = '{\"broker\":\"' + global.get(\"mqttadresse\")+'\",'\n    + '\"port\":\"' + global.get(\"mqttport\")+'\",'\n    + '\"username\":\"' + global.get(\"mqttuser\")+'\",'\n    + '\"password\":\"' + global.get(\"mqttpass\")+'\"'\n    +'}';\nreturn msg\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 480,
        "wires": [
            [
                "5ee485bdb3085557"
            ]
        ]
    },
    {
        "id": "5ee485bdb3085557",
        "type": "json",
        "z": "2d882136a35b2d36",
        "g": "44faab0d8759f989",
        "name": "",
        "property": "broker",
        "action": "",
        "pretty": false,
        "x": 510,
        "y": 480,
        "wires": [
            [
                "358d596529460ec8",
                "7b4899cb440ff2f9"
            ]
        ]
    },
    {
        "id": "358d596529460ec8",
        "type": "mqtt out",
        "z": "2d882136a35b2d36",
        "g": "44faab0d8759f989",
        "name": "MQTT Broker",
        "topic": "",
        "qos": "1",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 700,
        "y": 420,
        "wires": []
    },
    {
        "id": "7b4899cb440ff2f9",
        "type": "debug",
        "z": "2d882136a35b2d36",
        "g": "44faab0d8759f989",
        "name": "debug 23",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 680,
        "y": 480,
        "wires": []
    },
    {
        "id": "e3d2b4d505d7c3b1",
        "type": "inject",
        "z": "2d882136a35b2d36",
        "g": "58578674e7f69c99",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 160,
        "wires": [
            [
                "d3a91a0be3d32cfa"
            ]
        ]
    },
    {
        "id": "d3a91a0be3d32cfa",
        "type": "file in",
        "z": "2d882136a35b2d36",
        "g": "58578674e7f69c99",
        "name": "",
        "filename": "/data/options.json",
        "filenameType": "str",
        "format": "utf8",
        "chunk": false,
        "sendError": false,
        "encoding": "none",
        "allProps": false,
        "x": 350,
        "y": 160,
        "wires": [
            [
                "6a484576febf2df9"
            ]
        ]
    },
    {
        "id": "6a484576febf2df9",
        "type": "json",
        "z": "2d882136a35b2d36",
        "g": "58578674e7f69c99",
        "name": "",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 550,
        "y": 160,
        "wires": [
            [
                "307c4ac37254eba4",
                "c5b68a34de9a9c28"
            ]
        ]
    },
    {
        "id": "697f593b67e21ceb",
        "type": "debug",
        "z": "2d882136a35b2d36",
        "g": "58578674e7f69c99",
        "name": "debug 97",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 960,
        "y": 160,
        "wires": []
    },
    {
        "id": "307c4ac37254eba4",
        "type": "debug",
        "z": "2d882136a35b2d36",
        "g": "58578674e7f69c99",
        "name": "debug 164",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 730,
        "y": 200,
        "wires": []
    },
    {
        "id": "c5b68a34de9a9c28",
        "type": "function",
        "z": "2d882136a35b2d36",
        "g": "58578674e7f69c99",
        "name": "Définir global variables",
        "func": "// Récupération des données du payload\nconst data = msg.payload;\n\n// Extraction et stockage des variables globales\ntry {\n    // Configuration JK-BMS principale\n    if (data.jkbms_path) {\n        global.set(\"path\", data.jkbms_path);\n        node.log(\"Variable globale 'path' définie: \" + data.jkbms_path);\n    }\n    \n    if (data.jkbms_count) {\n        global.set(\"nb_jkbms\", data.jkbms_count);\n        node.log(\"Variable globale 'nb_jkbms' définie: \" + data.jkbms_count);\n    }\n    \n    // Configuration Gateway\n    if (data.use_gateway !== undefined) {\n        global.set(\"use_gateway\", data.use_gateway);\n        node.log(\"Variable globale 'use_gateway' définie: \" + data.use_gateway);\n    }\n    \n    if (data.gateway_ip) {\n        global.set(\"gateway_ip\", data.gateway_ip);\n        node.log(\"Variable globale 'gateway_ip' définie: \" + data.gateway_ip);\n    }\n    \n    if (data.gateway_port) {\n        global.set(\"gateway_port\", data.gateway_port);\n        node.log(\"Variable globale 'gateway_port' définie: \" + data.gateway_port);\n    }\n    \n    // Paramètres MQTT\n    if (data.mqtt) {\n        if (data.mqtt.mqttadresse) {\n            global.set(\"mqttadresse\", data.mqtt.mqttadresse);\n            node.log(\"Variable globale 'mqttadresse' définie: \" + data.mqtt.mqttadresse);\n        }\n        \n        if (data.mqtt.mqttport) {\n            global.set(\"mqttport\", data.mqtt.mqttport);\n            node.log(\"Variable globale 'mqttport' définie: \" + data.mqtt.mqttport);\n        }\n        \n        if (data.mqtt.mqttuser) {\n            global.set(\"mqttuser\", data.mqtt.mqttuser);\n            node.log(\"Variable globale 'mqttuser' définie: \" + data.mqtt.mqttuser);\n        }\n        \n        if (data.mqtt.mqttpass) {\n            global.set(\"mqttpass\", data.mqtt.mqttpass);\n            node.log(\"Variable globale 'mqttpass' définie: \" + data.mqtt.mqttpass);\n        }\n    }\n    \n    // Configuration SSL (ajoutée en bonus)\n    if (data.ssl !== undefined) {\n        global.set(\"ssl\", data.ssl);\n        node.log(\"Variable globale 'ssl' définie: \" + data.ssl);\n    }\n    \n    if (data.certfile) {\n        global.set(\"certfile\", data.certfile);\n        node.log(\"Variable globale 'certfile' définie: \" + data.certfile);\n    }\n    \n    if (data.keyfile) {\n        global.set(\"keyfile\", data.keyfile);\n        node.log(\"Variable globale 'keyfile' définie: \" + data.keyfile);\n    }\n    \n    // Message de confirmation\n    msg.payload = {\n        status: \"success\",\n        message: \"Variables globales créées avec succès\",\n        variables: {\n            path: global.get(\"path\"),\n            nb_jkbms: global.get(\"nb_jkbms\"),\n            use_gateway: global.get(\"use_gateway\"),\n            gateway_ip: global.get(\"gateway_ip\"),\n            gateway_port: global.get(\"gateway_port\"),\n            mqttadresse: global.get(\"mqttadresse\"),\n            mqttport: global.get(\"mqttport\"),\n            mqttuser: global.get(\"mqttuser\"),\n            mqttpass: global.get(\"mqttpass\"),\n            ssl: global.get(\"ssl\"),\n            certfile: global.get(\"certfile\"),\n            keyfile: global.get(\"keyfile\")\n        }\n    };\n\n} catch (error) {\n    node.error(\"Erreur lors de la création des variables globales: \" + error.message);\n    msg.payload = {\n        status: \"error\",\n        message: error.message\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 760,
        "y": 160,
        "wires": [
            [
                "697f593b67e21ceb"
            ]
        ]
    },
    {
        "id": "prepare_command",
        "type": "function",
        "z": "e437f2f44495aeb9",
        "g": "6b5bd0bba4a26d99",
        "name": "Live Trame 3   -  #5664 - 0x1620",
        "func": "// Création de la trame Modbus pour registre 5664\nlet currentAddress = global.get(\"slaveAddress-Trame3\") || 1; // Valeur par défaut : 1\n// Récupération de l'adresse esclave depuis le contexte global\nconst slaveId = global.get(\"slaveAddress-Trame3\") || 0x01; // Valeur par défaut si non définie\nconst functionCode = 0x10;\nconst registerHigh = 0x16;\nconst registerLow = 0x20;\nconst quantityHigh = 0x00;\nconst quantityLow = 0x01;\nconst byteCount = 0x02;\nconst valueHigh = 0x00;\nconst valueLow = 0x00;\n\n// Calculer CRC16 Modbus\nfunction crc16(buffer) {\n    let crc = 0xFFFF;\n    for (let i = 0; i < buffer.length; i++) {\n        crc ^= buffer[i];\n        for (let j = 0; j < 8; j++) {\n            if (crc & 0x0001) {\n                crc = (crc >> 1) ^ 0xA001;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    return crc;\n}\n\n// Construction du buffer sans CRC\nconst dataBuffer = Buffer.from([\n    slaveId,\n    functionCode,\n    registerHigh,\n    registerLow,\n    quantityHigh,\n    quantityLow,\n    byteCount,\n    valueHigh,\n    valueLow\n]);\n\n// Calcul du CRC\nconst crc = crc16(dataBuffer);\n\n// Buffer final avec CRC\nconst finalBuffer = Buffer.allocUnsafe(dataBuffer.length + 2);\ndataBuffer.copy(finalBuffer);\nfinalBuffer.writeUInt16LE(crc, dataBuffer.length);\n\nmsg.topic = \"Trame-3-dynamiques\"\nmsg.payload = finalBuffer;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 540,
        "wires": [
            [
                "d3854248aace5164"
            ]
        ]
    },
    {
        "id": "48962018a6c0050f",
        "type": "function",
        "z": "e437f2f44495aeb9",
        "g": "6b5bd0bba4a26d99",
        "name": "Fixes Trame 1  -  #5660 - 0x161C",
        "func": "// Création de la trame Modbus pour registre 5664\nlet currentAddress = global.get(\"slaveAddress-Trame1\") || 1; // Valeur par défaut : 1\n// Récupération de l'adresse esclave depuis le contexte global\nconst slaveId = global.get(\"slaveAddress-Trame1\") || 0x01; // Valeur par défaut si non définie\nconst functionCode = 0x10;\nconst registerHigh = 0x16;\nconst registerLow = 0x1C;\nconst quantityHigh = 0x00;\nconst quantityLow = 0x01;\nconst byteCount = 0x02;\nconst valueHigh = 0x00;\nconst valueLow = 0x00;\n\n// Calculer CRC16 Modbus\nfunction crc16(buffer) {\n    let crc = 0xFFFF;\n    for (let i = 0; i < buffer.length; i++) {\n        crc ^= buffer[i];\n        for (let j = 0; j < 8; j++) {\n            if (crc & 0x0001) {\n                crc = (crc >> 1) ^ 0xA001;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    return crc;\n}\n\n// Construction du buffer sans CRC\nconst dataBuffer = Buffer.from([\n    slaveId,\n    functionCode,\n    registerHigh,\n    registerLow,\n    quantityHigh,\n    quantityLow,\n    byteCount,\n    valueHigh,\n    valueLow\n]);\n\n// Calcul du CRC\nconst crc = crc16(dataBuffer);\n\n// Buffer final avec CRC\nconst finalBuffer = Buffer.allocUnsafe(dataBuffer.length + 2);\ndataBuffer.copy(finalBuffer);\nfinalBuffer.writeUInt16LE(crc, dataBuffer.length);\n\nmsg.topic = \"Trame-1-statiques\"\nmsg.payload = finalBuffer;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 280,
        "wires": [
            [
                "d3854248aace5164"
            ]
        ]
    },
    {
        "id": "305e1cac13589b0d",
        "type": "link in",
        "z": "e437f2f44495aeb9",
        "g": "efcb27eee8e0e602",
        "name": "Serial-In",
        "links": [
            "cb31b781d9bcb31e",
            "5df172e294de3c89",
            "3d4605eb10a3d1dc",
            "30ec269020be3cfd",
            "d1d7ba8380ba4e39",
            "366518e9212a6b71"
        ],
        "x": 145,
        "y": 80,
        "wires": [
            [
                "8d8489f730e79441"
            ]
        ]
    },
    {
        "id": "cb31b781d9bcb31e",
        "type": "link out",
        "z": "e437f2f44495aeb9",
        "g": "6b5bd0bba4a26d99",
        "name": "link out 5",
        "mode": "link",
        "links": [
            "305e1cac13589b0d"
        ],
        "x": 695,
        "y": 400,
        "wires": []
    },
    {
        "id": "020c19662d54639e",
        "type": "function",
        "z": "e437f2f44495aeb9",
        "g": "6b5bd0bba4a26d99",
        "name": "Setup Trame 2  -  #5662 - 0x1622",
        "func": "// Création de la trame Modbus pour registre 5662\nlet currentAddress = global.get(\"slaveAddress-Trame2\") || 1; // Valeur par défaut : 1\n// Récupération de l'adresse esclave depuis le contexte global\nconst slaveId = global.get(\"slaveAddress-Trame2\") || 0x01; // Valeur par défaut si non définie\nconst functionCode = 0x10;\nconst registerHigh = 0x16;\nconst registerLow = 0x1E;\nconst quantityHigh = 0x00;\nconst quantityLow = 0x01;\nconst byteCount = 0x02;\nconst valueHigh = 0x00;\nconst valueLow = 0x00;\n\n// Calculer CRC16 Modbus\nfunction crc16(buffer) {\n    let crc = 0xFFFF;\n    for (let i = 0; i < buffer.length; i++) {\n        crc ^= buffer[i];\n        for (let j = 0; j < 8; j++) {\n            if (crc & 0x0001) {\n                crc = (crc >> 1) ^ 0xA001;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    return crc;\n}\n\n// Construction du buffer sans CRC\nconst dataBuffer = Buffer.from([\n    slaveId,\n    functionCode,\n    registerHigh,\n    registerLow,\n    quantityHigh,\n    quantityLow,\n    byteCount,\n    valueHigh,\n    valueLow\n]);\n\n// Calcul du CRC\nconst crc = crc16(dataBuffer);\n\n// Buffer final avec CRC\nconst finalBuffer = Buffer.allocUnsafe(dataBuffer.length + 2);\ndataBuffer.copy(finalBuffer);\nfinalBuffer.writeUInt16LE(crc, dataBuffer.length);\n\nmsg.topic = \"Trame-2-setup\"\nmsg.payload = finalBuffer;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 400,
        "wires": [
            [
                "d3854248aace5164"
            ]
        ]
    },
    {
        "id": "6b802ba3d2772465",
        "type": "debug",
        "z": "e437f2f44495aeb9",
        "g": "6ec0cd904988f0ff",
        "name": "Trame 3",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 200,
        "y": 1440,
        "wires": []
    },
    {
        "id": "e6d9f6f2ecbfa12e",
        "type": "debug",
        "z": "e437f2f44495aeb9",
        "g": "f8bc911f73526834",
        "name": "debug 16",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 580,
        "y": 1200,
        "wires": []
    },
    {
        "id": "87cae6741d4eba43",
        "type": "link in",
        "z": "e437f2f44495aeb9",
        "g": "554f91ffdbfbfc68",
        "name": "link in 3",
        "links": [
            "cfbb3e70d43124da",
            "d132c36160191dc5"
        ],
        "x": 65,
        "y": 860,
        "wires": [
            [
                "ef22a3d568844d0a",
                "722fcc3b75fdf46e"
            ]
        ]
    },
    {
        "id": "9b9034a8b404274d",
        "type": "debug",
        "z": "e437f2f44495aeb9",
        "g": "f8bc911f73526834",
        "name": "Trame 2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 190,
        "y": 1160,
        "wires": []
    },
    {
        "id": "20642f46d6ad8f27",
        "type": "debug",
        "z": "e437f2f44495aeb9",
        "g": "8d42d70f697c6b57",
        "name": "Trame 1",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 200,
        "y": 1000,
        "wires": []
    },
    {
        "id": "1555b1456f9f113e",
        "type": "debug",
        "z": "e437f2f44495aeb9",
        "g": "8d42d70f697c6b57",
        "name": "debug 21",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 579,
        "y": 1040,
        "wires": []
    },
    {
        "id": "780b5889dad59c22",
        "type": "buffer-parser",
        "z": "e437f2f44495aeb9",
        "g": "8d42d70f697c6b57",
        "name": "Trame 1",
        "data": "payload",
        "dataType": "msg",
        "specification": "spec",
        "specificationType": "ui",
        "items": [
            {
                "type": "ascii",
                "name": "BMS_A",
                "offset": 6,
                "length": 13,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "ascii",
                "name": "FW_A",
                "offset": 22,
                "length": 3,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "ascii",
                "name": "SW_N",
                "offset": 30,
                "length": 5,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint32le",
                "name": "Uptime_S",
                "offset": 38,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint32le",
                "name": "Power_count_N",
                "offset": 42,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "ascii",
                "name": "SerialNb_N",
                "offset": 46,
                "length": 13,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "ascii",
                "name": "Password1_A",
                "offset": 62,
                "length": 8,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "ascii",
                "name": "Manufacturing_date_N",
                "offset": 78,
                "length": 8,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "ascii",
                "name": "Brand_A",
                "offset": 102,
                "length": 8,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "ascii",
                "name": "Password2_A",
                "offset": 118,
                "length": 8,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "UART1_protocol_number_N",
                "offset": 184,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "CAN_protocol_number_N",
                "offset": 185,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "LCD_buzzer_trigger_N",
                "offset": 234,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint32le",
                "name": "LCD_buzzer_trigger_value_N",
                "offset": 238,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint32le",
                "name": "LCD_buzzer_release_value_N",
                "offset": 242,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "Request_Charge_voltage_Time_S",
                "offset": 266,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "Request_Float_voltage_Time_N",
                "offset": 267,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            }
        ],
        "swap1": "",
        "swap2": "",
        "swap3": "",
        "swap1Type": "swap",
        "swap2Type": "swap",
        "swap3Type": "swap",
        "msgProperty": "payload",
        "msgPropertyType": "str",
        "resultType": "keyvalue",
        "resultTypeType": "return",
        "multipleResult": false,
        "fanOutMultipleResult": false,
        "setTopic": true,
        "outputs": 1,
        "x": 390,
        "y": 1040,
        "wires": [
            [
                "1555b1456f9f113e",
                "f0baa88edd6cc075"
            ]
        ]
    },
    {
        "id": "8d8489f730e79441",
        "type": "serial request",
        "z": "e437f2f44495aeb9",
        "g": "efcb27eee8e0e602",
        "name": "JKBMS-RS485",
        "serial": "6e1abcbcc6ebb714",
        "x": 280,
        "y": 80,
        "wires": [
            [
                "cfbb3e70d43124da",
                "d9ef164688871372",
                "9c7f34f8f23e6ba9"
            ]
        ]
    },
    {
        "id": "ef22a3d568844d0a",
        "type": "switch",
        "z": "e437f2f44495aeb9",
        "g": "554f91ffdbfbfc68",
        "name": "Trame 1-2-3-Autres",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "Trame-1-statiques",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "Trame-2-setup",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "Trame-3-dynamiques",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 4,
        "x": 200,
        "y": 860,
        "wires": [
            [
                "58ef70ea1beab86a"
            ],
            [
                "5f01f1a8c86201ad"
            ],
            [
                "31a51f2f45d84be6"
            ],
            [
                "6a62d2d49420f2ef",
                "bb5385e5fa6e8f58"
            ]
        ]
    },
    {
        "id": "cfbb3e70d43124da",
        "type": "link out",
        "z": "e437f2f44495aeb9",
        "g": "efcb27eee8e0e602",
        "name": "Serial Out",
        "mode": "link",
        "links": [
            "87cae6741d4eba43"
        ],
        "x": 285,
        "y": 120,
        "wires": []
    },
    {
        "id": "d9ef164688871372",
        "type": "debug",
        "z": "e437f2f44495aeb9",
        "g": "efcb27eee8e0e602",
        "name": "Modbus Out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 460,
        "y": 80,
        "wires": []
    },
    {
        "id": "6a62d2d49420f2ef",
        "type": "debug",
        "z": "e437f2f44495aeb9",
        "g": "554f91ffdbfbfc68",
        "name": "Autres trame",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 480,
        "y": 900,
        "wires": []
    },
    {
        "id": "27c1423f6c9aada6",
        "type": "function",
        "z": "e437f2f44495aeb9",
        "g": "6ec0cd904988f0ff",
        "name": "Vérifie Trame 3",
        "func": "const expectedHeader = [0x55, 0xAA, 0xEB, 0x90, 0x02];\nconst expectedLength = 308;\n\n// Vérifie si le buffer commence par la séquence attendue et fait la bonne longueur\nfunction checkBuffer(buffer) {\n    // Vérifie d'abord la longueur totale\n    if (buffer.length !== expectedLength) return false;\n\n    // Vérifie ensuite l'en-tête\n    if (buffer.length < expectedHeader.length) return false;\n\n    for (let i = 0; i < expectedHeader.length; i++) {\n        if (buffer[i] !== expectedHeader[i]) return false;\n    }\n    return true;\n}\n\nif (checkBuffer(msg.payload)) {\n    return msg;\n} else {\n    return null; // Ne transmet pas le message si la vérification échoue\n}",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 220,
        "y": 1400,
        "wires": [
            [
                "f2fbf57365769c2d",
                "8941479643260a23",
                "0b480948b60d645d",
                "ec8b2fdc37713423"
            ],
            [
                "da663fa50d94c63c"
            ]
        ]
    },
    {
        "id": "31a51f2f45d84be6",
        "type": "link out",
        "z": "e437f2f44495aeb9",
        "g": "554f91ffdbfbfc68",
        "name": "trame3-out",
        "mode": "link",
        "links": [
            "8a804f30a6c6f20f"
        ],
        "x": 365,
        "y": 860,
        "wires": []
    },
    {
        "id": "8a804f30a6c6f20f",
        "type": "link in",
        "z": "e437f2f44495aeb9",
        "g": "6ec0cd904988f0ff",
        "name": "trame3-in",
        "links": [
            "31a51f2f45d84be6"
        ],
        "x": 95,
        "y": 1400,
        "wires": [
            [
                "27c1423f6c9aada6",
                "6b802ba3d2772465"
            ]
        ]
    },
    {
        "id": "5f01f1a8c86201ad",
        "type": "link out",
        "z": "e437f2f44495aeb9",
        "g": "554f91ffdbfbfc68",
        "name": "trame2-out",
        "mode": "link",
        "links": [
            "23a113423703427c"
        ],
        "x": 365,
        "y": 820,
        "wires": []
    },
    {
        "id": "23a113423703427c",
        "type": "link in",
        "z": "e437f2f44495aeb9",
        "g": "f8bc911f73526834",
        "name": "trame2-in",
        "links": [
            "5f01f1a8c86201ad"
        ],
        "x": 85,
        "y": 1180,
        "wires": [
            [
                "9b9034a8b404274d",
                "3775966e34cef950"
            ]
        ]
    },
    {
        "id": "b8914948fca3fdf5",
        "type": "function",
        "z": "e437f2f44495aeb9",
        "g": "c5358579966ea944",
        "name": "buffer to hexa",
        "func": "// Dans un nœud function\nmsg.payload = Buffer.from(msg.payload).toString('hex');\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 160,
        "y": 1580,
        "wires": [
            [
                "019f592e42a7a3e6"
            ]
        ]
    },
    {
        "id": "019f592e42a7a3e6",
        "type": "debug",
        "z": "e437f2f44495aeb9",
        "g": "c5358579966ea944",
        "name": "debug 2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 320,
        "y": 1580,
        "wires": []
    },
    {
        "id": "3775966e34cef950",
        "type": "function",
        "z": "e437f2f44495aeb9",
        "g": "f8bc911f73526834",
        "name": "Vérifie Trame 2",
        "func": "//const expectedHeader = [0x55, 0xAA, 0xEB, 0x90, 0x01];\nconst expectedHeader = [0x55, 0xAA, 0xEB, 0x90, 0x01];\n\n// Vérifie si le buffer commence par la séquence attendue\nfunction checkHeader(buffer) {\n    if (buffer.length < expectedHeader.length) return false;\n    \n    for (let i = 0; i < expectedHeader.length; i++) {\n        if (buffer[i] !== expectedHeader[i]) return false;\n    }\n    return true;\n}\n\nif (checkHeader(msg.payload)) {\n    return msg;\n} else {\n    return null; // Ne transmet pas le message si l'en-tête ne correspond pas\n}",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 210,
        "y": 1200,
        "wires": [
            [
                "6ddc941d8fc09996"
            ],
            []
        ]
    },
    {
        "id": "58ef70ea1beab86a",
        "type": "link out",
        "z": "e437f2f44495aeb9",
        "g": "554f91ffdbfbfc68",
        "name": "trame1-out",
        "mode": "link",
        "links": [
            "1c533d251a90da41"
        ],
        "x": 365,
        "y": 780,
        "wires": []
    },
    {
        "id": "1c533d251a90da41",
        "type": "link in",
        "z": "e437f2f44495aeb9",
        "g": "8d42d70f697c6b57",
        "name": "trame1-in",
        "links": [
            "58ef70ea1beab86a"
        ],
        "x": 85,
        "y": 1040,
        "wires": [
            [
                "1967c318d9216a54",
                "20642f46d6ad8f27"
            ]
        ]
    },
    {
        "id": "1967c318d9216a54",
        "type": "function",
        "z": "e437f2f44495aeb9",
        "g": "8d42d70f697c6b57",
        "name": "Vérifie Trame 1",
        "func": "const expectedHeader = [0x55, 0xAA, 0xEB, 0x90];\n\n// Vérifie si le buffer commence par la séquence attendue\nfunction checkHeader(buffer) {\n    if (buffer.length < expectedHeader.length) return false;\n    \n    for (let i = 0; i < expectedHeader.length; i++) {\n        if (buffer[i] !== expectedHeader[i]) return false;\n    }\n    return true;\n}\n\nif (checkHeader(msg.payload)) {\n    return msg;\n} else {\n    return null; // Ne transmet pas le message si l'en-tête ne correspond pas\n}",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 220,
        "y": 1040,
        "wires": [
            [
                "780b5889dad59c22"
            ],
            []
        ]
    },
    {
        "id": "9c7f34f8f23e6ba9",
        "type": "debug",
        "z": "e437f2f44495aeb9",
        "g": "efcb27eee8e0e602",
        "name": "msg.status",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "status",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 460,
        "y": 120,
        "wires": []
    },
    {
        "id": "a57eec1d77cfb03e",
        "type": "debug",
        "z": "e437f2f44495aeb9",
        "g": "6ec0cd904988f0ff",
        "name": "debug 5",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 580,
        "y": 1440,
        "wires": []
    },
    {
        "id": "3c4c2b0ec268a41f",
        "type": "debug",
        "z": "e437f2f44495aeb9",
        "g": "6ec0cd904988f0ff",
        "name": "debug 8",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 780,
        "y": 1440,
        "wires": []
    },
    {
        "id": "5ee439284855bf6e",
        "type": "mqtt out",
        "z": "e437f2f44495aeb9",
        "g": "6ec0cd904988f0ff",
        "name": "Onduleur",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 780,
        "y": 1400,
        "wires": []
    },
    {
        "id": "55ea9406b130a136",
        "type": "debug",
        "z": "e437f2f44495aeb9",
        "g": "8d42d70f697c6b57",
        "name": "MQTT",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 769,
        "y": 1040,
        "wires": []
    },
    {
        "id": "1a9a7bee6083f2b1",
        "type": "mqtt out",
        "z": "e437f2f44495aeb9",
        "g": "8d42d70f697c6b57",
        "name": "Onduleur",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 779,
        "y": 1000,
        "wires": []
    },
    {
        "id": "da663fa50d94c63c",
        "type": "debug",
        "z": "e437f2f44495aeb9",
        "g": "6ec0cd904988f0ff",
        "name": "discard",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 400,
        "y": 1440,
        "wires": []
    },
    {
        "id": "6ddc941d8fc09996",
        "type": "buffer-parser",
        "z": "e437f2f44495aeb9",
        "g": "f8bc911f73526834",
        "name": "Trame 2",
        "data": "payload",
        "dataType": "msg",
        "specification": "spec",
        "specificationType": "ui",
        "items": [
            {
                "type": "int32le",
                "name": "smart_sleep_voltage_V",
                "offset": 6,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_voltage_undervoltage_protection_V",
                "offset": 10,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_voltage_undervoltage_recovery_V",
                "offset": 14,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_voltage_overvoltage_protection_V",
                "offset": 18,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_voltage_overvoltage_recovery_V",
                "offset": 22,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "balance_trigger_voltage_V",
                "offset": 26,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_soc100_voltage_V",
                "offset": 30,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_soc0_voltage_V",
                "offset": 34,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_request_charge_voltage_V",
                "offset": 38,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_request_float_voltage_V",
                "offset": 42,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "power_off_voltage_V",
                "offset": 46,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "max_charge_current_A",
                "offset": 50,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_overcurrent_protection_delay_S",
                "offset": 54,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_overcurrent_protection_recovery_time_S",
                "offset": 58,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "max_discharge_current_S",
                "offset": 62,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "discharge_overcurrent_protection_delay_S",
                "offset": 66,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "discharge_overcurrent_protection_recovery_time_S",
                "offset": 70,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "short_circuit_protection_recovery_time_S",
                "offset": 74,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "max_balance_current_A",
                "offset": 78,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_overtemperature_protection_T",
                "offset": 82,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_overtemperature_protection_recovery_T",
                "offset": 86,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "discharge_overtemperature_protection_T",
                "offset": 90,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "discharge_overtemperature_protection_recovery_T",
                "offset": 94,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_undertemperature_protection_T",
                "offset": 98,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "charge_undertemperature_protection_recovery_T",
                "offset": 102,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "power_tube_overtemperature_protection_T",
                "offset": 106,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "power_tube_overtemperature_protection_recovery_T",
                "offset": 110,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "cell_count_N",
                "offset": 114,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "charging_switch_B",
                "offset": 118,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "discharging_switch_B",
                "offset": 122,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "balance_switch_B",
                "offset": 126,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "total_battery_capacity_Ah",
                "offset": 130,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "short_circuit_protection_delay_S",
                "offset": 134,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "balance_starting_voltage_V",
                "offset": 138,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Connexion_wire_resistance_1_R",
                "offset": 158,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": " Device_address_N",
                "offset": 270,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "display_always_on_switch_B",
                "offset": 282,
                "length": 1,
                "offsetbit": 4,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "smart_sleep_switch_B",
                "offset": 282,
                "length": 1,
                "offsetbit": 7,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "disable_pcl_module_switch_B",
                "offset": 282,
                "length": 1,
                "offsetbit": 8,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "timed_stored_data_switch_B",
                "offset": 283,
                "length": 1,
                "offsetbit": 1,
                "scale": "1",
                "mask": ""
            }
        ],
        "swap1": "",
        "swap2": "",
        "swap3": "",
        "swap1Type": "swap",
        "swap2Type": "swap",
        "swap3Type": "swap",
        "msgProperty": "payload",
        "msgPropertyType": "str",
        "resultType": "keyvalue",
        "resultTypeType": "return",
        "multipleResult": false,
        "fanOutMultipleResult": false,
        "setTopic": true,
        "outputs": 1,
        "x": 390,
        "y": 1200,
        "wires": [
            [
                "e6d9f6f2ecbfa12e",
                "2dca953e4985c420"
            ]
        ]
    },
    {
        "id": "64590862f9d3a361",
        "type": "function",
        "z": "e437f2f44495aeb9",
        "g": "6ec0cd904988f0ff",
        "name": "To MQTT",
        "func": "// Récupération de l'ID d'esclave depuis les variables globales\nconst slaveId = global.get(\"slaveAddress-Trame3\") || 0x01; // Valeur par défaut si non définie\n\n// Conversion de la valeur hexadécimale en décimal si nécessaire\nconst slaveIdNumber = typeof slaveId === 'string' ? parseInt(slaveId, 16) : slaveId;\n\nvar payload = msg.payload;\nvar baseTopic = \"BMS_\" + slaveIdNumber;\nvar discoveryPrefix = \"homeassistant/sensor\";\nvar deviceName = \"BMS_\" + slaveIdNumber;\nvar deviceID = \"BMS_\" + slaveIdNumber + \"_device\";\nvar dynamicDataTopic = `${baseTopic}/donnees_dynamiques`;\n\nvar topics = {};\nvar discoveryMsgs = [];\nvar dynamicData = {};\n\n// Extraire uniquement les tensions des cellules\nvar cellVoltages = [];\nvar cellKeys = [];\nfor (var key in payload) {\n    // Ne prendre que les clés qui contiennent \"Cell\" et \"volt\" et finissent par \"_V\"\n    if (key.includes(\"Cell_\") && key.includes(\"volt\") && key.endsWith(\"_V\")) {\n        let voltage = Number(payload[key]);\n        if (!isNaN(voltage)) {\n            cellVoltages.push(voltage);\n            cellKeys.push(key);\n        }\n    }\n}\n\n// Calculs des statistiques des cellules\nif (cellVoltages.length > 0) {\n    // Calcul de la moyenne\n    var cellAvgVolt = cellVoltages.reduce((sum, voltage) => sum + voltage, 0) / cellVoltages.length;\n    \n    // Trouve la tension max et min\n    var cellMaxVolt = Math.max(...cellVoltages);\n    var cellMinVolt = Math.min(...cellVoltages);\n    \n    // Calcul du delta\n    var cellDeltaVolt = cellMaxVolt - cellMinVolt;\n    \n    // Trouve les index des cellules\n    var maxVoltIndex = cellKeys[cellVoltages.indexOf(cellMaxVolt)].match(/Cell_(\\d+)/)[1];\n    var minVoltIndex = cellKeys[cellVoltages.indexOf(cellMinVolt)].match(/Cell_(\\d+)/)[1];\n    \n    // Ajoute les valeurs calculées au payload\n    payload[\"cell_voltage_average_V\"] = parseFloat(cellAvgVolt.toFixed(3));\n    payload[\"cell_voltage_delta_V\"] = parseFloat(cellDeltaVolt.toFixed(3));\n    payload[\"cell_voltage_max_number_N\"] = parseInt(maxVoltIndex);\n    payload[\"cell_voltage_min_number_N\"] = parseInt(minVoltIndex);\n}\n\n// Ajouter toutes les valeurs dynamiquement\nfor (var key in payload) {\n    var cleanKey = key.replace(/_[A-Z]+$/, \"\"); // Supprime l'underscore et l'unité\n    var sensorTopic = `${baseTopic}/${cleanKey}`;\n    topics[sensorTopic] = payload[key];\n    dynamicData[cleanKey] = payload[key];\n    \n    var configTopic = `${discoveryPrefix}/${deviceID}_${cleanKey}/config`;\n    var configPayload = {\n        name: cleanKey,\n        unique_id: `${deviceID}_${cleanKey}`,\n        state_topic: sensorTopic,\n        unit_of_measurement: \"\",\n        entity_category: \"diagnostic\",  // Ajoute cette catégorie pour grouper dans \"Live data\"\n        device: {\n            identifiers: [deviceID],\n            name: deviceName,\n            manufacturer: \"Smartphoton-JK-BMS\",\n            model: \"JK_PB2A16S15P\",\n            sw_version: \"1.0.0\"\n        }\n    };\n    \n    // Ajouter des unités de mesure spécifiques\n    if (key.endsWith(\"_V\")) configPayload.unit_of_measurement = \"V\";\n    if (key.endsWith(\"_Ah\")) configPayload.unit_of_measurement = \"Ah\";\n    if (key.endsWith(\"_A\")) configPayload.unit_of_measurement = \"A\";\n    if (key.endsWith(\"_W\")) configPayload.unit_of_measurement = \"W\";\n    if (key.endsWith(\"_T\")) configPayload.unit_of_measurement = \"°C\";\n    if (key.endsWith(\"_R\")) configPayload.unit_of_measurement = \"Ω\";\n    if (key.endsWith(\"_P\")) {\n        configPayload.unit_of_measurement = \"%\";\n        if (key.startsWith(\"SOC\")) {\n            configPayload.device_class = \"battery\";\n        }\n    }\n    if (key.endsWith(\"_S\")) configPayload.unit_of_measurement = \"s\";\n    \n    discoveryMsgs.push({ topic: configTopic, payload: JSON.stringify(configPayload), retain: true });\n}\n\n// Publier les données dynamiques sous un seul topic\ntopics[dynamicDataTopic] = JSON.stringify(dynamicData);\n\nvar outputMsgs = discoveryMsgs;\nfor (var topic in topics) {\n    outputMsgs.push({ topic: topic, payload: topics[topic] });\n}\n\nreturn [outputMsgs];",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 580,
        "y": 1400,
        "wires": [
            [
                "3c4c2b0ec268a41f",
                "5ee439284855bf6e"
            ]
        ]
    },
    {
        "id": "f0baa88edd6cc075",
        "type": "function",
        "z": "e437f2f44495aeb9",
        "g": "8d42d70f697c6b57",
        "name": "To MQTT",
        "func": "// Récupération de l'ID d'esclave depuis les variables globales\nconst slaveId = global.get(\"slaveAddress-Trame1\") || 0x01; // Valeur par défaut si non définie\n\n// Conversion de la valeur hexadécimale en décimal si nécessaire\nconst slaveIdNumber = typeof slaveId === 'string' ? parseInt(slaveId, 16) : slaveId;\n\nvar payload = msg.payload;\nvar baseTopic = \"BMS_\" + slaveIdNumber;\nvar discoveryPrefix = \"homeassistant\";\nvar deviceName = \"BMS_\" + slaveIdNumber;\nvar deviceID = \"BMS_\" + slaveIdNumber + \"_device\";\n\nvar discoveryMsgs = [];\n\n// Ajouter toutes les valeurs dynamiquement\nfor (var key in payload) {\n    var cleanKey = key.replace(/_[A-Z]+$/, \"\").toLowerCase();\n    var sensorTopic = `${baseTopic}/state/${cleanKey}`;  // Simplifié le state_topic\n    \n    var configTopic = `${discoveryPrefix}/sensor/${deviceID}/${cleanKey}/config`;\n    var configPayload = {\n        name: `BMS ${key.replace(/_[A-Z]+$/, \"\").replace(/_/g, \" \")}`,\n        unique_id: `${deviceID}_${cleanKey}`,\n        state_topic: sensorTopic,\n        enabled_by_default: true,\n        device: {\n            identifiers: [deviceID],\n            name: deviceName,\n            manufacturer: \"Smartphoton-JK-BMS\",\n            model: payload.BMS_A || \"JK_PB2A16S15P\",\n            sw_version: payload.SW_N || \"1.0.0\"\n        }\n    };\n\n    // Ajout des unités selon le suffixe\n    if (key.endsWith(\"_S\")) {\n        configPayload.unit_of_measurement = \"s\";\n        configPayload.device_class = \"duration\";\n        configPayload.state_class = \"measurement\";\n    }\n    else if (key.endsWith(\"_N\") && key.includes(\"Time\")) {\n        configPayload.unit_of_measurement = \"s\";\n        configPayload.device_class = \"duration\";\n        configPayload.state_class = \"measurement\";\n    }\n    else if (key.endsWith(\"_N\") && !key.includes(\"Serial\")) {\n        configPayload.state_class = \"measurement\";\n    }\n\n    // Gestion des icônes\n    if (key.includes(\"Password\")) {\n        configPayload.icon = \"mdi:form-textbox-password\";\n    } else if (key.includes(\"Serial\")) {\n        configPayload.icon = \"mdi:barcode\";\n    } else if (key.includes(\"protocol\")) {\n        configPayload.icon = \"mdi:protocol\";\n    } else if (key.includes(\"version\") || key.includes(\"SW\") || key.includes(\"FW\")) {\n        configPayload.icon = \"mdi:numeric-10\";\n    } else if (key.includes(\"Uptime\")) {\n        configPayload.icon = \"mdi:timer-outline\";\n        configPayload.device_class = \"duration\";\n    } else if (key.includes(\"date\")) {\n        configPayload.icon = \"mdi:calendar\";\n    }\n\n    // Ajouter le message de configuration\n    discoveryMsgs.push({\n        topic: configTopic,\n        payload: JSON.stringify(configPayload),\n        retain: true\n    });\n\n    // Ajouter le message d'état\n    discoveryMsgs.push({\n        topic: sensorTopic,\n        payload: payload[key],\n        retain: true\n    });\n}\n\nreturn [discoveryMsgs];",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 579,
        "y": 1000,
        "wires": [
            [
                "55ea9406b130a136",
                "1a9a7bee6083f2b1"
            ]
        ]
    },
    {
        "id": "2dca953e4985c420",
        "type": "function",
        "z": "e437f2f44495aeb9",
        "g": "f8bc911f73526834",
        "name": "To MQTT",
        "func": "// Récupération de l'ID d'esclave depuis les variables globales\nconst slaveId = global.get(\"slaveAddress-Trame2\") || 0x01; // Valeur par défaut si non définie\n\n// Conversion de la valeur hexadécimale en décimal si nécessaire\nconst slaveIdNumber = typeof slaveId === 'string' ? parseInt(slaveId, 16) : slaveId;\n\nvar payload = msg.payload;\nvar baseTopic = \"BMS_\" + slaveIdNumber;\nvar discoveryPrefix = \"homeassistant\";\nvar deviceName = \"BMS_\" + slaveIdNumber;\nvar deviceID = \"BMS_\" + slaveIdNumber + \"_device\";\n\nvar discoveryMsgs = [];\n\n// Fonction de conversion des booléens\nfunction formatBoolean(value) {\n    if (typeof value === 'boolean') {\n        return value ? 'True' : 'False';\n    }\n    if (typeof value === 'string') {\n        const lowerVal = value.toLowerCase();\n        return lowerVal === 'true' ? 'True' : lowerVal === 'false' ? 'False' : value;\n    }\n    return value;\n}\n\nfunction createConfigPayload(key, value, commandTopic) {\n    var cleanKey = key.replace(/_[A-Z]+$/, \"\").toLowerCase();\n    var entityType = \"number\";\n    \n    if (key.endsWith(\"_B\")) {\n        entityType = \"switch\";\n    }\n    \n    var configTopic = `${discoveryPrefix}/${entityType}/${deviceID}/${cleanKey}/config`;\n    \n    var configPayload = {\n        name: `BMS ${key.replace(/_[A-Z]+$/, \"\").replace(/_/g, \" \")}`,\n        unique_id: `${deviceID}_${cleanKey}`,\n        state_topic: `${baseTopic}/control/${cleanKey}/state`,\n        command_topic: `${baseTopic}/control/${cleanKey}/set`,\n        entity_category: \"config\",\n        device: {\n            identifiers: [deviceID],\n            name: deviceName,\n            manufacturer: \"Smartphoton-JK-BMS\",\n            model: payload.BMS_A || \"JK_PB2A16S15P\",\n            sw_version: \"1.0.0\"\n        }\n    };\n\n    if (entityType === \"number\") {\n        configPayload.mode = \"box\";\n        \n        if (key.endsWith(\"_V\")) {\n            configPayload.unit_of_measurement = \"V\";\n            configPayload.min = 0;\n            configPayload.max = 5;\n            configPayload.step = 0.01;\n        }\n    \n        // ... (autres configurations number inchangées)\n    \n    } else if (entityType === \"switch\") {\n        // Modification clé ici pour Home Assistant\n        configPayload.payload_on = \"True\";\n        configPayload.payload_off = \"False\";\n        configPayload.state_on = \"True\";\n        configPayload.state_off = \"False\";\n    }\n\n    return {\n        topic: configTopic,\n        payload: JSON.stringify(configPayload),\n        retain: true\n    };\n}\n\nfor (var key in payload) {\n    discoveryMsgs.push(createConfigPayload(key, payload[key]));\n    \n    var cleanKey = key.replace(/_[A-Z]+$/, \"\").toLowerCase();\n    var formattedValue = formatBoolean(payload[key]);\n    \n    discoveryMsgs.push({\n        topic: `${baseTopic}/control/${cleanKey}/state`,\n        payload: formattedValue,\n        retain: true\n    });\n}\n\nreturn [discoveryMsgs];",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 580,
        "y": 1160,
        "wires": [
            [
                "e8ed5df6828f9f8f",
                "08b1d0bb4085f9c1"
            ]
        ]
    },
    {
        "id": "e8ed5df6828f9f8f",
        "type": "debug",
        "z": "e437f2f44495aeb9",
        "g": "f8bc911f73526834",
        "name": "debug 15",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 780,
        "y": 1200,
        "wires": []
    },
    {
        "id": "08b1d0bb4085f9c1",
        "type": "mqtt out",
        "z": "e437f2f44495aeb9",
        "g": "f8bc911f73526834",
        "name": "Onduleur",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 780,
        "y": 1160,
        "wires": []
    },
    {
        "id": "42b39467dd4b0da2",
        "type": "link in",
        "z": "e437f2f44495aeb9",
        "g": "6b5bd0bba4a26d99",
        "name": "Relecture-Trame-2-in",
        "links": [],
        "x": 215,
        "y": 440,
        "wires": [
            [
                "020c19662d54639e"
            ]
        ]
    },
    {
        "id": "bb5385e5fa6e8f58",
        "type": "link out",
        "z": "e437f2f44495aeb9",
        "g": "554f91ffdbfbfc68",
        "name": "Autres-topics-out",
        "mode": "link",
        "links": [
            "63b5b654057c4381"
        ],
        "x": 365,
        "y": 900,
        "wires": []
    },
    {
        "id": "33128f050c7a6d40",
        "type": "delay",
        "z": "e437f2f44495aeb9",
        "g": "6b5bd0bba4a26d99",
        "name": "",
        "pauseType": "delay",
        "timeout": "500",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 270,
        "y": 240,
        "wires": [
            [
                "bdc67ff77d388fd4"
            ]
        ]
    },
    {
        "id": "bdc67ff77d388fd4",
        "type": "function",
        "z": "e437f2f44495aeb9",
        "g": "6b5bd0bba4a26d99",
        "name": "Loop Modbus adresse",
        "func": "let currentAddress = global.get(\"slaveAddress-Trame1\") || 1; // Valeur par défaut : 1\nlet Number_of_BMS = global.get(\"nb_jkbms\") || 1; // Valeur par défaut : 1\n\n// Incrémenter l'adresse, revenir à 1 après 8\ncurrentAddress = currentAddress >= Number_of_BMS ? 1 : currentAddress + 1;\n\nglobal.set(\"slaveAddress-Trame1\", currentAddress);\n\n//node.warn(`Prochaine adresse esclave Trame1 : ${currentAddress}`);\nmsg.payload = currentAddress;\nreturn msg; // Continuer vers le prochain nœud\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 460,
        "y": 240,
        "wires": [
            [
                "612e601399a564be"
            ]
        ]
    },
    {
        "id": "612e601399a564be",
        "type": "debug",
        "z": "e437f2f44495aeb9",
        "g": "6b5bd0bba4a26d99",
        "name": "Trame 1",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 640,
        "y": 240,
        "wires": []
    },
    {
        "id": "47c0ebe01c623676",
        "type": "delay",
        "z": "e437f2f44495aeb9",
        "g": "6b5bd0bba4a26d99",
        "name": "",
        "pauseType": "delay",
        "timeout": "500",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 270,
        "y": 360,
        "wires": [
            [
                "c15a66e8901ebb92"
            ]
        ]
    },
    {
        "id": "c15a66e8901ebb92",
        "type": "function",
        "z": "e437f2f44495aeb9",
        "g": "6b5bd0bba4a26d99",
        "name": "Loop Modbus adresse",
        "func": "let currentAddress = global.get(\"slaveAddress-Trame2\") || 1; // Valeur par défaut : 1\nlet Number_of_BMS = global.get(\"nb_jkbms\") || 1; // Valeur par défaut : 1\n\n// Incrémenter l'adresse, revenir à 1 après 8\ncurrentAddress = currentAddress >= Number_of_BMS ? 1 : currentAddress + 1;\n\nglobal.set(\"slaveAddress-Trame2\", currentAddress);\n\n//node.warn(`Prochaine adresse esclave Trame2 : ${currentAddress}`);\nmsg.payload = currentAddress;\nreturn msg; // Continuer vers le prochain nœud\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 460,
        "y": 360,
        "wires": [
            [
                "57c7fc5e6af725a8"
            ]
        ]
    },
    {
        "id": "57c7fc5e6af725a8",
        "type": "debug",
        "z": "e437f2f44495aeb9",
        "g": "6b5bd0bba4a26d99",
        "name": "Trame 2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 640,
        "y": 360,
        "wires": []
    },
    {
        "id": "588a28b52bca3c97",
        "type": "delay",
        "z": "e437f2f44495aeb9",
        "g": "6b5bd0bba4a26d99",
        "name": "",
        "pauseType": "delay",
        "timeout": "500",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 270,
        "y": 500,
        "wires": [
            [
                "6aaaa309d4c3a50c"
            ]
        ]
    },
    {
        "id": "6aaaa309d4c3a50c",
        "type": "function",
        "z": "e437f2f44495aeb9",
        "g": "6b5bd0bba4a26d99",
        "name": "Loop Modbus adresse",
        "func": "let currentAddress = global.get(\"slaveAddress-Trame3\") || 1; // Valeur par défaut : 1\nlet Number_of_BMS = global.get(\"nb_jkbms\") || 1; // Valeur par défaut : 1\n\n// Incrémenter l'adresse, revenir à 1 après 8\ncurrentAddress = currentAddress >= Number_of_BMS ? 1 : currentAddress + 1;\n\nglobal.set(\"slaveAddress-Trame3\", currentAddress);\n\n// node.warn(`Prochaine adresse esclave Trame3 : ${currentAddress}`);\nmsg.payload = currentAddress;\nreturn msg; // Continuer vers le prochain nœud\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 460,
        "y": 500,
        "wires": [
            [
                "307f2a35426531d7"
            ]
        ]
    },
    {
        "id": "307f2a35426531d7",
        "type": "debug",
        "z": "e437f2f44495aeb9",
        "g": "6b5bd0bba4a26d99",
        "name": "Trame 3",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 640,
        "y": 500,
        "wires": []
    },
    {
        "id": "f2fbf57365769c2d",
        "type": "buffer-parser",
        "z": "e437f2f44495aeb9",
        "g": "6ec0cd904988f0ff",
        "name": "Trame 3",
        "data": "payload",
        "dataType": "msg",
        "specification": "spec",
        "specificationType": "ui",
        "items": [
            {
                "type": "uint16le",
                "name": "Cell_1_volt_V",
                "offset": 6,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_2_volt_V",
                "offset": 8,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_3_volt_V",
                "offset": 10,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_4_volt_V",
                "offset": 12,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_5_volt_V",
                "offset": 14,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_6_volt_V",
                "offset": 16,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_7_volt_V",
                "offset": 18,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_8_volt_V",
                "offset": 20,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_9_volt_V",
                "offset": 22,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_10_volt_V",
                "offset": 24,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_11_volt_V",
                "offset": 26,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_12_volt_V",
                "offset": 28,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_13_volt_V",
                "offset": 30,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_14_volt_V",
                "offset": 32,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_15_volt_V",
                "offset": 34,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Cell_16_volt_V",
                "offset": 36,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_1_ohm_R",
                "offset": 80,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_2_ohm_R",
                "offset": 82,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_3_ohm_R",
                "offset": 84,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_4_ohm_R",
                "offset": 86,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_5_ohm_R",
                "offset": 88,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_6_ohm_R",
                "offset": 90,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_7_ohm_R",
                "offset": 92,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_8_ohm_R",
                "offset": 94,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_9_ohm_R",
                "offset": 96,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_10_ohm_R",
                "offset": 98,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_11_ohm_R",
                "offset": 100,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_12_ohm_R",
                "offset": 102,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_13_ohm_R",
                "offset": 104,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_14_ohm_R",
                "offset": 106,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_15_ohm_R",
                "offset": 108,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Cell_16_ohm_R",
                "offset": 110,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Mos_temp_T",
                "offset": 144,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "uint32le",
                "name": "Puissance_Totale_W",
                "offset": 154,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Courant_total_A",
                "offset": 158,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Sonde_1_temp_T",
                "offset": 162,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Sonde_2_temp_T",
                "offset": 164,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Balance_courant_A",
                "offset": 170,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "byte",
                "name": "Balance_Action_B",
                "offset": 172,
                "length": 1,
                "offsetbit": 0,
                "scale": "/100",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "SOC_pourcentage_P",
                "offset": 173,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Capacite_restante_Ah",
                "offset": 174,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Capacite_batterie_Ah",
                "offset": 178,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Nombre_Cycle_N",
                "offset": 182,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "int32le",
                "name": "Cycle_Capacite_Ah",
                "offset": 186,
                "length": 1,
                "offsetbit": 0,
                "scale": "/1000",
                "mask": ""
            },
            {
                "type": "uint8",
                "name": "SOH_pourcentage_P",
                "offset": 190,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint32le",
                "name": "Total_runtime_S",
                "offset": 194,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "byte",
                "name": "Switch_Charge_B",
                "offset": 198,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "byte",
                "name": "Switch_Decharge_B",
                "offset": 199,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "byte",
                "name": "Switch_Balance_B",
                "offset": 200,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "uint16le",
                "name": "Tension_Totale_volt_V",
                "offset": 234,
                "length": 1,
                "offsetbit": 0,
                "scale": "/100",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Sonde_3_temp_T",
                "offset": 254,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            },
            {
                "type": "int16le",
                "name": "Sonde_4_temp_T",
                "offset": 258,
                "length": 1,
                "offsetbit": 0,
                "scale": "/10",
                "mask": ""
            }
        ],
        "swap1": "",
        "swap2": "",
        "swap3": "",
        "swap1Type": "swap",
        "swap2Type": "swap",
        "swap3Type": "swap",
        "msgProperty": "payload",
        "msgPropertyType": "str",
        "resultType": "keyvalue",
        "resultTypeType": "return",
        "multipleResult": false,
        "fanOutMultipleResult": false,
        "setTopic": true,
        "outputs": 1,
        "x": 420,
        "y": 1400,
        "wires": [
            [
                "64590862f9d3a361",
                "a57eec1d77cfb03e"
            ]
        ]
    },
    {
        "id": "8941479643260a23",
        "type": "buffer-parser",
        "z": "e437f2f44495aeb9",
        "g": "554f91ffdbfbfc68",
        "name": "Erreurs codes",
        "data": "payload",
        "dataType": "msg",
        "specification": "spec",
        "specificationType": "ui",
        "items": [
            {
                "type": "uint16be",
                "name": "errors-codes",
                "offset": 166,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "bit4",
                "offset": 166,
                "length": 1,
                "offsetbit": 4,
                "scale": "1",
                "mask": ""
            }
        ],
        "swap1": "",
        "swap2": "",
        "swap3": "",
        "swap1Type": "swap",
        "swap2Type": "swap",
        "swap3Type": "swap",
        "msgProperty": "payload",
        "msgPropertyType": "str",
        "resultType": "keyvalue",
        "resultTypeType": "return",
        "multipleResult": false,
        "fanOutMultipleResult": false,
        "setTopic": true,
        "outputs": 1,
        "x": 600,
        "y": 1540,
        "wires": [
            [
                "dc8be2eb9f379046"
            ]
        ]
    },
    {
        "id": "dc8be2eb9f379046",
        "type": "debug",
        "z": "e437f2f44495aeb9",
        "g": "554f91ffdbfbfc68",
        "name": "debug 22",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 780,
        "y": 1540,
        "wires": []
    },
    {
        "id": "0b480948b60d645d",
        "type": "function",
        "z": "e437f2f44495aeb9",
        "g": "6ec0cd904988f0ff",
        "name": "Gestion des codes d'erreurs",
        "func": "// Liste des erreurs possibles\nconst errorList = [\n    \"Charge Overtemperature\",               // bit 0\n    \"Charge Undertemperature\",              // bit 1\n    \"Coprocessor communication error\",      // bit 2\n    \"Cell Undervoltage\",                    // bit 3\n    \"Battery pack undervoltage\",            // bit 4\n    \"Discharge overcurrent\",                // bit 5\n    \"Discharge short circuit\",              // bit 6\n    \"Discharge overtemperature\",            // bit 7\n    \"Wire resistance\",                      // bit 8\n    \"Mosfet overtemperature\",               // bit 9\n    \"Cell count is not equal to settings\",  // bit 10\n    \"Current sensor anomaly\",               // bit 11\n    \"Cell Overvoltage\",                     // bit 12\n    \"Battery pack overvoltage\",             // bit 13\n    \"Charge overcurrent protection\",        // bit 14\n    \"Charge short circuit\"                  // bit 15\n];\n\n// Récupérer le buffer\nconst buffer = msg.payload;\n\n// Vérifier que le buffer est suffisamment grand\nif (buffer.length <= 167) {\n    msg.payload = \"Buffer trop petit pour extraire le code d'erreur\";\n    return msg;\n}\n\n// Extraire la valeur d'erreur à l'offset 166 (en supposant Big Endian - BE)\nconst errorCode = (buffer[166] << 8) | buffer[167];\n\n// Initialiser un tableau pour stocker les erreurs détectées\nconst activeErrors = [];\n\n// Vérifier chaque bit d'erreur\nfor (let i = 0; i < errorList.length; i++) {\n    // Si le bit correspondant est activé (1), ajouter l'erreur à la liste\n    if (errorCode & (1 << i)) {\n        activeErrors.push(errorList[i]);\n    }\n}\n\n// Si aucune erreur n'est détectée\nif (activeErrors.length === 0) {\n    msg.payload = \"Aucune erreur détectée\";\n} else {\n    // Joindre les erreurs avec des virgules\n    msg.payload = activeErrors.join(\", \");\n}\n\n// Ajouter également le code d'erreur brut pour référence\nmsg.errorCode = errorCode;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 589,
        "y": 1360,
        "wires": [
            [
                "8ccdcf5d7075d4c7"
            ]
        ]
    },
    {
        "id": "8ccdcf5d7075d4c7",
        "type": "debug",
        "z": "e437f2f44495aeb9",
        "g": "6ec0cd904988f0ff",
        "name": "debug 26",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 789,
        "y": 1360,
        "wires": []
    },
    {
        "id": "653bf583b3edc452",
        "type": "function",
        "z": "e437f2f44495aeb9",
        "g": "6ec0cd904988f0ff",
        "name": "function 2",
        "func": "// Valeur à tester : bit 12 + bit 4 → 0x1010 = 4112\nlet testValue = 0x0001;\n\n// Création d'un buffer vide avec au moins 168 octets\nlet buffer = Buffer.alloc(168);\n\n// Insère testValue à l’offset 166 (little endian)\nbuffer.writeUInt16LE(testValue, 166);\n\nmsg.payload = buffer;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 1340,
        "wires": [
            [
                "0b480948b60d645d"
            ]
        ]
    },
    {
        "id": "55785a4118180011",
        "type": "inject",
        "z": "e437f2f44495aeb9",
        "g": "6ec0cd904988f0ff",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 230,
        "y": 1340,
        "wires": [
            [
                "653bf583b3edc452"
            ]
        ]
    },
    {
        "id": "ec8b2fdc37713423",
        "type": "debug",
        "z": "e437f2f44495aeb9",
        "g": "6ec0cd904988f0ff",
        "name": "debug 27",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 550,
        "y": 1320,
        "wires": []
    },
    {
        "id": "45e89eb282d2510b",
        "type": "inject",
        "z": "e437f2f44495aeb9",
        "g": "6b5bd0bba4a26d99",
        "name": "Trame 1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "host",
                "v": "gateway_ip",
                "vt": "global"
            },
            {
                "p": "port",
                "v": "gateway_port",
                "vt": "global"
            }
        ],
        "repeat": "180",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "",
        "payload": "1",
        "payloadType": "num",
        "x": 120,
        "y": 280,
        "wires": [
            [
                "33128f050c7a6d40",
                "48962018a6c0050f"
            ]
        ]
    },
    {
        "id": "cc5072db2fb56b16",
        "type": "inject",
        "z": "e437f2f44495aeb9",
        "g": "6b5bd0bba4a26d99",
        "name": "Trame 2",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "host",
                "v": "gateway_ip",
                "vt": "global"
            },
            {
                "p": "port",
                "v": "gateway_port",
                "vt": "global"
            }
        ],
        "repeat": "120",
        "crontab": "",
        "once": true,
        "onceDelay": "1.5",
        "topic": "",
        "payload": "01 10 16 20 00 01 02 00 00 D6 F1",
        "payloadType": "str",
        "x": 120,
        "y": 400,
        "wires": [
            [
                "020c19662d54639e",
                "47c0ebe01c623676"
            ]
        ]
    },
    {
        "id": "a6457f1b4018e210",
        "type": "inject",
        "z": "e437f2f44495aeb9",
        "g": "6b5bd0bba4a26d99",
        "name": "Trame 3",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "host",
                "v": "gateway_ip",
                "vt": "global"
            },
            {
                "p": "port",
                "v": "gateway_port",
                "vt": "global"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "",
        "payload": "1",
        "payloadType": "num",
        "x": 120,
        "y": 540,
        "wires": [
            [
                "prepare_command",
                "588a28b52bca3c97"
            ]
        ]
    },
    {
        "id": "fb941bfb8f075284",
        "type": "inject",
        "z": "e437f2f44495aeb9",
        "g": "1c9e2e84f7764473",
        "name": "GW IP",
        "props": [
            {
                "p": "host",
                "v": "gateway_ip",
                "vt": "global"
            },
            {
                "p": "port",
                "v": "gateway_port",
                "vt": "global"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 710,
        "y": 80,
        "wires": [
            [
                "374bbe6e8c64a12a"
            ]
        ]
    },
    {
        "id": "374bbe6e8c64a12a",
        "type": "tcp request",
        "z": "e437f2f44495aeb9",
        "g": "1c9e2e84f7764473",
        "name": "",
        "server": "",
        "port": "",
        "out": "time",
        "ret": "buffer",
        "splitc": "200",
        "newline": "",
        "trim": false,
        "tls": "",
        "x": 850,
        "y": 120,
        "wires": [
            [
                "710b79fc70fe4146",
                "d132c36160191dc5"
            ]
        ]
    },
    {
        "id": "710b79fc70fe4146",
        "type": "debug",
        "z": "e437f2f44495aeb9",
        "g": "1c9e2e84f7764473",
        "name": "TCP debug ",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1010,
        "y": 80,
        "wires": []
    },
    {
        "id": "47904917111ec14c",
        "type": "inject",
        "z": "e437f2f44495aeb9",
        "g": "67d16682a4904961",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 830,
        "y": 640,
        "wires": [
            [
                "8d56499e5fd78d16"
            ]
        ]
    },
    {
        "id": "8d56499e5fd78d16",
        "type": "change",
        "z": "e437f2f44495aeb9",
        "g": "67d16682a4904961",
        "name": "GW true ",
        "rules": [
            {
                "t": "set",
                "p": "use_gateway",
                "pt": "global",
                "to": "true",
                "tot": "bool"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1000,
        "y": 640,
        "wires": [
            []
        ]
    },
    {
        "id": "6ba5ab19ca0baf49",
        "type": "inject",
        "z": "e437f2f44495aeb9",
        "g": "67d16682a4904961",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 830,
        "y": 680,
        "wires": [
            [
                "502b03bbf1fa8f13"
            ]
        ]
    },
    {
        "id": "502b03bbf1fa8f13",
        "type": "change",
        "z": "e437f2f44495aeb9",
        "g": "67d16682a4904961",
        "name": "GW false ",
        "rules": [
            {
                "t": "set",
                "p": "use_gateway",
                "pt": "global",
                "to": "false",
                "tot": "bool"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1000,
        "y": 680,
        "wires": [
            []
        ]
    },
    {
        "id": "d132c36160191dc5",
        "type": "link out",
        "z": "e437f2f44495aeb9",
        "g": "1c9e2e84f7764473",
        "name": "Serial Out",
        "mode": "link",
        "links": [
            "87cae6741d4eba43"
        ],
        "x": 955,
        "y": 120,
        "wires": []
    },
    {
        "id": "d3854248aace5164",
        "type": "switch",
        "z": "e437f2f44495aeb9",
        "g": "6b5bd0bba4a26d99",
        "name": "Use Gateway ?",
        "property": "use_gateway",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 840,
        "y": 400,
        "wires": [
            [
                "771632eaf7af77e3"
            ],
            [
                "366518e9212a6b71"
            ]
        ]
    },
    {
        "id": "366518e9212a6b71",
        "type": "link out",
        "z": "e437f2f44495aeb9",
        "g": "6b5bd0bba4a26d99",
        "name": "link out 2",
        "mode": "link",
        "links": [
            "305e1cac13589b0d"
        ],
        "x": 955,
        "y": 420,
        "wires": []
    },
    {
        "id": "722fcc3b75fdf46e",
        "type": "debug",
        "z": "e437f2f44495aeb9",
        "g": "554f91ffdbfbfc68",
        "name": "debug 13",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 180,
        "y": 800,
        "wires": []
    },
    {
        "id": "771632eaf7af77e3",
        "type": "link out",
        "z": "e437f2f44495aeb9",
        "g": "6b5bd0bba4a26d99",
        "name": "link out 3",
        "mode": "link",
        "links": [
            "22c8417438319190"
        ],
        "x": 955,
        "y": 380,
        "wires": []
    },
    {
        "id": "22c8417438319190",
        "type": "link in",
        "z": "e437f2f44495aeb9",
        "g": "1c9e2e84f7764473",
        "name": "link in 1",
        "links": [
            "771632eaf7af77e3"
        ],
        "x": 745,
        "y": 120,
        "wires": [
            [
                "374bbe6e8c64a12a"
            ]
        ]
    },
    {
        "id": "40c53f7ceb572ff5",
        "type": "mqtt out",
        "z": "63221fce04fce9a1",
        "g": "784cf280be8f9617",
        "name": "Onduleur",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "56f7b2737cce493b",
        "x": 520,
        "y": 240,
        "wires": []
    },
    {
        "id": "32422263e19ea107",
        "type": "link out",
        "z": "63221fce04fce9a1",
        "g": "784cf280be8f9617",
        "name": "Relecture-Trame-2-out",
        "mode": "link",
        "links": [
            "42b39467dd4b0da2"
        ],
        "x": 635,
        "y": 200,
        "wires": []
    },
    {
        "id": "c3fe04450213c840",
        "type": "link out",
        "z": "63221fce04fce9a1",
        "g": "784cf280be8f9617",
        "name": "Setup dispatch out",
        "mode": "link",
        "links": [
            "3b2397378287cde4"
        ],
        "x": 295,
        "y": 280,
        "wires": []
    },
    {
        "id": "55b993c941334789",
        "type": "trigger",
        "z": "63221fce04fce9a1",
        "g": "784cf280be8f9617",
        "name": "",
        "op1": "réception",
        "op2": "",
        "op1type": "str",
        "op2type": "payl",
        "duration": "2",
        "extend": true,
        "overrideDelay": false,
        "units": "s",
        "reset": "",
        "bytopic": "topic",
        "topic": "topic",
        "outputs": 2,
        "x": 460,
        "y": 100,
        "wires": [
            [
                "d0a21ee58c34740e"
            ],
            [
                "195a17138b42ee08",
                "b8969f5c95ec96c0"
            ]
        ]
    },
    {
        "id": "d0a21ee58c34740e",
        "type": "debug",
        "z": "63221fce04fce9a1",
        "g": "784cf280be8f9617",
        "name": "debug 17",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 660,
        "y": 80,
        "wires": []
    },
    {
        "id": "195a17138b42ee08",
        "type": "debug",
        "z": "63221fce04fce9a1",
        "g": "784cf280be8f9617",
        "name": "debug 3",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 660,
        "y": 120,
        "wires": []
    },
    {
        "id": "08624c75c29f1a0d",
        "type": "delay",
        "z": "63221fce04fce9a1",
        "g": "784cf280be8f9617",
        "name": "",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 340,
        "y": 200,
        "wires": [
            [
                "40c53f7ceb572ff5",
                "70d583469e139f77"
            ]
        ]
    },
    {
        "id": "70d583469e139f77",
        "type": "change",
        "z": "63221fce04fce9a1",
        "g": "784cf280be8f9617",
        "name": "re-lecture",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "re-lecture",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 520,
        "y": 200,
        "wires": [
            [
                "32422263e19ea107"
            ]
        ]
    },
    {
        "id": "c827a1a690486903",
        "type": "debug",
        "z": "63221fce04fce9a1",
        "g": "784cf280be8f9617",
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 340,
        "y": 240,
        "wires": []
    },
    {
        "id": "e5a60eb34250469e",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write balance starting voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.42)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en valeur entière (échelle 1/1000)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x84,                           // Register address low byte (0x84)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        (voltageValue >> 24) & 0xFF,    // Valeur MSB (premier octet)\n        (voltageValue >> 16) & 0xFF,    // Deuxième octet\n        (voltageValue >> 8) & 0xFF,     // Troisième octet\n        voltageValue & 0xFF             // Valeur LSB (dernier octet)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nconst tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\nmsg.topic = \"write_balance_starting_voltage\";\nmsg.payload = generateModbusWriteCommand(tensionAEcrire);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 460,
        "wires": [
            [
                "eb2f9a902aaa89d4",
                "3907fa3c80ee4655"
            ]
        ]
    },
    {
        "id": "eb2f9a902aaa89d4",
        "type": "link out",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "link out 14",
        "mode": "link",
        "links": [
            "305e1cac13589b0d"
        ],
        "x": 885,
        "y": 1400,
        "wires": []
    },
    {
        "id": "1eae5ec0352d7054",
        "type": "switch",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Topic Setup",
        "property": "stateTopic_bis",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "control/balance_starting_voltage/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/balance_trigger_voltage/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_count/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_request_charge_voltage/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_request_float_voltage/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_soc0_voltage/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_soc100_voltage/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_voltage_overvoltage_protection/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_voltage_overvoltage_recovery/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_voltage_undervoltage_protection/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/cell_voltage_undervoltage_recovery/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/charging_switch/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/discharging_switch/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/balance_switch/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/charge_overcurrent_protection_delay/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/charge_overcurrent_protection_recovery_time/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/charge_overtemperature_protection/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/charge_overtemperature_protection_recovery/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/discharge_overtemperature_protection/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/discharge_overtemperature_protection_recovery/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/power_tube_overtemperature_protection/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/power_tube_overtemperature_protection_recovery/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/charge_undertemperature_protection/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/charge_undertemperature_protection_recovery/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/max_balance_current/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/max_charge_current/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/max_discharge_current/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/power_off_voltage/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/display_always_on_switch/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/disable_pcl_module_switch/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/smart_sleep_switch/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/timed_stored_data_switch/state",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "control/smart_sleep_voltage/state",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 34,
        "x": 230,
        "y": 1160,
        "wires": [
            [
                "e5a60eb34250469e"
            ],
            [
                "0d83f03d4fe31ec7"
            ],
            [
                "d7d7e9cdde18feea"
            ],
            [
                "3c7d8632a04715ee"
            ],
            [
                "7062d7dac3d1708c"
            ],
            [
                "1ce89be89438eff9"
            ],
            [
                "23416caeb8f58587"
            ],
            [
                "dbf778beb308a432"
            ],
            [
                "d8fb1f44a0b34cb0"
            ],
            [
                "13a18dea6847dcd9"
            ],
            [
                "98b856c602c300ed"
            ],
            [
                "97cc6b2d5b15ec56"
            ],
            [
                "272cc4c342d5d912"
            ],
            [
                "970884cba0b3a3b7"
            ],
            [
                "92db9540d65530ec"
            ],
            [
                "e2b657959bd108d7"
            ],
            [
                "25a9d6ef8e4679d9"
            ],
            [
                "3e6d34126eb8086d"
            ],
            [
                "8c0ff28b33260428"
            ],
            [
                "b6bae1307ec91a38"
            ],
            [
                "f5b0b7204cb1eb25"
            ],
            [
                "47ea910caf54107a"
            ],
            [
                "9422ad975c55488b"
            ],
            [
                "093a767a45da5e96"
            ],
            [
                "4b03b3f62c267409"
            ],
            [
                "80b77b7957818d4c"
            ],
            [
                "40113a24a46cdb3b"
            ],
            [
                "1558e7d444dba0cb"
            ],
            [
                "56dd1878273cb1f8"
            ],
            [
                "5b2b55fee59d0e82"
            ],
            [
                "678c2f4b43673b7d"
            ],
            [
                "adf49a702d6ba9dc"
            ],
            [
                "8643c3a547c69160"
            ],
            [
                "991a64f8c51375eb"
            ]
        ]
    },
    {
        "id": "3b2397378287cde4",
        "type": "link in",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Setup dispatch in",
        "links": [
            "c3fe04450213c840"
        ],
        "x": 95,
        "y": 620,
        "wires": [
            [
                "1eae5ec0352d7054"
            ]
        ]
    },
    {
        "id": "991a64f8c51375eb",
        "type": "debug",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Autre topic setup",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 250,
        "y": 1500,
        "wires": []
    },
    {
        "id": "0d83f03d4fe31ec7",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write  balance trigger voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 0.08)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en valeur entière (échelle 1/1000)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n   \n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x14,                           // Register address low byte (0x14)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        (voltageValue >> 24) & 0xFF,    // Valeur MSB (premier octet)\n        (voltageValue >> 16) & 0xFF,    // Deuxième octet\n        (voltageValue >> 8) & 0xFF,     // Troisième octet\n        voltageValue & 0xFF             // Valeur LSB (dernier octet)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 0.001 || tensionAEcrire > 0.009) {\n    msg.error = \"Tension invalide. Valeur attendue entre 0.001V et 0.009V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_balance_trigger_voltage\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 500,
        "wires": [
            [
                "eb2f9a902aaa89d4",
                "e74995e51759d290"
            ]
        ]
    },
    {
        "id": "d7d7e9cdde18feea",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write  BMS cell count",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient le nombre de cellules (ex: 16)\nfunction generateModbusWriteCommand(cellCount) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // La valeur est utilisée directement, sans échelle\n    const cellValue = parseInt(cellCount);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x6C,                           // Register address low byte (0x6C)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        (cellValue >> 24) & 0xFF,       // Valeur MSB (premier octet)\n        (cellValue >> 16) & 0xFF,       // Deuxième octet\n        (cellValue >> 8) & 0xFF,        // Troisième octet\n        cellValue & 0xFF                // Valeur LSB (dernier octet)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction du nombre de cellules et envoi de la trame\nlet nombreCellules = parseInt(msg.payload);\n\n// Validation basique\nif (isNaN(nombreCellules) || nombreCellules < 1 || nombreCellules > 32) {\n    msg.error = \"Nombre de cellules invalide. Valeur attendue entre 1 et 32\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_bms_cell_count\";\nnewMsg.payload = generateModbusWriteCommand(nombreCellules);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 540,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "3c7d8632a04715ee",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write  cell request charge voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n   \n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x20,                           // Register address low byte (0x20)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Pour debug, affichons la valeur en hexadécimal\n    node.warn(`Écriture de ${voltage}V soit ${voltageValue}mV`);\n    node.warn(`Valeur en hex: 0x${voltageValue.toString(16)}`);\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_cell_request_charge_voltage\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 580,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "2a33af3acfb1a757",
        "type": "debug",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "debug 24",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 820,
        "y": 1580,
        "wires": []
    },
    {
        "id": "7062d7dac3d1708c",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write  cell request float voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x24,                           // Register address low byte (0x24)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_cell_request_float_voltage\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 620,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "1ce89be89438eff9",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write BMS cell soc0 voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x1C,                           // Register address low byte (0x1C)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_bms_cell_soc0_voltage\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 660,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "23416caeb8f58587",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write BMS cell soc100 voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x18,                           // Register address low byte (0x18)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_bms_cell_soc100_voltage\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 700,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "dbf778beb308a432",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write BMS cell voltage overvoltage protection",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x0c,                           // Register address low byte (0x0c)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_cell_voltage_overvoltage_protection\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 740,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "d8fb1f44a0b34cb0",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write BMS cell voltage overvoltage recovery",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x10,                           // Register address low byte (0x0c)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_cell_voltage_overvoltage_recovery\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 780,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "13a18dea6847dcd9",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write BMS cell voltage undervoltage protection",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x04,                           // Register address low byte (0x0c)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_cell_voltage_undervoltage_protection\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 580,
        "y": 820,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "98b856c602c300ed",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write BMS cell voltage undervoltage recovery",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension (ex: 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x08,                           // Register address low byte (0x0c)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 2.5 || tensionAEcrire > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_cell_voltage_undervoltage_recovery\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 860,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "97cc6b2d5b15ec56",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write  Charging switch",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload peut être \"true\"/\"True\"/\"false\"/\"False\" ou true/false\n\nfunction generateModbusWriteCommand(input) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Conversion de l'entrée en booléen\n    let isOn = false;\n    if (typeof input === 'string') {\n        isOn = input.toLowerCase() === 'true';\n    } else if (typeof input === 'boolean') {\n        isOn = input;\n    }\n\n    // Debug\n    console.log(\"Input value:\", input);\n    console.log(\"Converted to:\", isOn);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x70,                           // Register address low byte (0x70)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        0x00,                           // Octet de poids fort (MSB)\n        0x00,                           // \n        0x00,                           // \n        isOn ? 1 : 0                    // Octet de poids faible (LSB)\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'boolean' && typeof msg.payload !== 'string') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: true/false, 'true'/'false', 'True'/'False'\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_balancer_charging_switch\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\n// Debug\nconsole.log(\"Message payload:\", msg.payload);\nconsole.log(\"Type of payload:\", typeof msg.payload);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 900,
        "wires": [
            [
                "eb2f9a902aaa89d4",
                "2331437f356ceafd"
            ]
        ]
    },
    {
        "id": "272cc4c342d5d912",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write  BMS Décharge switch",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload peut être \"true\"/\"True\"/\"false\"/\"False\" ou true/false\n\nfunction generateModbusWriteCommand(input) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Conversion de l'entrée en booléen\n    let isOn = false;\n    if (typeof input === 'string') {\n        isOn = input.toLowerCase() === 'true';\n    } else if (typeof input === 'boolean') {\n        isOn = input;\n    }\n\n    // Debug\n    console.log(\"Input value:\", input);\n    console.log(\"Converted to:\", isOn);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x74,                           // Register address low byte (0x74)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        0x00,                           // Octet de poids fort (MSB)\n        0x00,                           // \n        0x00,                           // \n        isOn ? 1 : 0                    // Octet de poids faible (LSB)\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'boolean' && typeof msg.payload !== 'string') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: true/false, 'true'/'false', 'True'/'False'\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_bms_discharging_switch\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\n// Debug\nconsole.log(\"Message payload:\", msg.payload);\nconsole.log(\"Type of payload:\", typeof msg.payload);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 940,
        "wires": [
            [
                "eb2f9a902aaa89d4",
                "913ddde7f0deadf0"
            ]
        ]
    },
    {
        "id": "970884cba0b3a3b7",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write  BMS Balance switch",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload peut être \"true\"/\"True\"/\"false\"/\"False\" ou true/false\n\nfunction generateModbusWriteCommand(input) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Conversion de l'entrée en booléen\n    let isOn = false;\n    if (typeof input === 'string') {\n        isOn = input.toLowerCase() === 'true';\n    } else if (typeof input === 'boolean') {\n        isOn = input;\n    }\n\n    // Debug\n    console.log(\"Input value:\", input);\n    console.log(\"Converted to:\", isOn);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x78,                           // Register address low byte (0x78)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        0x00,                           // Octet de poids fort (MSB)\n        0x00,                           // \n        0x00,                           // \n        isOn ? 1 : 0                    // Octet de poids faible (LSB)\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'boolean' && typeof msg.payload !== 'string') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: true/false, 'true'/'false', 'True'/'False'\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_charging_float_mode_switch\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\n// Debug\nconsole.log(\"Message payload:\", msg.payload);\nconsole.log(\"Type of payload:\", typeof msg.payload);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 980,
        "wires": [
            [
                "eb2f9a902aaa89d4",
                "cb9d4157ead46059"
            ]
        ]
    },
    {
        "id": "92db9540d65530ec",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write  BMS BMS charge overcurrent protection delay",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre en secondes (ex: 4)\n\nfunction generateModbusWriteCommand(seconds) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof seconds !== 'number' || seconds < 0 || !Number.isInteger(seconds)) {\n        throw new Error(\"La valeur d'entrée doit être un entier positif représentant des secondes.\");\n    }\n\n    // Conversion en uint32 (deux registres de 16 bits en Big-Endian)\n    let highWord = (seconds >> 16) & 0xFFFF;\n    let lowWord = seconds & 0xFFFF;\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x30,                           // Register address low byte (0x30)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        (highWord >> 8) & 0xFF,         // Octet de poids fort du premier registre\n        highWord & 0xFF,                // Octet de poids faible du premier registre\n        (lowWord >> 8) & 0xFF,          // Octet de poids fort du second registre\n        lowWord & 0xFF                  // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number' || msg.payload < 0 || !Number.isInteger(msg.payload)) {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un entier positif en secondes.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_charge_overcurrent_protection_delay\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 1020,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "e2b657959bd108d7",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write  BMS charge overcurrent protection recovery time",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre en secondes (ex: 4)\n\nfunction generateModbusWriteCommand(seconds) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof seconds !== 'number' || seconds < 0 || !Number.isInteger(seconds)) {\n        throw new Error(\"La valeur d'entrée doit être un entier positif représentant des secondes.\");\n    }\n\n    // Conversion en uint32 (deux registres de 16 bits en Big-Endian)\n    let highWord = (seconds >> 16) & 0xFFFF;\n    let lowWord = seconds & 0xFFFF;\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x34,                           // Register address low byte (0x30)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        (highWord >> 8) & 0xFF,         // Octet de poids fort du premier registre\n        highWord & 0xFF,                // Octet de poids faible du premier registre\n        (lowWord >> 8) & 0xFF,          // Octet de poids fort du second registre\n        lowWord & 0xFF                  // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number' || msg.payload < 0 || !Number.isInteger(msg.payload)) {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un entier positif en secondes.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_charge_overcurrent_protection_recovery_time\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 1060,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "25a9d6ef8e4679d9",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write charge overtemperature protection",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x4C,                           // Register address low byte (0x4C)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_charge_overtemperature_protection\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 560,
        "y": 1100,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "3e6d34126eb8086d",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write charge overtemperature protection recovery",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x1050)\n        0x50,                           // Register address low byte (0x1050)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_charge_overtemperature_protection_recovery\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 1140,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "8c0ff28b33260428",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write discharge overtemperature protection",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x1050)\n        0x54,                           // Register address low byte (0x1050)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_discharge_overtemperature_protection\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 1180,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "b6bae1307ec91a38",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write discharge overtemperature protection recovery",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x1050)\n        0x58,                           // Register address low byte (0x1050)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_discharge_overtemperature_protection_recovery\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 1220,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "f5b0b7204cb1eb25",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write power tube overtemperature protection",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x1050)\n        0x64,                           // Register address low byte (0x1050)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_power_tube_overtemperature_protection\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 1260,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "47ea910caf54107a",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write power tube overtemperature protection recovery",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x1050)\n        0x68,                           // Register address low byte (0x1050)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_power tube_overtemperature_protection_recovery\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 1300,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "9422ad975c55488b",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write charge undertemperature protection",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x1050)\n        0x5C,                           // Register address low byte (0x1050)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_charge_undertemperature_protection\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 560,
        "y": 1340,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "093a767a45da5e96",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write charge undertemperature protection recovery",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload est un nombre représentant la température en °C (ex: 70.1 pour 70.1°C)\n\nfunction generateModbusWriteCommand(temperature) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Vérification et conversion de l'entrée\n    if (typeof temperature !== 'number') {\n        throw new Error(\"La valeur d'entrée doit être un nombre représentant la température en °C.\");\n    }\n\n    // Conversion en INT32 (valeur multipliée par 10 pour stocker en 0.1°C)\n    let tempValue = Math.round(temperature * 10);\n    let buffer = Buffer.alloc(4);\n    buffer.writeInt32BE(tempValue, 0);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x1050)\n        0x60,                           // Register address low byte (0x1050)\n        0x00,                           // Quantity high byte (2 registres pour int32)\n        0x02,                           // Quantity low byte (2 registres pour int32)\n        0x04,                           // Byte count (4 bytes pour int32)\n        buffer[0],                      // Octet de poids fort du premier registre\n        buffer[1],                      // Octet de poids faible du premier registre\n        buffer[2],                      // Octet de poids fort du second registre (valeur réelle)\n        buffer[3]                       // Octet de poids faible du second registre\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    // Debug: afficher la trame en console\n    console.log(\"Trame générée:\", command);\n\n    return Buffer.from(command);\n}\n\n// Validation de l'entrée\nif (typeof msg.payload !== 'number') {\n    msg.error = \"Valeur d'entrée invalide. Attendu: un nombre représentant la température en °C.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_charge_undertemperature_protection_recovery\";\nnewMsg.payload = generateModbusWriteCommand(msg.payload);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 1380,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "4b03b3f62c267409",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write max balance current",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient le courant en ampères (ex: 1.5)\nfunction generateModbusWriteCommand(current) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion du courant selon l'échelle (2A = 2000)\n    // Exemple: 1.5A -> 1500\n    const currentValue = Math.round(current * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x48,                           // Register address low byte (0x48)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en BE (Big Endian), on envoie d'abord les octets de poids fort\n        0x00,                           // Octet 1 (MSB)\n        0x00,                           // Octet 2\n        (currentValue >> 8) & 0xFF,     // Octet 3\n        currentValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Pour debug, affichons la valeur\n    node.warn(`Écriture de ${current}A soit ${currentValue} unités`);\n    node.warn(`Valeur en hex: 0x${currentValue.toString(16)}`);\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de courant et envoi de la trame\nlet courantAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(courantAEcrire) || courantAEcrire < 0 || courantAEcrire > 2) {\n    msg.error = \"Courant invalide. Valeur attendue entre 0A et 2A\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_max_balance_current\";\nnewMsg.payload = generateModbusWriteCommand(courantAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 1420,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "80b77b7957818d4c",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write max charge current",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient le courant en ampères (ex: 5)\nfunction generateModbusWriteCommand(current) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion du courant selon l'échelle observée (140A = 140000)\n    // Exemple: 5A -> 5000\n    const currentValue = Math.round(current * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x2C,                           // Register address low byte (0x2C)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32, on envoie les 4 octets (du plus significatif au moins significatif)\n        (currentValue >> 24) & 0xFF,    // Octet 1 (MSB)\n        (currentValue >> 16) & 0xFF,    // Octet 2\n        (currentValue >> 8) & 0xFF,     // Octet 3\n        currentValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Pour debug, affichons la valeur\n    node.warn(`Écriture de ${current}A soit ${currentValue} unités`);\n    node.warn(`Valeur en hex: 0x${currentValue.toString(16).padStart(8, '0')}`);\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de courant et envoi de la trame\nlet courantAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(courantAEcrire) || courantAEcrire < 0 || courantAEcrire > 150) {\n    msg.error = \"Courant invalide. Valeur attendue entre 0A et 150A\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_max_charge_current\";\nnewMsg.payload = generateModbusWriteCommand(courantAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 1460,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "40113a24a46cdb3b",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write BMS max discharge current",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient le courant en ampères (ex: 5)\nfunction generateModbusWriteCommand(current) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion du courant selon l'échelle observée (140A = 140000)\n    // Exemple: 5A -> 5000\n    const currentValue = Math.round(current * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x38,                           // Register address low byte (0x38)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32, on envoie les 4 octets (du plus significatif au moins significatif)\n        (currentValue >> 24) & 0xFF,    // Octet 1 (MSB)\n        (currentValue >> 16) & 0xFF,    // Octet 2\n        (currentValue >> 8) & 0xFF,     // Octet 3\n        currentValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Pour debug, affichons la valeur\n    node.warn(`Écriture de ${current}A soit ${currentValue} unités`);\n    node.warn(`Valeur en hex: 0x${currentValue.toString(16).padStart(8, '0')}`);\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de courant et envoi de la trame\nlet courantAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(courantAEcrire) || courantAEcrire < 0 || courantAEcrire > 150) {\n    msg.error = \"Courant invalide. Valeur attendue entre 0A et 150A\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_bms_max_discharge_current\";\nnewMsg.payload = generateModbusWriteCommand(courantAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 1500,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "1558e7d444dba0cb",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write BMS power off voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue: msg.payload contient la tension en volts (ex: 2.5)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n    \n    // Conversion de la tension en millivolts (2.5V -> 2500mV)\n    const voltageValue = Math.round(voltage * 1000);\n    \n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x28,                           // Register address low byte (0x28)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32, on envoie les 4 octets (du plus significatif au moins significatif)\n        (voltageValue >> 24) & 0xFF,    // Octet 1 (MSB)\n        (voltageValue >> 16) & 0xFF,    // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n    \n    // Pour debug, affichons la valeur\n    node.warn(`Écriture de ${voltage}V soit ${voltageValue}mV`);\n    node.warn(`Valeur en hex: 0x${voltageValue.toString(16).padStart(8, '0')}`);\n    \n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n    \n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet tensionAEcrire = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(tensionAEcrire) || tensionAEcrire < 1.8 || tensionAEcrire > 3.0) {\n    msg.error = \"Tension invalide. Valeur attendue entre 1.8V et 3.0V\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_power_off_voltage\";\nnewMsg.payload = generateModbusWriteCommand(tensionAEcrire);\n\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 1540,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "56dd1878273cb1f8",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write LCD-on-off",
        "func": "// Node-RED function node pour générer la trame Modbus\nfunction generateModbusCommand(setLCDOn) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,       // Slave ID\n        0x10,       // Function code (16 - Write Multiple Registers)\n        0x11,       // Register address high byte (0x11)\n        0x14,       // Register address low byte (0x14)\n        0x00,       // Quantity of registers high byte\n        0x01,       // Quantity of registers low byte\n        0x02,       // Byte count\n        0x00,       // Data high byte\n        setLCDOn ? 0x10 : 0x00  // Data low byte (bit 4 set or unset)\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    return Buffer.from(command);\n}\n\n// Traitement du payload d'entrée\nlet setLCDOn = msg.payload.toLowerCase() === \"true\";\n\n// Envoi de la trame\nmsg.topic = \"LCD\";\nmsg.payload = generateModbusCommand(setLCDOn);\n\n// Fonction pour extraire les 9 premiers bits de la réponse\nmsg.extractBits = function(response) {\n    if (response && response.length >= 5) {\n        const uint16Value = (response[3] << 8) | response[4];\n        let bitStates = {};\n        for (let i = 0; i < 9; i++) {\n            bitStates[`bit${i}`] = (uint16Value >> i) & 1;\n        }\n        return bitStates;\n    }\n    return null;\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 1580,
        "wires": [
            [
                "eb2f9a902aaa89d4",
                "2a33af3acfb1a757"
            ]
        ]
    },
    {
        "id": "5b2b55fee59d0e82",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write PCL_Disable",
        "func": "// Node-RED function node pour générer la trame Modbus\nfunction generateModbusCommand(setPCLDisabled) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,       // Slave ID\n        0x10,       // Function code (16 - Write Multiple Registers)\n        0x11,       // Register address high byte (0x11)\n        0x14,       // Register address low byte (0x14)\n        0x00,       // Quantity of registers high byte\n        0x01,       // Quantity of registers low byte\n        0x02,       // Byte count\n        0x00,       // Data high byte\n        setPCLDisabled ? 0x80 : 0x00  // Data low byte (bit 7 set or unset)\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    return Buffer.from(command);\n}\n\n// Traitement du payload d'entrée\nlet setPCLDisabled = msg.payload.toLowerCase() === \"true\";\n\n// Envoi de la trame\nmsg.topic = \"PCL_Disable\";\nmsg.payload = generateModbusCommand(setPCLDisabled);\n\n// Fonction pour extraire les 9 premiers bits de la réponse\nmsg.extractBits = function(response) {\n    if (response && response.length >= 5) {\n        const uint16Value = (response[3] << 8) | response[4];\n        let bitStates = {};\n        for (let i = 0; i < 9; i++) {\n            bitStates[`bit${i}`] = (uint16Value >> i) & 1;\n        }\n        return bitStates;\n    }\n    return null;\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 1620,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "678c2f4b43673b7d",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write smart sleep switch",
        "func": "// Node-RED function node pour générer la trame Modbus\nfunction generateModbusCommand(setSmartSleepOn) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,       // Slave ID\n        0x10,       // Function code (16 - Write Multiple Registers)\n        0x11,       // Register address high byte (0x11)\n        0x14,       // Register address low byte (0x14)\n        0x00,       // Quantity of registers high byte\n        0x01,       // Quantity of registers low byte\n        0x02,       // Byte count\n        0x00,       // Data high byte\n        setSmartSleepOn ? 0x40 : 0x00  // Data low byte (bit 6 set or unset)\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    return Buffer.from(command);\n}\n\n// Traitement du payload d'entrée\nlet setSmartSleepOn = msg.payload.toLowerCase() === \"true\";\n\n// Envoi de la trame\nmsg.topic = \"Smart_Sleep\";\nmsg.payload = generateModbusCommand(setSmartSleepOn);\n\n// Fonction pour extraire les 9 premiers bits de la réponse\nmsg.extractBits = function(response) {\n    if (response && response.length >= 5) {\n        const uint16Value = (response[3] << 8) | response[4];\n        let bitStates = {};\n        for (let i = 0; i < 9; i++) {\n            bitStates[`bit${i}`] = (uint16Value >> i) & 1;\n        }\n        return bitStates;\n    }\n    return null;\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 1660,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "adf49a702d6ba9dc",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write Timed_Stored_Data",
        "func": "// Node-RED function node pour générer la trame Modbus\nfunction generateModbusCommand(setTimedStoredDataOn) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,       // Slave ID\n        0x10,       // Function code (16 - Write Multiple Registers)\n        0x11,       // Register address high byte (0x11)\n        0x14,       // Register address low byte (0x14)\n        0x00,       // Quantity of registers high byte\n        0x01,       // Quantity of registers low byte\n        0x02,       // Byte count\n        setTimedStoredDataOn ? 0x01 : 0x00,  // Data high byte (bit 8 set or unset)\n        0x00        // Data low byte\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    return Buffer.from(command);\n}\n\n// Traitement du payload d'entrée\nlet setTimedStoredDataOn = msg.payload.toLowerCase() === \"true\";\n\n// Envoi de la trame\nmsg.topic = \"Timed_Stored_Data\";\nmsg.payload = generateModbusCommand(setTimedStoredDataOn);\n\n// Fonction pour extraire les 9 premiers bits de la réponse\nmsg.extractBits = function(response) {\n    if (response && response.length >= 5) {\n        const uint16Value = (response[3] << 8) | response[4];\n        let bitStates = {};\n        for (let i = 0; i < 9; i++) {\n            bitStates[`bit${i}`] = (uint16Value >> i) & 1;\n        }\n        return bitStates;\n    }\n    return null;\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 1700,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "8643c3a547c69160",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "Write BMS_smart_sleep_voltage",
        "func": "// Node-RED function node pour générer la trame Modbus d'écriture\n// Entrée attendue : msg.payload contient la tension (exemple : 3.65)\nfunction generateModbusWriteCommand(voltage) {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Conversion de la tension en millivolts (par exemple, 3.65V -> 3650)\n    const voltageValue = Math.round(voltage * 1000);\n\n    // Construction de la trame sans CRC\n    // Récupération de l'adresse esclave depuis le contexte global\n    const slaveId = global.get(\"slaveAddress-setup\") || 0x01; // Valeur par défaut si non définie\n\n    const command = [\n        slaveId,                           // Slave ID\n        0x10,                           // Function code (16/0x10 - Write Multiple Registers)\n        0x10,                           // Register address high byte (0x10)\n        0x00,                           // Register address low byte (0x00)\n        0x00,                           // Quantity high byte (2 registres pour uint32)\n        0x02,                           // Quantity low byte (2 registres pour uint32)\n        0x04,                           // Byte count (4 bytes pour uint32)\n        // Pour un uint32 en Big Endian (BE), on envoie d'abord les octets de poids fort\n        (voltageValue >> 24) & 0xFF,    // Octet 1 (MSB)\n        (voltageValue >> 16) & 0xFF,    // Octet 2\n        (voltageValue >> 8) & 0xFF,     // Octet 3\n        voltageValue & 0xFF             // Octet 4 (LSB)\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n\n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);          // CRC low byte\n    command.push((crc >> 8) & 0xFF);   // CRC high byte\n\n    return Buffer.from(command);\n}\n\n// Extraction de la valeur de tension et envoi de la trame\nlet smartSleepVoltage = parseFloat(msg.payload);\n\n// Validation basique\nif (isNaN(smartSleepVoltage) || smartSleepVoltage < 2.5 || smartSleepVoltage > 4.5) {\n    msg.error = \"Tension invalide. Valeur attendue entre 2.5V et 4.5V.\";\n    return msg;\n}\n\n// Création du message de sortie\nconst newMsg = {};\nnewMsg.topic = \"write_BMS_smart_sleep_voltage\";\nnewMsg.payload = generateModbusWriteCommand(smartSleepVoltage);\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 1740,
        "wires": [
            [
                "eb2f9a902aaa89d4"
            ]
        ]
    },
    {
        "id": "cb9d4157ead46059",
        "type": "debug",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "debug 18",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 740,
        "y": 980,
        "wires": []
    },
    {
        "id": "913ddde7f0deadf0",
        "type": "debug",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "debug 12",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 730,
        "y": 940,
        "wires": []
    },
    {
        "id": "2331437f356ceafd",
        "type": "debug",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "debug 11",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 690,
        "y": 900,
        "wires": []
    },
    {
        "id": "b8969f5c95ec96c0",
        "type": "function",
        "z": "63221fce04fce9a1",
        "g": "784cf280be8f9617",
        "name": "function 1",
        "func": "// Handle incoming commands from Home Assistant\nvar parameter = msg.topic.split('/')[2]; // Extract parameter name\nvar value = msg.payload;  // Création du stateTopic original\nvar stateTopic = msg.topic.replace('/set', '/state');  \n\n// Récupère le numéro du BMS et met à jour la variable globale\nconst topicParts = msg.topic.split('_');\nconst slaveAddress = parseInt(topicParts[1].split('/')[0]);\nglobal.set('slaveAddress-setup', slaveAddress);  \n\n// Création du stateTopic_bis en retirant \"BMS_n/\" et remplaçant \"/set\" par \"/state\"\nconst stateTopic_bis = msg.topic.replace(/BMS_\\d+\\//, '').replace('/set', '/state');\n\nreturn [\n    { \n        topic: stateTopic, \n        payload: value, \n        retain: true,\n        stateTopic_bis: stateTopic_bis  // Ajoutez stateTopic_bis ici\n    },\n    { \n        payload: { \n            parameter: parameter, \n            value: value\n        } \n    }\n];",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 140,
        "y": 240,
        "wires": [
            [
                "c3fe04450213c840",
                "08624c75c29f1a0d",
                "c827a1a690486903"
            ]
        ]
    },
    {
        "id": "1905f9987eb5b3fd",
        "type": "inject",
        "z": "63221fce04fce9a1",
        "g": "784cf280be8f9617",
        "name": "BMS_n/",
        "props": [
            {
                "p": "topic",
                "v": "[\"control/+/set\",\"BMS_1/control/+/set\",\"BMS_2/control/+/set\",\"BMS_3/control/+/set\",\"BMS_4/control/+/set\",\"BMS_5/control/+/set\",\"BMS_6/control/+/set\",\"BMS_7/control/+/set\",\"BMS_8/control/+/set\",\"BMS_9/control/+/set\",\"BMS_10/control/+/set\",\"BMS_11/control/+/set\",\"BMS_12/control/+/set\",\"BMS_13/control/+/set\",\"BMS_14/control/+/set\",\"BMS_15/control/+/set\"]",
                "vt": "json"
            },
            {
                "p": "action",
                "v": "subscribe",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "0.2",
        "topic": "",
        "x": 120,
        "y": 100,
        "wires": [
            [
                "7989336bb8bc11db"
            ]
        ]
    },
    {
        "id": "7989336bb8bc11db",
        "type": "mqtt in",
        "z": "63221fce04fce9a1",
        "g": "784cf280be8f9617",
        "name": "",
        "topic": "",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "56f7b2737cce493b",
        "nl": false,
        "rap": false,
        "inputs": 1,
        "x": 290,
        "y": 100,
        "wires": [
            [
                "55b993c941334789"
            ]
        ]
    },
    {
        "id": "3907fa3c80ee4655",
        "type": "debug",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "debug 30",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 770,
        "y": 460,
        "wires": []
    },
    {
        "id": "e74995e51759d290",
        "type": "debug",
        "z": "63221fce04fce9a1",
        "g": "219ec3c4c0c62dcb",
        "name": "debug 6",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 750,
        "y": 500,
        "wires": []
    },
    {
        "id": "323d60d4baaf7cef",
        "type": "ui-number-input",
        "z": "dfa2ea8601dc4518",
        "g": "8ca20acee7a5ced4",
        "group": "858d2c8bdccf259b",
        "name": "Nombre de BMS",
        "label": "Nombre de BMS",
        "order": 1,
        "width": "2",
        "height": "1",
        "topic": "topic",
        "topicType": "msg",
        "min": 0,
        "max": "15",
        "step": 1,
        "tooltip": "Veuillez indiquer le nombre de BMS présents",
        "passthru": true,
        "sendOnBlur": false,
        "sendOnEnter": true,
        "className": "",
        "clearable": true,
        "icon": "",
        "iconPosition": "left",
        "iconInnerPosition": "inside",
        "spinner": "default",
        "x": 200,
        "y": 520,
        "wires": [
            [
                "a2b0648cb046cfbe"
            ]
        ]
    },
    {
        "id": "95136cbde35b3056",
        "type": "ui-text-input",
        "z": "dfa2ea8601dc4518",
        "g": "3309ffc04a216e40",
        "group": "858d2c8bdccf259b",
        "name": "MQTT Broker IP adresse",
        "label": "Broker IP",
        "order": 3,
        "width": "2",
        "height": "1",
        "topic": "topic",
        "topicType": "msg",
        "mode": "text",
        "tooltip": "Veuillez entrer l'adresse IP de votre Broker MQTT",
        "delay": 300,
        "passthru": false,
        "sendOnDelay": false,
        "sendOnBlur": false,
        "sendOnEnter": true,
        "className": "",
        "clearable": true,
        "sendOnClear": false,
        "icon": "",
        "iconPosition": "left",
        "iconInnerPosition": "inside",
        "x": 270,
        "y": 620,
        "wires": [
            [
                "2123d252804f6de2"
            ]
        ]
    },
    {
        "id": "a2b0648cb046cfbe",
        "type": "change",
        "z": "dfa2ea8601dc4518",
        "g": "8ca20acee7a5ced4",
        "name": "Number of BMS",
        "rules": [
            {
                "t": "set",
                "p": "Number_of_BMS",
                "pt": "global",
                "to": "payload",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 460,
        "y": 520,
        "wires": [
            [
                "ea324554d0bd9024"
            ]
        ]
    },
    {
        "id": "2123d252804f6de2",
        "type": "change",
        "z": "dfa2ea8601dc4518",
        "g": "3309ffc04a216e40",
        "name": "Broker_IP",
        "rules": [
            {
                "t": "set",
                "p": "Broker_IP",
                "pt": "global",
                "to": "payload",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 480,
        "y": 620,
        "wires": [
            [
                "3ce30d1dddc257b6"
            ]
        ]
    },
    {
        "id": "836bea324c6df2ca",
        "type": "ui-text-input",
        "z": "dfa2ea8601dc4518",
        "g": "3309ffc04a216e40",
        "group": "858d2c8bdccf259b",
        "name": "Broker User",
        "label": "Broker User",
        "order": 4,
        "width": "2",
        "height": "1",
        "topic": "topic",
        "topicType": "msg",
        "mode": "text",
        "tooltip": "Veuillez entrer le nom utilisteur pour la connexion à votre broker",
        "delay": 300,
        "passthru": false,
        "sendOnDelay": false,
        "sendOnBlur": false,
        "sendOnEnter": true,
        "className": "",
        "clearable": true,
        "sendOnClear": false,
        "icon": "",
        "iconPosition": "left",
        "iconInnerPosition": "inside",
        "x": 230,
        "y": 660,
        "wires": [
            [
                "1cd47d6c2f768f5f"
            ]
        ]
    },
    {
        "id": "1cd47d6c2f768f5f",
        "type": "change",
        "z": "dfa2ea8601dc4518",
        "g": "3309ffc04a216e40",
        "name": "Broker_User",
        "rules": [
            {
                "t": "set",
                "p": "Broker_User",
                "pt": "global",
                "to": "payload",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 490,
        "y": 660,
        "wires": [
            [
                "3ce30d1dddc257b6"
            ]
        ]
    },
    {
        "id": "3cb083ba64129d24",
        "type": "ui-text-input",
        "z": "dfa2ea8601dc4518",
        "g": "3309ffc04a216e40",
        "group": "858d2c8bdccf259b",
        "name": "Broker Password",
        "label": "Broker Password",
        "order": 5,
        "width": "2",
        "height": "1",
        "topic": "topic",
        "topicType": "msg",
        "mode": "password",
        "tooltip": "Veuillez entrer le mot de passe pour la connexion à votre Broker MQTT",
        "delay": 300,
        "passthru": false,
        "sendOnDelay": false,
        "sendOnBlur": false,
        "sendOnEnter": true,
        "className": "",
        "clearable": true,
        "sendOnClear": false,
        "icon": "",
        "iconPosition": "left",
        "iconInnerPosition": "inside",
        "x": 250,
        "y": 700,
        "wires": [
            [
                "852b53befbd1075b"
            ]
        ]
    },
    {
        "id": "852b53befbd1075b",
        "type": "change",
        "z": "dfa2ea8601dc4518",
        "g": "3309ffc04a216e40",
        "name": "Broker_Password",
        "rules": [
            {
                "t": "set",
                "p": "Broker_Password",
                "pt": "global",
                "to": "payload",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 510,
        "y": 700,
        "wires": [
            [
                "3ce30d1dddc257b6"
            ]
        ]
    },
    {
        "id": "15f1710cf5093fb0",
        "type": "switch",
        "z": "dfa2ea8601dc4518",
        "g": "259fe46998b37b22",
        "name": "Broker_IP vide ?",
        "property": "Broker_IP",
        "propertyType": "global",
        "rules": [
            {
                "t": "null"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 380,
        "y": 180,
        "wires": [
            [
                "0716aa3cd0eb7183"
            ],
            [
                "bbe4431a1216286d"
            ]
        ]
    },
    {
        "id": "6cae3649dec819a4",
        "type": "inject",
        "z": "dfa2ea8601dc4518",
        "g": "259fe46998b37b22",
        "name": "Broker_IP",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "Broker_IP",
        "payloadType": "global",
        "x": 150,
        "y": 180,
        "wires": [
            [
                "15f1710cf5093fb0"
            ]
        ]
    },
    {
        "id": "bbe4431a1216286d",
        "type": "link out",
        "z": "dfa2ea8601dc4518",
        "g": "259fe46998b37b22",
        "name": "Broker_IP_out",
        "mode": "link",
        "links": [
            "dee0d6711b426449"
        ],
        "x": 815,
        "y": 189,
        "wires": []
    },
    {
        "id": "dee0d6711b426449",
        "type": "link in",
        "z": "dfa2ea8601dc4518",
        "g": "3309ffc04a216e40",
        "name": "Broker_IP_in",
        "links": [
            "bbe4431a1216286d"
        ],
        "x": 115,
        "y": 620,
        "wires": [
            [
                "95136cbde35b3056"
            ]
        ]
    },
    {
        "id": "0716aa3cd0eb7183",
        "type": "change",
        "z": "dfa2ea8601dc4518",
        "g": "259fe46998b37b22",
        "name": "Please fill it",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "Please fill it",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 630,
        "y": 160,
        "wires": [
            [
                "bbe4431a1216286d"
            ]
        ]
    },
    {
        "id": "ad72afbb71279da9",
        "type": "switch",
        "z": "dfa2ea8601dc4518",
        "g": "259fe46998b37b22",
        "name": "Broker_User vide ?",
        "property": "Broker_User",
        "propertyType": "global",
        "rules": [
            {
                "t": "null"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 391,
        "y": 239,
        "wires": [
            [
                "9c7d6f179e710814"
            ],
            [
                "10d32db96de1049b"
            ]
        ]
    },
    {
        "id": "b40d86ff8814acd6",
        "type": "inject",
        "z": "dfa2ea8601dc4518",
        "g": "259fe46998b37b22",
        "name": "Broker_User",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "Broker_User",
        "payloadType": "global",
        "x": 151,
        "y": 239,
        "wires": [
            [
                "ad72afbb71279da9"
            ]
        ]
    },
    {
        "id": "10d32db96de1049b",
        "type": "link out",
        "z": "dfa2ea8601dc4518",
        "g": "259fe46998b37b22",
        "name": "Broker_User_out",
        "mode": "link",
        "links": [
            "27b1591610853483"
        ],
        "x": 815,
        "y": 248,
        "wires": []
    },
    {
        "id": "9c7d6f179e710814",
        "type": "change",
        "z": "dfa2ea8601dc4518",
        "g": "259fe46998b37b22",
        "name": "Please fill it",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "Please fill it",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 631,
        "y": 219,
        "wires": [
            [
                "10d32db96de1049b"
            ]
        ]
    },
    {
        "id": "27b1591610853483",
        "type": "link in",
        "z": "dfa2ea8601dc4518",
        "g": "3309ffc04a216e40",
        "name": "Broker_User_in",
        "links": [
            "10d32db96de1049b"
        ],
        "x": 115,
        "y": 660,
        "wires": [
            [
                "836bea324c6df2ca"
            ]
        ]
    },
    {
        "id": "bce7a24ea78cde8e",
        "type": "switch",
        "z": "dfa2ea8601dc4518",
        "g": "259fe46998b37b22",
        "name": "Number_of_BMS vide ?",
        "property": "Number_of_BMS",
        "propertyType": "global",
        "rules": [
            {
                "t": "null"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 411,
        "y": 119,
        "wires": [
            [
                "b67ac1233f0da57e"
            ],
            [
                "91b88a5031c60415"
            ]
        ]
    },
    {
        "id": "2372cd84fe52e55c",
        "type": "inject",
        "z": "dfa2ea8601dc4518",
        "g": "259fe46998b37b22",
        "name": "Number_of_BMS",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "Number_of_BMS",
        "payloadType": "global",
        "x": 171,
        "y": 119,
        "wires": [
            [
                "bce7a24ea78cde8e"
            ]
        ]
    },
    {
        "id": "91b88a5031c60415",
        "type": "link out",
        "z": "dfa2ea8601dc4518",
        "g": "259fe46998b37b22",
        "name": "Number_of_BMS_out",
        "mode": "link",
        "links": [
            "4622780f4abd4ac3"
        ],
        "x": 815,
        "y": 127,
        "wires": []
    },
    {
        "id": "b67ac1233f0da57e",
        "type": "change",
        "z": "dfa2ea8601dc4518",
        "g": "259fe46998b37b22",
        "name": "fill to 1 ",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "1",
                "tot": "num"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 611,
        "y": 99,
        "wires": [
            [
                "91b88a5031c60415"
            ]
        ]
    },
    {
        "id": "4622780f4abd4ac3",
        "type": "link in",
        "z": "dfa2ea8601dc4518",
        "g": "8ca20acee7a5ced4",
        "name": "Number_of_BMS_in",
        "links": [
            "91b88a5031c60415"
        ],
        "x": 75,
        "y": 520,
        "wires": [
            [
                "323d60d4baaf7cef"
            ]
        ]
    },
    {
        "id": "cff79b090ba46671",
        "type": "switch",
        "z": "dfa2ea8601dc4518",
        "g": "259fe46998b37b22",
        "name": "Broker_Password vide ?",
        "property": "Broker_Password",
        "propertyType": "global",
        "rules": [
            {
                "t": "null"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 411,
        "y": 307,
        "wires": [
            [
                "43c4f85eafb7dc6b"
            ],
            [
                "081a4d809dc9018e"
            ]
        ]
    },
    {
        "id": "8ea8e26d1fdd001e",
        "type": "inject",
        "z": "dfa2ea8601dc4518",
        "g": "259fe46998b37b22",
        "name": "Broker_Password",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "Broker_Password",
        "payloadType": "global",
        "x": 171,
        "y": 307,
        "wires": [
            [
                "cff79b090ba46671"
            ]
        ]
    },
    {
        "id": "081a4d809dc9018e",
        "type": "link out",
        "z": "dfa2ea8601dc4518",
        "g": "259fe46998b37b22",
        "name": "Broker_Password_out",
        "mode": "link",
        "links": [
            "698f6870ab9ffea7"
        ],
        "x": 815,
        "y": 314,
        "wires": []
    },
    {
        "id": "43c4f85eafb7dc6b",
        "type": "change",
        "z": "dfa2ea8601dc4518",
        "g": "259fe46998b37b22",
        "name": "Please fill it",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "Please fill it",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 631,
        "y": 287,
        "wires": [
            [
                "081a4d809dc9018e"
            ]
        ]
    },
    {
        "id": "698f6870ab9ffea7",
        "type": "link in",
        "z": "dfa2ea8601dc4518",
        "g": "3309ffc04a216e40",
        "name": "Broker_Password_in",
        "links": [
            "081a4d809dc9018e"
        ],
        "x": 115,
        "y": 700,
        "wires": [
            [
                "3cb083ba64129d24"
            ]
        ]
    },
    {
        "id": "fd5bbf99e156f067",
        "type": "ui-button",
        "z": "dfa2ea8601dc4518",
        "g": "3309ffc04a216e40",
        "group": "858d2c8bdccf259b",
        "name": "Show Password ?",
        "label": "Show Password",
        "order": 6,
        "width": "2",
        "height": "1",
        "emulateClick": false,
        "tooltip": "",
        "color": "",
        "bgcolor": "",
        "className": "",
        "icon": "eye-remove-outline",
        "iconPosition": "left",
        "payload": "yes",
        "payloadType": "str",
        "topic": "topic",
        "topicType": "msg",
        "buttonColor": "",
        "textColor": "",
        "iconColor": "",
        "enableClick": true,
        "enablePointerdown": false,
        "pointerdownPayload": "",
        "pointerdownPayloadType": "str",
        "enablePointerup": false,
        "pointerupPayload": "",
        "pointerupPayloadType": "str",
        "x": 190,
        "y": 740,
        "wires": [
            [
                "f295b7dfa1823e2a",
                "e5f2093494699767"
            ]
        ]
    },
    {
        "id": "70d27fecf9d0f6b3",
        "type": "ui-text",
        "z": "dfa2ea8601dc4518",
        "g": "3309ffc04a216e40",
        "group": "858d2c8bdccf259b",
        "order": 7,
        "width": "2",
        "height": "1",
        "name": "Show Passw,",
        "label": "Password",
        "format": "{{msg.payload}}",
        "layout": "col-center",
        "style": false,
        "font": "",
        "fontSize": 16,
        "color": "#717171",
        "wrapText": false,
        "className": "",
        "x": 750,
        "y": 740,
        "wires": []
    },
    {
        "id": "f295b7dfa1823e2a",
        "type": "change",
        "z": "dfa2ea8601dc4518",
        "g": "3309ffc04a216e40",
        "name": "Broker_Password",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "Broker_Password",
                "tot": "global"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 410,
        "y": 740,
        "wires": [
            [
                "70d27fecf9d0f6b3"
            ]
        ]
    },
    {
        "id": "e5f2093494699767",
        "type": "delay",
        "z": "dfa2ea8601dc4518",
        "g": "3309ffc04a216e40",
        "name": "",
        "pauseType": "delay",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 380,
        "y": 780,
        "wires": [
            [
                "d1d53addb7c64437"
            ]
        ]
    },
    {
        "id": "d1d53addb7c64437",
        "type": "change",
        "z": "dfa2ea8601dc4518",
        "g": "3309ffc04a216e40",
        "name": "clear",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": " ",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 520,
        "y": 780,
        "wires": [
            [
                "70d27fecf9d0f6b3"
            ]
        ]
    },
    {
        "id": "f046317729829edf",
        "type": "change",
        "z": "dfa2ea8601dc4518",
        "g": "331dfcc16357afd3",
        "name": "USB serial port",
        "rules": [
            {
                "t": "set",
                "p": "USB_serial_port",
                "pt": "global",
                "to": "payload",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 480,
        "y": 880,
        "wires": [
            [
                "a860585537cd655c"
            ]
        ]
    },
    {
        "id": "504a0728ea25b990",
        "type": "link in",
        "z": "dfa2ea8601dc4518",
        "g": "331dfcc16357afd3",
        "name": "USB_serial_port_in",
        "links": [
            "42c42f151143fc33"
        ],
        "x": 115,
        "y": 880,
        "wires": [
            [
                "08f864ae8a8410af"
            ]
        ]
    },
    {
        "id": "08f864ae8a8410af",
        "type": "ui-text-input",
        "z": "dfa2ea8601dc4518",
        "g": "331dfcc16357afd3",
        "group": "858d2c8bdccf259b",
        "name": "USB serial port",
        "label": "USB serial port",
        "order": 9,
        "width": "4",
        "height": "1",
        "topic": "topic",
        "topicType": "msg",
        "mode": "text",
        "tooltip": "Veuillez entrer le nom de votre interface USB / RS485. Ex: /dev/ttyUSB1",
        "delay": 300,
        "passthru": true,
        "sendOnDelay": false,
        "sendOnBlur": false,
        "sendOnEnter": true,
        "className": "",
        "clearable": true,
        "sendOnClear": false,
        "icon": "",
        "iconPosition": "left",
        "iconInnerPosition": "inside",
        "x": 240,
        "y": 880,
        "wires": [
            [
                "f046317729829edf"
            ]
        ]
    },
    {
        "id": "8eba824391b30950",
        "type": "switch",
        "z": "dfa2ea8601dc4518",
        "g": "259fe46998b37b22",
        "name": "USB_serial_port vide ?",
        "property": "USB_serial_port",
        "propertyType": "global",
        "rules": [
            {
                "t": "null"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 400,
        "y": 360,
        "wires": [
            [
                "5d682238eaebc0e9",
                "2b3a79e14d5983b1"
            ],
            [
                "42c42f151143fc33"
            ]
        ]
    },
    {
        "id": "9e1ff26caf038053",
        "type": "inject",
        "z": "dfa2ea8601dc4518",
        "g": "259fe46998b37b22",
        "name": "USB_serial_port",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "USB_serial_port",
        "payloadType": "global",
        "x": 160,
        "y": 360,
        "wires": [
            [
                "8eba824391b30950"
            ]
        ]
    },
    {
        "id": "42c42f151143fc33",
        "type": "link out",
        "z": "dfa2ea8601dc4518",
        "g": "259fe46998b37b22",
        "name": "USB_serial_port_out",
        "mode": "link",
        "links": [
            "504a0728ea25b990"
        ],
        "x": 815,
        "y": 368,
        "wires": []
    },
    {
        "id": "5d682238eaebc0e9",
        "type": "change",
        "z": "dfa2ea8601dc4518",
        "g": "259fe46998b37b22",
        "name": "Please fill it",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "Please fill it",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 630,
        "y": 340,
        "wires": [
            [
                "42c42f151143fc33"
            ]
        ]
    },
    {
        "id": "2b3a79e14d5983b1",
        "type": "debug",
        "z": "dfa2ea8601dc4518",
        "g": "259fe46998b37b22",
        "name": "debug 10",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 630,
        "y": 380,
        "wires": []
    },
    {
        "id": "ea324554d0bd9024",
        "type": "link out",
        "z": "dfa2ea8601dc4518",
        "g": "8ca20acee7a5ced4",
        "name": "Sauvegarde_parametres_out",
        "mode": "link",
        "links": [],
        "x": 605,
        "y": 520,
        "wires": []
    },
    {
        "id": "3ce30d1dddc257b6",
        "type": "link out",
        "z": "dfa2ea8601dc4518",
        "g": "3309ffc04a216e40",
        "name": "Sauvegarde_parametres_out",
        "mode": "link",
        "links": [],
        "x": 675,
        "y": 640,
        "wires": []
    },
    {
        "id": "a860585537cd655c",
        "type": "link out",
        "z": "dfa2ea8601dc4518",
        "g": "331dfcc16357afd3",
        "name": "Sauvegarde_parametres_out",
        "mode": "link",
        "links": [],
        "x": 615,
        "y": 880,
        "wires": []
    },
    {
        "id": "5b14b666e62da67d",
        "type": "switch",
        "z": "c42476a3aa2dd79c",
        "g": "c5544de409dc3632",
        "name": "Topic ?",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "LCD-on-off",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "divers",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "divers-bit",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 4,
        "x": 240,
        "y": 140,
        "wires": [
            [
                "0e22f5085190544e",
                "8bc9c72eb8f36ff2"
            ],
            [
                "347c975cf903685a"
            ],
            [
                "8cf65bc85374df94"
            ],
            [
                "2d239cf871fcdd0f"
            ]
        ],
        "outputLabels": [
            "LCD-on-off",
            "",
            null,
            "Autres"
        ]
    },
    {
        "id": "63b5b654057c4381",
        "type": "link in",
        "z": "c42476a3aa2dd79c",
        "g": "c5544de409dc3632",
        "name": "Autres-topics-in",
        "links": [
            "bb5385e5fa6e8f58"
        ],
        "x": 145,
        "y": 140,
        "wires": [
            [
                "5b14b666e62da67d"
            ]
        ]
    },
    {
        "id": "2d239cf871fcdd0f",
        "type": "debug",
        "z": "c42476a3aa2dd79c",
        "g": "c5544de409dc3632",
        "name": "Autres topics",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 130,
        "y": 220,
        "wires": []
    },
    {
        "id": "0e2e65e40bcb2ac0",
        "type": "inject",
        "z": "c42476a3aa2dd79c",
        "g": "754c40640a559f32",
        "name": "",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "1",
        "payloadType": "num",
        "x": 470,
        "y": 140,
        "wires": [
            [
                "d5dca54b28d74f18"
            ]
        ]
    },
    {
        "id": "dbee32cce099fa83",
        "type": "debug",
        "z": "c42476a3aa2dd79c",
        "g": "754c40640a559f32",
        "name": "debug 9",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 720,
        "y": 180,
        "wires": []
    },
    {
        "id": "d5dca54b28d74f18",
        "type": "function",
        "z": "c42476a3aa2dd79c",
        "g": "754c40640a559f32",
        "name": "Lire LCD from x1114",
        "func": "// Node-RED function node pour générer la trame Modbus\nfunction generateModbusCommand() {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Construction de la trame sans CRC\n    const command = [\n        0x01,       // Slave ID\n        0x03,       // Function code (03 - Read Holding Registers)\n        0x11,       // Register address high byte\n        0x14,       // Register address low byte\n        0x00,       // Quantity high byte (1 registre, 2 octets)\n        0x01        // Quantity low byte\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    return Buffer.from(command);\n}\n\n// Envoi de la trame\nmsg.topic = \"LCD-on-off\"\nmsg.payload = generateModbusCommand();\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 640,
        "y": 140,
        "wires": [
            [
                "3d4605eb10a3d1dc"
            ]
        ]
    },
    {
        "id": "0e22f5085190544e",
        "type": "buffer-parser",
        "z": "c42476a3aa2dd79c",
        "g": "754c40640a559f32",
        "name": "LCD-on-off",
        "data": "payload",
        "dataType": "msg",
        "specification": "spec",
        "specificationType": "ui",
        "items": [
            {
                "type": "buffer",
                "name": "item2",
                "offset": 4,
                "length": 1,
                "offsetbit": 5,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "Port Switch",
                "offset": 3,
                "length": 1,
                "offsetbit": 3,
                "scale": "1",
                "mask": ""
            },
            {
                "type": "bool",
                "name": "LCD-on-off",
                "offset": 4,
                "length": 1,
                "offsetbit": 4,
                "scale": "1",
                "mask": ""
            }
        ],
        "swap1": "",
        "swap2": "",
        "swap3": "",
        "swap1Type": "swap",
        "swap2Type": "swap",
        "swap3Type": "swap",
        "msgProperty": "payload",
        "msgPropertyType": "str",
        "resultType": "keyvalue",
        "resultTypeType": "return",
        "multipleResult": false,
        "fanOutMultipleResult": false,
        "setTopic": true,
        "outputs": 1,
        "x": 470,
        "y": 180,
        "wires": [
            [
                "dbee32cce099fa83"
            ]
        ]
    },
    {
        "id": "3d4605eb10a3d1dc",
        "type": "link out",
        "z": "c42476a3aa2dd79c",
        "g": "754c40640a559f32",
        "name": "link out 13",
        "mode": "link",
        "links": [
            "305e1cac13589b0d"
        ],
        "x": 895,
        "y": 140,
        "wires": []
    },
    {
        "id": "e9a62d58d10aea04",
        "type": "inject",
        "z": "c42476a3aa2dd79c",
        "g": "39449a18b64acb51",
        "name": "",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "1",
        "payloadType": "num",
        "x": 470,
        "y": 280,
        "wires": [
            [
                "a627048a1842edd0"
            ]
        ]
    },
    {
        "id": "991b73c0d7830977",
        "type": "debug",
        "z": "c42476a3aa2dd79c",
        "g": "39449a18b64acb51",
        "name": "debug 25",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 820,
        "y": 320,
        "wires": []
    },
    {
        "id": "a627048a1842edd0",
        "type": "function",
        "z": "c42476a3aa2dd79c",
        "g": "39449a18b64acb51",
        "name": "Lire - DIVERS: x1078",
        "func": "// Node-RED function node pour générer la trame Modbus\nfunction generateModbusCommand() {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Construction de la trame sans CRC\n    const command = [\n        0x01,       // Slave ID\n        0x03,       // Function code (03 - Read Holding Registers)\n        0x10,       // Register address high byte (0x12)\n        0x70,       // Register address low byte (0xC4)\n        0x00,       // Quantity high byte (1 registre, 2 octets)\n        0x02        // Quantity low byte (1 registre, 2 octets)\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    return Buffer.from(command);\n}\n\n// Envoi de la trame\nmsg.topic = \"divers\";\nmsg.payload = generateModbusCommand();\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 640,
        "y": 280,
        "wires": [
            [
                "30ec269020be3cfd"
            ]
        ]
    },
    {
        "id": "347c975cf903685a",
        "type": "buffer-parser",
        "z": "c42476a3aa2dd79c",
        "g": "39449a18b64acb51",
        "name": "cell cell_voltage_overvoltage_protection",
        "data": "payload",
        "dataType": "msg",
        "specification": "spec",
        "specificationType": "ui",
        "items": [
            {
                "type": "uint32be",
                "name": "divers",
                "offset": 3,
                "length": 1,
                "offsetbit": 0,
                "scale": "1",
                "mask": ""
            }
        ],
        "swap1": "",
        "swap2": "",
        "swap3": "",
        "swap1Type": "swap",
        "swap2Type": "swap",
        "swap3Type": "swap",
        "msgProperty": "payload",
        "msgPropertyType": "str",
        "resultType": "keyvalue",
        "resultTypeType": "return",
        "multipleResult": false,
        "fanOutMultipleResult": false,
        "setTopic": true,
        "outputs": 1,
        "x": 560,
        "y": 320,
        "wires": [
            [
                "991b73c0d7830977"
            ]
        ]
    },
    {
        "id": "30ec269020be3cfd",
        "type": "link out",
        "z": "c42476a3aa2dd79c",
        "g": "39449a18b64acb51",
        "name": "link out 6",
        "mode": "link",
        "links": [
            "305e1cac13589b0d"
        ],
        "x": 895,
        "y": 280,
        "wires": []
    },
    {
        "id": "8bc9c72eb8f36ff2",
        "type": "debug",
        "z": "c42476a3aa2dd79c",
        "g": "c5544de409dc3632",
        "name": "debug 4",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 420,
        "y": 80,
        "wires": []
    },
    {
        "id": "3d490c4684163fca",
        "type": "inject",
        "z": "c42476a3aa2dd79c",
        "g": "d3d5c2188bb8b56e",
        "name": "",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "1",
        "payloadType": "num",
        "x": 470,
        "y": 420,
        "wires": [
            [
                "33a274fa6b859154"
            ]
        ]
    },
    {
        "id": "142bf6609d8a7858",
        "type": "debug",
        "z": "c42476a3aa2dd79c",
        "g": "d3d5c2188bb8b56e",
        "name": "debug 7",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 700,
        "y": 460,
        "wires": []
    },
    {
        "id": "33a274fa6b859154",
        "type": "function",
        "z": "c42476a3aa2dd79c",
        "g": "d3d5c2188bb8b56e",
        "name": "Lire - DIVERs bit's",
        "func": "// Node-RED function node pour générer la trame Modbus\nfunction generateModbusCommand() {\n    // Fonction de calcul CRC16 Modbus\n    function crc16(buffer) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buffer.length; i++) {\n            crc ^= buffer[i];\n            for (let j = 0; j < 8; j++) {\n                if (crc & 0x0001) {\n                    crc = (crc >> 1) ^ 0xA001;\n                } else {\n                    crc = crc >> 1;\n                }\n            }\n        }\n        return crc;\n    }\n\n    // Construction de la trame sans CRC\n    const command = [\n        0x01,       // Slave ID\n        0x03,       // Function code (03 - Read Holding Registers)\n        0x11,       // Register address high byte (0x11)\n        0x14,       // Register address low byte (0x14)\n        0x00,       // Quantity high byte (1 registre, 2 octets)\n        0x01        // Quantity low byte (1 registre, 2 octets)\n    ];\n\n    // Calcul du CRC\n    const crc = crc16(Buffer.from(command));\n    \n    // Ajout du CRC à la trame (en ordre inverse car little-endian)\n    command.push(crc & 0xFF);         // CRC low byte\n    command.push((crc >> 8) & 0xFF);  // CRC high byte\n\n    return Buffer.from(command);\n}\n\n// Envoi de la trame\nmsg.topic = \"divers-bit\";\nmsg.payload = generateModbusCommand();\n\n// Fonction pour extraire les 9 premiers bits de la réponse\nmsg.extractBits = function(response) {\n    if (response && response.length >= 5) {\n        const uint16Value = (response[3] << 8) | response[4];\n        let bitStates = {};\n        for (let i = 0; i < 9; i++) {\n            bitStates[`bit${i}`] = (uint16Value >> i) & 1;\n        }\n        return bitStates;\n    }\n    return null;\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 630,
        "y": 420,
        "wires": [
            [
                "d1d7ba8380ba4e39"
            ]
        ]
    },
    {
        "id": "d1d7ba8380ba4e39",
        "type": "link out",
        "z": "c42476a3aa2dd79c",
        "g": "d3d5c2188bb8b56e",
        "name": "link out 1",
        "mode": "link",
        "links": [
            "305e1cac13589b0d"
        ],
        "x": 895,
        "y": 420,
        "wires": []
    },
    {
        "id": "8cf65bc85374df94",
        "type": "function",
        "z": "c42476a3aa2dd79c",
        "g": "d3d5c2188bb8b56e",
        "name": "function 3",
        "func": "if (msg.payload && msg.payload.length >= 5) {\n    msg.payload = msg.extractBits(msg.payload);\n}\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 460,
        "wires": [
            [
                "142bf6609d8a7858"
            ]
        ]
    },
    {
        "id": "ea5ef01450d064c2",
        "type": "inject",
        "z": "c42476a3aa2dd79c",
        "g": "49a4091113d20136",
        "name": "Allumer écran",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": "",
        "topic": "",
        "payload": "01 10 11 14 00 01 02 32 10 B0 E9",
        "payloadType": "str",
        "x": 150,
        "y": 640,
        "wires": [
            [
                "7d10fe7928d35c9e"
            ]
        ]
    },
    {
        "id": "1a7ba77a039ff8a5",
        "type": "inject",
        "z": "c42476a3aa2dd79c",
        "g": "49a4091113d20136",
        "name": "Eteindre écran",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": "",
        "topic": "",
        "payload": "01 10 11 14 00 01 02 32 00 b1 25",
        "payloadType": "str",
        "x": 160,
        "y": 680,
        "wires": [
            [
                "7d10fe7928d35c9e"
            ]
        ]
    },
    {
        "id": "7d10fe7928d35c9e",
        "type": "function",
        "z": "c42476a3aa2dd79c",
        "g": "49a4091113d20136",
        "name": "Conversion Hex",
        "func": "// Convertit la chaîne hex en buffer\nmsg.payload = Buffer.from(msg.payload.split(' ').map(x => parseInt(x, 16)));\nreturn msg;",
        "outputs": 1,
        "x": 560,
        "y": 620,
        "wires": [
            [
                "5df172e294de3c89"
            ]
        ]
    },
    {
        "id": "5df172e294de3c89",
        "type": "link out",
        "z": "c42476a3aa2dd79c",
        "g": "49a4091113d20136",
        "name": "link out 4",
        "mode": "link",
        "links": [
            "305e1cac13589b0d"
        ],
        "x": 675,
        "y": 620,
        "wires": []
    },
    {
        "id": "f1dc521817c84612",
        "type": "change",
        "z": "c42476a3aa2dd79c",
        "g": "49a4091113d20136",
        "name": "On",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "01 10 11 14 00 01 02 32 10 B0 E9",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 390,
        "y": 600,
        "wires": [
            [
                "7d10fe7928d35c9e"
            ]
        ]
    },
    {
        "id": "496e4bb443b0bf0b",
        "type": "switch",
        "z": "c42476a3aa2dd79c",
        "g": "49a4091113d20136",
        "name": "On / Off ?",
        "property": "payload",
        "propertyType": "msg",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 250,
        "y": 600,
        "wires": [
            [
                "f1dc521817c84612"
            ],
            [
                "edd8784d0c5d79c2"
            ]
        ]
    },
    {
        "id": "edd8784d0c5d79c2",
        "type": "change",
        "z": "c42476a3aa2dd79c",
        "g": "49a4091113d20136",
        "name": "Off",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "01 10 11 14 00 01 02 32 00 b1 25",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 390,
        "y": 660,
        "wires": [
            [
                "7d10fe7928d35c9e"
            ]
        ]
    }
]